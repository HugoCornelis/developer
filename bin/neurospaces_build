#!/usr/bin/perl
#!/usr/bin/perl -w -d:ptkdb
#


use strict;


use Getopt::Long;

use Neurospaces::Developer;

use YAML;


# See https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=707229

BEGIN
{
    $INC{'Mo/builder.pm'} = 1;
    $INC{'Mo/default.pm'} = 1;
}


# options related to operation mode selection:

our $option_client = 0;
our $option_developer = 0;

# operation execution profile: default is configure, compile and install

our $option_certification_report = 0;
our $option_check = 0;
our $option_clean = 0;
our $option_compile = 1;
our $option_configure_with_prefix = 0;
our $option_configure = 1;
our $option_configure_type = 'release';
our $option_countcode;
our $option_directories_create = 0;
our $option_dist = 0;
our $option_dist_dir = [];
our $option_distcheck = 0;
our $option_distclean = 0;
our $option_distkeywords = 0;
our $option_docs = 0;
our $option_dry_run = 0;
our $option_install = 1;
our $option_installed_versions = 1;
our $option_keep_going;
our $option_mac_universal = 0;
our $option_package_disabled_included = 0;
our $option_package_tags = [];
our $option_regex_selector = ".*";
our $option_repo_ci = 0;
our $option_repo_clone = 0;
our $option_repo_co = 0;
our $option_repo_diff = 0;
our $option_repo_history = 0;
our $option_repo_history_last = 2;
our $option_repo_init = 0;
our $option_repo_keys = 0;
our $option_repo_migrate = 0;
our $option_repo_pull = 0;
our $option_repo_push = 0;
our $option_repo_revert = 0;
our $option_repo_serve = 0;
our $option_repo_setup = 0;
our $option_repo_status = 0;
our $option_repo_sync = 0;
our $option_tag = 0;
our $option_uninstall = 0;
our $option_upload_server;
our $option_upstream_version;
our $option_verbose = 0;
our $option_website_prepare;
our $option_website_upload;


# options for source code and package distribution.
our $option_pkg_deb = 0;
our $option_pkg_deb_dir = 0;
our $option_pkg_rpm = 0;
our $option_pkg_rpm_dir = 0;
our $option_pkg_tar = 0;
our $option_pkg_tar_dir = 0;
our $option_version_major = 0;
our $option_version_minor = 0;
our $option_version_micro = 0;
our $option_version_tag = 0;
our $option_release_tag = 0;

# options related to installation on a client machine

our $option_src_tag;
our $option_src_dir;
our $option_download_server = 0;
our $option_unpack;

# options related to behavior of external applications

our $option_environment = [];


my $all_operations = [];


my $automated_merges = Neurospaces::Developer::Configurator::whole_build_configuration_automated_merges();

my $all_packages = $Neurospaces::Developer::Configurator::default_packages;

my $build_report
    = {
       description => {
		       command => $0,
		       name => "Build report",
		      },
       global => {
# 		  config => $config,
# 		  error_count => $error_count,
		  status => 'initializing',
		  test_count => 0,
		  time_start => `date`,
		 },
       client => {
		  OS => $^O,
		 },
      };


$SIG{'__DIE__'}
    = sub
      {
	  use Carp;

	  print STDERR Carp::longmess(@_);

	  $build_report->{global}->{status} = 'Died: ' . join " ", @_;

	  report_exit(3, @_);
      };


$SIG{'INT'}
    = sub
      {
	  $build_report->{global}->{status} = 'Interrupted';

	  report_exit(2);
      };


sub all_operations_execute
{
    # initialize operations related matters

    $build_report->{operations} = [];

    my $operations = $build_report->{operations};

    # loop over all packages, in dependency order

    foreach my $package_name (sort
			      {
				  $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
			      }
			      keys %$all_packages)
    {
	if ($option_verbose)
	{
	    print "$0: examining package $package_name\n";
	}

	my $package = $all_packages->{$package_name};

	# skip disabled packages

	if ($package->{disabled})
	{
	    if ($option_verbose)
	    {
		print "$0: package $package_name skipped, disabled is $package->{disabled}\n";
	    }

	    next;
	}

	# skip packages that are not selected by regex

	if ($package_name !~ /$option_regex_selector/i)
	{
	    if ($option_verbose)
	    {
		print "$0: package $package_name skipped, not selected using --regex-selector\n";
	    }

	    next;
	}

	# skip packages that are not selected by tag

	if (@$option_package_tags)
	{
	    my $selected = 0;

	    my $package_tags = $package->{tags} || [];

	    foreach my $package_tag (@$package_tags)
	    {
		foreach my $option_package_tag (@$option_package_tags)
		{
		    if ($package_tag eq $option_package_tag)
		    {
			$selected = $package_tag;
		    }
		}
	    }

	    if (not $selected)
	    {
		if ($option_verbose)
		{
		    print "$0: package $package_name skipped, not selected by --package-tags\n";
		}

		next;
	    }
	}

	# when packages are explicitly listed on the command line, only select those and exclude all the other ones

	if (@ARGV)
	{
	    my $selected = 0;

	    foreach my $argument (@ARGV)
	    {
		if ($package_name eq $argument)
		{
		    $selected = $package_name;
		}
	    }

	    if (not $selected)
	    {
		if ($option_verbose)
		{
		    print "$0: package $package_name skipped, not a command line argument\n";
		}

		next;
	    }
	}

	# loop over all package operations

	foreach my $all_operation (@$all_operations)
	{
	    my $condition_value = $all_operation->{condition};

	    my $operation = $all_operation->{implementation};

	    my $description = $all_operation->{description};

	    # construct package directory

	    my $target_directory = $package->{directory};

	    # if we are working on a client machine

	    if ($option_client)
	    {
		if (!defined $option_src_dir
		    || !defined $option_src_tag)
		{
		    die "$0: *** Error: you must set option_src_dir and option_src_tag when working in client mode";
		}

		# construct a target directory from the src-* options

		$target_directory = $option_src_dir . "/" . $package_name . "-" . $option_src_tag;
	    }

	    my $filename = $package_name . "-" . (defined $option_src_tag ? $option_src_tag : '') . ".tar.gz";

	    my $prefix = $option_download_server =~ m|://| ? '' : 'http://';

	    my $url = $prefix . $option_download_server . "/neurospaces/" . $filename;

	    my $directory = $option_src_dir ? $option_src_dir : $target_directory;

	    if (ref $description eq 'CODE')
	    {
		$description
		    = &$description
			(
			 {
# 			  description => $description,
			  directory => $directory,
			  ( $option_src_tag ? (filename => $filename,) : (), ),
			  operations => $operations,
			  package => $package,
			  package_name => $package_name,
			  url => $url,
			 },
			);

		if (ref $description eq 'ARRAY')
		{
		    $description = join ' ', @$description;
		}
	    }

	    if (ref $condition_value eq 'CODE')
	    {
		$condition_value
		    = &$condition_value
			(
			 {
			  description => $description,
			  directory => $directory,
			  ( $option_src_tag ? (filename => $filename,) : (), ),
			  operations => $operations,
			  package => $package,
			  package_name => $package_name,
			  url => $url,
			 },
			);
	    }

# 	    $description ||= (join ' ', @$operation );

	    # if the uninstall option is given

	    if ($option_uninstall)
	    {
		# but this operation is not uninstall

		if (ref $operation eq 'ARRAY'
		    && exists $operation->[5]
		    && $operation->[5] ne 'uninstall')
		{
		    # don't execute, doesnot make sense

		    $condition_value = 0;

		    if ($option_verbose > 1)
		    {
			print "$0: package $package_name [" . $description . "] condition turned to false \n";
		    }

		}
	    }

	    # if the operation's condition is true

	    if ($condition_value)
	    {
		if ($option_verbose > 1)
		{
		    print "$0: package $package_name [" . $description . "] preparing to execute \n";
		}

		# at this time, the operation was not executed yet

		my $operation_executed = 0;

		# if this is perl code

		if (ref $operation eq 'CODE')
		{
		    # register that we are about to do this operation for this package

		    push @$operations, { package_name => $package_name, operations => $operation, };

		    if (!$option_dry_run)
		    {
			my $result
			    = &$operation
				(
				 {
				  description => $description,
				  directory => $directory,
				  ( $option_src_tag ? (filename => $filename,) : (), ),
				  operations => $operations,
				  package => $package,
				  package_name => $package_name,
				  url => $url,
				 },
				);

			if (ref $result eq 'ARRAY')
			{
			    $operation_executed = 0;

			    $operation = $result;
			}
			else
			{
			    $operation_executed = 1;
			}
		    }
		    else
		    {
			if ($option_verbose)
			{
			    # embedded perl code

			    use Data::Dumper;

			    local $Data::Dumper::Deparse = 1;

			    my $perl_code = Dumper($operation);

			    print "$0: package $package_name [" . (join ' ', $perl_code ) . "] not executed, dry_run is $option_dry_run\n";
			}

			$operation_executed = 1;
		    }
		}

		# if the operation still needs execution

		if (not $operation_executed)
		{
		    # if package directory exists

		    if (-e $target_directory)
		    {
			# go to package directory

			use Cwd;

			my $current_directory = getcwd();

			if ($option_verbose > 1)
			{
			    print "$0: package $package_name, chdir from ($current_directory) to ($target_directory)\n";
			}

			my $success = chdir $target_directory;

			if (!$success)
			{
			    die "$0: *** Error: package $package_name cannot change from directory ($current_directory) to directory ($target_directory): $!";
			}

			# add options specific to this operation and package

			# here we implement the separation between debug and release

			my $package_options = [];

			push
			    @$package_options,
				@{$package->{$operation->[0]} || []};

			# if the command is listed as having specific options

			if ($package->{operations}->{$operation->[0]})
			{
			    # construct variable name for type of build: remove things like './' from configure lines

			    my $text = $operation->[0];

			    $text =~ s(\./)();

			    $text = "\$option_" . $text . "_type";

			    # get the value of the specific options (fi the build type)

			    my $type = eval $text;

			    if ($@)
			    {
				die $@;
			    }

			    # construct options for this operation

			    my $build_type_options = $package->{operations}->{$operation->[0]}->{$type};

			    push
				@$package_options,
				    @$build_type_options;
			}

			# perform the operation on the package

			Neurospaces::Developer::Operations::operation_execute
			    (
			     $operations,
			     {
			      description => $description,
			      keywords => $option_developer,
			      package_name => $package_name,
			     },
			     [
			      @$operation,
			      @$package_options,
			     ],
			    );

			if ($option_verbose > 1)
			{
			    print "$0: package $package_name, chdir from ($target_directory) to ($current_directory)\n";
			}

			$success = chdir $current_directory;

			if (!$success)
			{
			    die "$0: *** Error: package $package_name, cannot change from directory ($target_directory) to directory ($current_directory): $!";
			}
		    }
		    else
		    {
			if ($option_verbose)
			{
			    print "$0: package $package_name skipped, [" . $description . "], directory ($target_directory) not found, assuming this package source is not installed\n";
			}
		    }
		}
	    }
	    else
	    {
		if ($option_verbose > 1)
		{
		    print "$0: package $package_name [" . $description . "] skipped, condition_value is $condition_value\n";
		}
	    }
	}
    }
}


sub main
{
    read_cmd_line();

    # set status: running

    $build_report->{global}->{status} = 'Running';

    # execute all operations

    all_operations_execute();

    # finish

    $build_report->{global}->{status} = 'Finished';

    report_exit(0);
}


sub read_cmd_line
{
    my $option_disable;
    my $option_enable;
    my $option_help = 0;
    my $option_help_all = 0;
    my $option_help_build_order = 0;
    my $option_help_descriptions = 0;
    my $option_help_operations = 0;
    my $option_help_packages = 0;
    my $option_help_repositories;
    my $option_version;

    my $result
	= GetOptions
	    (
	     # options related to operation mode selection:

	     "client!" => \$option_client,
	     "developer!" => \$option_developer,

	     # operation execution profile: default is configure, compile and install

	     "certification-report!" => \$option_certification_report,
	     "check!" => \$option_check,
	     "clean!" => \$option_clean,
	     "compile!" => \$option_compile,
	     "configure!" => \$option_configure,
	     "configure-with-prefix!" => \$option_configure_with_prefix,
	     "configure-type=s" => \$option_configure_type,
	     "countcode=s" => \$option_countcode,
	     "directories-create!" => \$option_directories_create,
	     "disable=s" => \$option_disable,
	     "dist!" => \$option_dist,
	     "distcheck!" => \$option_distcheck,
	     "distclean!" => \$option_distclean,
	     "dist-dir=s" => $option_dist_dir,
	     "distkeywords!" => \$option_distkeywords,
	     "docs!" => \$option_docs,
	     "dry-run!" => \$option_dry_run,
	     "enable=s" => \$option_enable,
	     "help!" => \$option_help,
	     "help-all!" => \$option_help_all,
	     "help-build-order!" => \$option_help_build_order,
	     "help-descriptions!" => \$option_help_descriptions,
	     "help-operations!" => \$option_help_operations,
	     "help-packages!" => \$option_help_packages,
	     "help-repositories!" => \$option_help_repositories,
	     "install!" => \$option_install,
	     "installed-versions!" => \$option_installed_versions,
	     "keep-going!" => \$option_keep_going,
	     "package-disabled-included!" => \$option_package_disabled_included,
	     "package-tags=s" => $option_package_tags,
	     "pkg-deb" => \$option_pkg_deb,
	     "pkg-deb-dir=s" => \$option_pkg_deb_dir,
	     "pkg-rpm" => \$option_pkg_rpm,
	     "pkg-rpm-dir=s" => \$option_pkg_rpm_dir,
	     "pkg-tar" => \$option_pkg_tar,
	     "pkg-tar-dir=s" => \$option_pkg_tar_dir,
	     "regex-selector=s" => \$option_regex_selector,
	     "release-tag=s" => \$option_release_tag,
	     "repo-ci=s" => \$option_repo_ci,
	     "repo-clone=s" => \$option_repo_clone,
	     "repo-co!" => \$option_repo_co,
	     "repo-diff!" => \$option_repo_diff,
	     "repo-init!" => \$option_repo_init,
	     "repo-keys!" => \$option_repo_keys,
	     "repo-migrate!" => \$option_repo_migrate,
	     "repo-history!" => \$option_repo_history,
	     "repo-history-last=i" => \$option_repo_history_last,
	     "repo-pull=s" => \$option_repo_pull,
	     "repo-push=s" => \$option_repo_push,
	     "repo-revert!" => \$option_repo_revert,
	     "repo-serve!" => \$option_repo_serve,
	     "repo-setup!" => \$option_repo_setup,
	     "repo-status!" => \$option_repo_status,
	     "repo-sync=s" => \$option_repo_sync,
	     "tag=s" => \$option_tag,
	     "uninstall!" => \$option_uninstall,
	     "universal!" => \$option_mac_universal,
	     "upload-server=s" => \$option_upload_server,
	     "upstream-version=s" => \$option_upstream_version,
	     "verbose+" => \$option_verbose,
	     "version" => \$option_version,
	     "version-tag=s" => \$option_version_tag,
	     "website-prepare!" => \$option_website_prepare,
	     "website-upload!" => \$option_website_upload,

	     # options related to installation on a client machine

	     "download-server=s" => \$option_download_server,
	     "src-tag=s" => \$option_src_tag,
	     "src-dir=s" => \$option_src_dir,
	     "unpack!" => \$option_unpack,

	     # options related to behavior of external applications

	     "environment=s" => $option_environment,
	    );

    if (!$result)
    {
	die "$0: *** Error: Error in option processing";
    }

    # process operation mode options

    #! we give client mode precedence over developer mode

    if (!$option_client
	&& !$option_developer)
    {
	$option_client = 1;
    }

    if ($option_client)
    {
	$option_developer = 0;
    }

    if ($option_developer)
    {
	$option_client = 0;
    }

    # fill in the build report

    $build_report->{options}
	= {
	   # options related to operation mode selection:

	   "client!" => $option_client,
	   "developer!" => $option_developer,

	   # operation execution profile: default is configure, compile and install

	   "certification-report!" => $option_certification_report,
	   "check!" => $option_check,
	   "clean!" => $option_clean,
	   "compile!" => $option_compile,
	   "configure!" => $option_configure,
	   "configure-with-prefix!" => $option_configure_with_prefix,
	   "configure-type=s" => $option_configure_type,
	   "countcode=s" => $option_countcode,
	   "directories-create!" => $option_directories_create,
	   "disable=s" => $option_disable,
	   "dist!" => $option_dist,
	   "distcheck!" => $option_distcheck,
	   "distclean!" => $option_distclean,
	   "dist-dir=s" => $option_dist_dir,
	   "distkeywords!" => $option_distkeywords,
	   "docs!" => $option_docs,
	   "dry-run!" => $option_dry_run,
	   "enable=s" => $option_enable,
	   "help!" => $option_help,
	   "help-all!" => $option_help_all,
	   "help-build-order!" => $option_help_build_order,
	   "help-descriptions!" => $option_help_descriptions,
	   "help-operations!" => $option_help_operations,
	   "help-packages!" => $option_help_packages,
	   "help-repositories!" => $option_help_repositories,
	   "install!" => $option_install,
	   "installed-versions!" => $option_installed_versions,
	   "keep-going!" => $option_keep_going,
	   "package-disabled-included!" => $option_package_disabled_included,
	   "package-tags=s" => $option_package_tags,
	   "pkg-deb!" => $option_pkg_deb,
	   "pkg-deb-dir=s" => $option_pkg_deb_dir,
	   "pkg-rpm!" => $option_pkg_rpm,
	   "pkg-rpm-dir=s" => $option_pkg_rpm_dir,
	   "pkg-tar!" => $option_pkg_tar,
	   "pkg-tar-dir=s" => $option_pkg_tar_dir,
	   "regex-selector=s" => $option_regex_selector,
	   "release-tag=s" => $option_release_tag,
	   "repo-ci=s" => $option_repo_ci,
	   "repo-clone=s" => $option_repo_clone,
	   "repo-co!" => $option_repo_co,
	   "repo-diff!" => $option_repo_diff,
	   "repo-init!" => $option_repo_init,
	   "repo-keys!" => $option_repo_keys,
	   "repo-migrate!" => $option_repo_migrate,
	   "repo-history!" => $option_repo_history,
	   "repo-history-last=i" => $option_repo_history_last,
	   "repo-pull=s" => $option_repo_pull,
	   "repo-push=s" => $option_repo_push,
	   "repo-revert!" => $option_repo_revert,
	   "repo-serve!" => $option_repo_serve,
	   "repo-setup!" => $option_repo_setup,
	   "repo-status!" => $option_repo_status,
	   "repo-sync=s" => $option_repo_sync,
	   "tag=s" => $option_tag,
	   "universal!" => $option_mac_universal,
	   "uninstall!" => $option_uninstall,
	   "upload-server=s" => $option_upload_server,
	   "upstream-version=s" => $option_upstream_version,
	   "verbose+" => $option_verbose,
	   "version" => $option_version,
	   "version=s" => $option_version_tag,
	   "website-prepare!" => $option_website_prepare,
	   "website-upload!" => $option_website_upload,

	   # options related to installation on a client machine

	   "download-server=s" => $option_download_server,
	   "src-tag=s" => $option_src_tag,
	   "src-dir=s" => $option_src_dir,
	   "unpack!" => $option_unpack,

	   # options related to behavior of external applications

	   "environment=s" => $option_environment,
	  };

    if ($option_version)
    {
	my $version = version();

	print $version . "\n";

	exit 1;
    }

    # process enable and disable options overhere, such that there
    # effect is mirrored in the help output

    if ($option_enable)
    {
	# loop over all packages, in dependency order

	foreach my $package_name (sort
				  {
				      $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
				  }
				  keys %$all_packages)
	{
	    # if should be enabled

	    if ($package_name =~ /$option_enable/)
	    {
		# enable but don't overwrite existing value

		my $package = $all_packages->{$package_name};

		if ($package->{disabled})
		{
		    $package->{disabled} = 0;
		}
	    }
	}
    }

    if ($option_disable)
    {
	# loop over all packages, in dependency order

	foreach my $package_name (sort
				  {
				      $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
				  }
				  keys %$all_packages)
	{
	    # if should be disabled

	    if ($package_name =~ /$option_disable/)
	    {
		# disable but don't overwrite existing value

		my $package = $all_packages->{$package_name};

		if (!$package->{disabled})
		{
		    $package->{disabled} = $option_disable;
		}
	    }
	}
    }

    my $tag_set_in_tag_database = 0;

    # merge operations with options that affect the execution of the
    # operations

    $all_operations = Neurospaces::Developer::Operations::construct_all();

    # process environment options

#     # tell neurospaces_harness if to send emails for this

#     $ENV{NEUROSPACES_HARNESS_OPTION_EMAIL} = $option_neurospaces_harness_email;

    # build the environment for external applications

    foreach my $environment_setting (@$option_environment)
    {
	$environment_setting =~ /^(.*?)=(.*)$/;

	my $variable = $1;

	my $value = $2;

	$ENV{$variable} = $value;
    }

    if ($option_verbose
	&& @$option_environment)
    {
	use YAML;

	print Dump(\%ENV);
    }

    # reporting options

    if ($option_help)
#         || scalar @ARGV)
    {
	$0 =~ m(.*/(.*));

	my $program_name = $1;

	print "\n\n" . Dump($build_report->{options});

	print
	    "

$program_name: configure, compile, check, install, tag and build
releases of packages selected from a set of packages.

$program_name can operate in two modes: the default one is for a
client machine, assuming a user who tries to install the packages.
The second mode is for a developer who follows the Neurospaces
conventions where to put the src code of the packages.  The main
difference between the two modes is where this script finds the source
code.

$program_name creates a matrix of packages (rows) and build operations
(columns).  $program_name goes through the matrix, packages first, and
performs one build operation after the other for the selected package.
The options select or deselect cells in the matrix.

To find out what packages are in the database, use the '--help-packages'
option.  Disabled packages are not put in the matrix, enabled packages
are.  To disable packages, use the '--disable' option with a regex
argument.  To enable packages, use the '--enable' option with a regex
argument.  After building the matrix, rows are selected using
'--regex-selector' option, which by default selects all rows.

To find out about the known build operations, use '--help'.  To
disable a build operation, prefix the corresponding option with
'--no-', eg. to disable configure, use '--no-configure'.

options related to operation mode selection:
    --client                 execute in client mode (for regular users, default).
    --developer              execute in developer mode.

options related to operation execution profile:
    --certification-report      annotate the (monotone) repository with the build_report.
    --check                     check packages.
    --clean                     clean before compiling.
    --compile                   compile packages.
    --configure                 configure before compiling.
    --configure-with-prefix     configure with a hardcoded prefix.
    --configure-type            type of configuration (default is 'release').
    --countcode                 countcode at different times during the build.
    --describe                  describe the function of packages.
    --directories-create        create package directory structure.
    --disable                   explicitly disable this regex of packages in the configuration.
    --dist                      build distribution tarballs.
    --dist-dir                  distribution directories to copy the tarballs to?
    --distcheck                 check created tarballs.
    --distclean                 distclean before compiling.
    --distkeywords              do keyword expansion (be careful with this one).
    --docs                      generate docs during compilation.
    --dry-run                   do not execute any command, just report what would be done.
    --enable                    explicitly enable these regex of packages in the configuration.
    --help                      print usage information.
    --help-all                  print usage, all packages and all operations.
    --help-build-order          print information on software package build order.
    --help-descriptions         print descriptions of the function of packages.
    --help-operations           print known operations.
    --help-packages             print known packages, in order of build.
    --help-repositories         print known source code repositories.
    --install                   install packages.
    --installed-versions        print the installed version of each software package.
    --keep-going                keep going in case of non-fatal errors (ala make -k).
    --package-disabled-included also select disabled packages.
    --package-tags              select packages based on the given tag(s).
    --pkg-deb                   build debian packages for each software component.
    --pkg-deb-dir               Directory to place debian packages after a debian build.
    --pkg-rpm                   build RPM packages for each software component.
    --pkg-rpm-dir               Directory to place RPM packages after an RPM build.
    --pkg-tar                   build source tarballs for each software package.
    --pkg-tar-dir               Directory to place source tarballs into after creating a dist.
    --regex-selector            defines a regex to select specific packages.
    --release-tag               Sets a release tag for source code distribution.
    --repo-ci                   commit all modifications with the given changelog description.
    --repo-clone                checkout or update the workspace source code from a remote repository.
    --repo-co                   checkout or update the workspace source code from a local repository.
    --repo-diff                 show workspace differences against the local repository.
    --repo-init                 initialize those local repositories that do not exist yet.
    --repo-keys                 show public keys stored by version control systems.
    --repo-history              show locally stored history information of enabled software components.
    --repo-history-last         number of history records to show.
    --repo-pull                 pull the repositories from this server (e.g. repo-genesis3.cbi.utsa.edu).
    --repo-push                 push the repositories to this server (e.g. repo-genesis3.cbi.utsa.edu).
    --repo-serve                start the version control program in server mode to give others access to your code.
                                this will automatically fork processes as needed and return control to the terminal.
    --repo-setup                create a workspace interface to the version control repository if it does not exist yet.
    --repo-status               compare workspace with source code repository branch head.
    --repo-sync                 sync the repositories with this server (e.g. repo-genesis3.cbi.utsa.edu).
    --tag                       set this tag on all packages.
    --uninstall                 uninstall packages, cannot be combined with installation options.
    --universal                 sets flags for building universal binaries on Mac OS X.
    --upload-server             enable uploading packages to this server (e.g. https://frs.sourceforge.net/uploads).
    --version                   print version information.
    --version-tag               The software version for a source code distribution release.
    --v|verbose                 tell what is being done, specify multiple times to get more feedback.
    --website-prepare           prepare the website on your developer machine.
    --website-upload            upload the website to the webserver.

options related to installation on a client machine:
    --download-server           enable downloading packages from this server (e.g. downloads.sourceforge.net).
    --src-tag                   use this tag for finding src directories on a client machine.
    --src-dir                   use this dir as the base for directories on a client machine.

So on a client machine, for package xxx, the src are found in the
directory <src-dir>/xxx-<src-tag>.  From there the build starts as
usual.


options related to behavior of external applications:
    --environment               fills in the environment, can be given multiple times.
                                e.g. environment NEUROSPACES_HARNESS_OPTION_EMAIL=1 generates emails for tests that fail.

";

	exit 0;
    }

    # reporting options

    if ($option_help_all)
    {
	$0 =~ m(.*/(.*));

	my $program_name = $1;

	print Dump(
		   {
		    options => $build_report->{options},
		    usage =>
	    "

$program_name: configure, compile, check, install, tag and build
releases of packages selected from a set of packages.

$program_name can operate in two modes: the default one is for a
client machine, assuming a user who tries to install the packages.
The second mode is for a developer who follows the Neurospaces
conventions where to put the src code of the packages.  The main
difference between the two modes is where this script finds the source
code.

$program_name creates a matrix of packages (rows) and operations
(columns).  $program_name goes through the matrix, packages first, and
performs one build operation after the other for the selected package.
The options select or deselect cells in this operation / package
matrix.

To find out what packages are in the database, use the
'--help-packages' option.  Disabled packages are not put in the
matrix, enabled packages are.  To disable packages, use the
'--disable' option with a regex argument.  To enable packages, use the
'--enable' option with a regex argument.  After building the matrix,
rows are selected using '--regex-selector' option, which by default
selects all rows.  Arguments on the command line explicitly select
package, but deselect all other packages.

To find out about the known build operations, use '--help'.  To
disable a build operation, prefix the corresponding option with
'--no-', eg. to disable configure, use '--no-configure'.

options related to operation mode selection:
    --client                 execute in client mode (for regular users, default).
    --developer              execute in developer mode.

options related to operation execution profile:
    --certification-report      annotate the (monotone) repository with the build_report.
    --check                     check packages.
    --clean                     clean before compiling.
    --compile                   compile packages.
    --configure                 configure before compiling.
    --configure-with-prefix     configure with a hardcoded prefix.
    --configure-type            type of configuration (default is 'release').
    --countcode                 countcode at different times during the build.
    --describe                  describe the function of packages.
    --directories-create        create package directory structure.
    --disable                   explicitly disable this regex of packages in the configuration.
    --dist                      build distribution tarballs.
    --dist-dir                  distribution directories to copy the tarballs to?
    --distcheck                 check created tarballs.
    --distclean                 distclean before compiling.
    --distkeywords              do keyword expansion (be careful with this one).
    --docs                      generate docs during compilation.
    --dry-run                   do not execute any command, just report what would be done.
    --enable                    explicitly enable these regex of packages in the configuration.
    --help                      print usage information.
    --help-all                  print usage, all packages and all operations.
    --help-build-order          print information on software package build order.
    --help-descriptions         print descriptions of the function of packages.
    --help-operations           print known operations.
    --help-packages             print known packages, in order of build.
    --help-repositories         print known source code repositories.
    --install                   install packages.
    --installed-versions        print the installed version of each software package.
    --keep-going                keep going in case of non-fatal errors (ala make -k).
    --package-disabled-included also select disabled packages.
    --package-tags              select packages based on the given tag(s).
    --pkg-deb                   build debian packages for each software component.
    --pkg-deb-dir               Directory to place debian packages after a debian build.
    --pkg-rpm                   build RPM packages for each software component.
    --pkg-rpm-dir               Directory to place RPM packages after an RPM build.
    --pkg-tar                   build source tarballs for each software package.
    --pkg-tar-dir               Directory to place source tarballs into after creating a dist.
    --regex-selector            defines a regex to select specific packages.
    --release-tag               Sets a release tag for source code distribution.
    --repo-ci                   commit all modifications with the given changelog description.
    --repo-clone                checkout or update the workspace source code from a remote repository.
    --repo-co                   checkout or update the workspace source code from a local repository.
    --repo-diff                 show workspace differences against the local repository.
    --repo-init                 initialize those local repositories that do not exist yet.
    --repo-keys                 show public keys stored by version control systems.
    --repo-history              show locally stored history information of enabled software components.
    --repo-history-last         number of history records to show.
    --repo-pull                 pull the repositories from this server (e.g. repo-genesis3.cbi.utsa.edu).
    --repo-push                 push the repositories to this server (e.g. repo-genesis3.cbi.utsa.edu).
    --repo-serve                start the version control program in server mode to give others access to your code.
                                this will automatically fork processes as needed and return control to the terminal.
    --repo-setup                create a workspace interface to the version control repository if it does not exist yet.
    --repo-status               compare workspace with source code repository branch head.
    --repo-sync                 sync the repositories with this server (e.g. repo-genesis3.cbi.utsa.edu).
    --tag                       set this tag on all packages.
    --uninstall                 uninstall packages, cannot be combined with installation options.
    --universal                 sets flags for building universal binaries on Mac OS X.
    --upload-server             enable uploading packages to this server (e.g. https://frs.sourceforge.net/uploads).
    --version                   print version information.
    --version-tag               The software version for a source code distribution release.
    --v|verbose                 tell what is being done, specify multiple times to get more feedback.
    --website-prepare           prepare the website on your developer machine.
    --website-upload            upload the website to the webserver.

options related to installation on a client machine:
    --download-server           enable downloading packages from this server (e.g. downloads.sourceforge.net).
    --src-tag                   use this tag for finding src directories on a client machine.
    --src-dir                   use this dir as the base for directories on a client machine.

So on a client machine, for package xxx, the src are found in the
directory <src-dir>/xxx-<src-tag>.  From there the build starts as
usual.


options related to behavior of external applications:
    --environment               fills in the environment, can be given multiple times.
                                e.g. environment NEUROSPACES_HARNESS_OPTION_EMAIL=1 generates emails for tests that fail.

",

			all_packages => $all_packages,
			all_operations => $all_operations,
		       },
		      );

	exit 1;
    }

    if ($option_help_operations)
    {
	print
	    "$0:\n  operations in order of build:\n    - "
		. (
		   join
		   "\n    - ",
		   grep
		   {
		       $_ =~ /$option_regex_selector/i
		   }
		   map
		   {
		       $_->{description} || join ' ', @{$_->{implementation} || []},
		   }
		   @$all_operations,
		  )
		    . "\n";

	exit 1;
    }

    if ($option_help_build_order)
    {
	my $build_order
	    = [
	       map
	       {
		   my $result = $all_packages->{$_};

		   $result->{name} = $_;

		   delete $result->{directory};
		   delete $result->{operations};
		   delete $result->{disabled};
		   delete $result->{version_control};
		   delete $result->{version_script};

		   $result;
	       }
	       sort
	       {
		   $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
	       }
	       grep
	       {
		   not $all_packages->{$_}->{disabled}
	       }
	       grep
	       {
		   my $selected = 'by default';

		   if (@$option_package_tags)
		   {
		       $selected = 0;

		       my $package_tags = $all_packages->{$_}->{tags} || [];

		       foreach my $package_tag (@$package_tags)
		       {
			   foreach my $option_package_tag (@$option_package_tags)
			   {
			       if ($package_tag eq $option_package_tag)
			       {
				   $selected = $package_tag;
			       }
			   }
		       }
		   }

		   $selected;
	       }
	       grep
	       {
		   $_ =~ /$option_regex_selector/i
	       }
	       keys %$all_packages
	      ];

	use YAML;

	print Dump( { build_order => $build_order, }, );

	exit 1;
    }

    if ($option_help_descriptions)
    {
	my $descriptions
	    = [
	       map
	       {
		   my $package_information = $all_packages->{$_};

		   {
		       package => $_,
		       description => $package_information->{description},
		       tags => $all_packages->{$_}->{tags},
		   };
	       }
	       sort
	       {
		   $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
	       }
	       grep
	       {
		   not $all_packages->{$_}->{disabled}
	       }
	       grep
	       {
		   # when packages are explicitly listed on the command line, only select those and exclude all the other ones

		   my $selected = 1;

		   if (@ARGV)
		   {
		       $selected = 0;

		       foreach my $argument (@ARGV)
		       {
			   if ($_ eq $argument)
			   {
			       $selected = $_;
			   }
		       }
		   }

		   $selected;
	       }
	       grep
	       {
		   my $selected = 'by default';

		   if (@$option_package_tags)
		   {
		       $selected = 0;

		       my $package_tags = $all_packages->{$_}->{tags} || [];

		       foreach my $package_tag (@$package_tags)
		       {
			   foreach my $option_package_tag (@$option_package_tags)
			   {
			       if ($package_tag eq $option_package_tag)
			       {
				   $selected = $package_tag;
			       }
			   }
		       }
		   }

		   $selected;
	       }
	       grep
	       {
		   $_ =~ /$option_regex_selector/i
	       }
	       keys %$all_packages
	      ];

	use YAML;

	print Dump( { $0 => { descriptions => $descriptions, }, }, );

	exit 1;
    }

    if ($option_help_packages)
    {
	print
	    "---\nenabled packages in order of build:\n    - "
		. (
		   join
		   "\n    - ",
		   sort
		   {
		       $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
		   }
		   grep
		   {
		       not $all_packages->{$_}->{disabled}
		   }
		   grep
		   {
		       my $selected = 'by default';

		       if (@$option_package_tags)
		       {
			   $selected = 0;

			   my $package_tags = $all_packages->{$_}->{tags} || [];

			   foreach my $package_tag (@$package_tags)
			   {
			       foreach my $option_package_tag (@$option_package_tags)
			       {
				   if ($package_tag eq $option_package_tag)
				   {
				       $selected = $package_tag;
				   }
			       }
			   }
		       }

		       $selected;
		   }
		   grep
		   {
		       $_ =~ /$option_regex_selector/i
		   }
		   keys %$all_packages
		  )
		    . "\n";

	exit 1;
    }

    if ($option_help_repositories)
    {
	my $repositories
	    = [
	       map
	       {
		   my $package_information = $all_packages->{$_};

		    my $result;

		    if (exists $package_information->{version_control}->{git})
		    {
 			my $repository_server = `git 2>&1 -C "$package_information->{directory}/" remote -v`;

			$result
			    = {
			       ($all_packages->{$_}->{disabled} ? (disabled => $all_packages->{$_}->{disabled}) : ()),
			       package => $_,
			       repository_name => $package_information->{version_control}->{git}->{remote},
 			       repository_server => $repository_server,
			       tags => $all_packages->{$_}->{tags},
			      };
		    }
		    else
		    {
			my $repository_name
			    = $package_information->{version_control}->{repository}
				|| $package_information->{directory} . '/' . 'mtn';

			my $repository_server
			    = $package_information->{version_control}->{server}
				|| Neurospaces::Developer::Operations::version_control_translate_server($package_information, 'default');

			my $repository_port_number
			    = $package_information->{version_control}->{port_number};

			$result
			    = {
			       ($all_packages->{$_}->{disabled} ? (disabled => $all_packages->{$_}->{disabled}) : ()),
			       package => $_,
			       repository_name => $repository_name,
			       # 		       repository_port_number => $repository_port_number,
			       repository_server => $repository_server . ":" . $repository_port_number,
			       tags => $all_packages->{$_}->{tags},
			      };
		    }

		    $result;
	       }
	       sort
	       {
		   $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
	       }
	       grep
	       {
		   ($option_package_disabled_included or (not $all_packages->{$_}->{disabled}))
	       }
	       grep
	       {
		   # when packages are explicitly listed on the command line, only select those and exclude all the other ones

		   my $selected = 1;

		   if (@ARGV)
		   {
		       $selected = 0;

		       foreach my $argument (@ARGV)
		       {
			   if ($_ eq $argument)
			   {
			       $selected = $_;
			   }
		       }
		   }

		   $selected;
	       }
	       grep
	       {
		   my $selected = 'by default';

		   if (@$option_package_tags)
		   {
		       $selected = 0;

		       my $package_tags = $all_packages->{$_}->{tags} || [];

		       foreach my $package_tag (@$package_tags)
		       {
			   foreach my $option_package_tag (@$option_package_tags)
			   {
			       if ($package_tag eq $option_package_tag)
			       {
				   $selected = $package_tag;
			       }
			   }
		       }
		   }

		   $selected;
	       }
	       grep
	       {
		   $_ =~ /$option_regex_selector/i
	       }
	       keys %$all_packages
	      ];

	use YAML;

	print Dump( { $0 => { repositories => $repositories, }, }, );
	
	exit 1;
    }

    # when packages are explicitly listed on the command line, check if they exist in the configuration

    if (@ARGV)
    {
	my $nonexistent_packages = [];

	foreach my $argument (@ARGV)
	{
	    if (not exists $all_packages->{$argument})
	    {
		push @$nonexistent_packages, $argument;
	    }
	}

	if (scalar @$nonexistent_packages)
	{
	    my $nonexistent_packages_string = join ', ', map { "'$_'" } @$nonexistent_packages;

	    die "$0: *** Error: the following arguments are not found in the package configuration: $nonexistent_packages_string";
	}
    }

}


sub report_exit
{
    my $exit_code = shift;

    my $description = shift;

    $build_report->{global}->{time_end} = `date`;

    #! I remove the times here, just to ease the regression testing

    if ($ENV{NEUROSPACES_BUILD_TESTING})
    {
	delete $build_report->{global}->{time_end};
	delete $build_report->{global}->{time_start};
    }

    if (defined $description
        && $exit_code eq 3)
    {
	print "*** die: $description\n";
    }

    # yaml out the build report

    if ($option_verbose > 1)
    {
	print Dump($build_report);
    }

#     # if there were errors

#     if ($error_count)
#     {
# 	# exit with failure

# 	$exit_code ||= 1;

# 	print "$0: exit_code $exit_code\n";

# 	exit $exit_code;
#     }

#     # else

#     else
    {
	# exit, possibly success

# 	print "$0: exiting with exit_code $exit_code\n";

	exit $exit_code;
    }
}


sub version
{
    # $Format: "    my $version=\"${package}-${label}\";"$
    my $version="developer-alpha";

    return $version;
}


main();


