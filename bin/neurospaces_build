#!/usr/bin/perl
#!/usr/bin/perl -w -d:ptkdb
#


use strict;


use Getopt::Long;

use YAML;


my $packages
    = {
       developer => {
		     directory => "$ENV{HOME}/neurospaces_project/project/developer/source/snapshots/0",
		     disabled => 1,
		     order => 0,
		    },
       geometry => {
		    directory => "$ENV{HOME}/neurospaces_project/geometry/source/c/snapshots/0",
		    disabled => 1,
		    order => 4,
		   },
       heccer => {
		  directory => "$ENV{HOME}/neurospaces_project/heccer/source/c/snapshots/0",
		  disabled => 0,
		  order => 2,
		 },
       model_container => {
			   './configure' => [
					     '--with-delete-operation',
					    ],
			   directory => "$ENV{HOME}/neurospaces_project/model_container/source/c/snapshots/0",
			   disabled => 0,
			   order => 1,
			  },
       simulation_browser => {
			      directory => "$ENV{HOME}/neurospaces_project/simulation_browser/source/perl/snapshots/0",
			      disabled => 1,
			      order => 6,
			     },
       ssp => {
	       directory => "$ENV{HOME}/neurospaces_project/ssp/source/perl/snapshots/0",
	       disabled => 0,
	       order => 3,
	      },
       studio => {
		  directory => "$ENV{HOME}/neurospaces_project/studio/source/perl/snapshots/0",
		  disabled => 0,
		  order => 5,
		 },
      };


# default profile: configure, compile and install

my $option_certification_report = 0;
my $option_check = 0;
my $option_clean = 0;
my $option_compile = 1;
my $option_configure = 1;
my $option_dist = 0;
my $option_distcheck = 0;
my $option_distclean = 0;
my $option_distkeywords = 0;
my $option_dry_run = 0;
my $option_install = 1;
my $option_regex_selector = ".*";
my $option_tag = 0;
my $option_uninstall = 0;
my $option_verbose = 0;


my $build_report
    = {
       description => {
		       command => $0,
		       name => "Build report",
		      },
       global => {
# 		  config => $config,
# 		  error_count => $error_count,
		  status => 'initializing',
		  test_count => 0,
		  time_start => `date`,
		 },
       target => {
		  OS => $^O,
		 },
      };


$SIG{'__DIE__'}
    = sub
      {
	  use Carp;

	  print STDERR Carp::longmess(@_);

	  $build_report->{global}->{status} = 'Died: ' . join " ", @_;

	  report_exit(3, @_);
      };


$SIG{'INT'}
    = sub
      {
	  $build_report->{global}->{status} = 'Interrupted';

	  report_exit(2);
      };


sub main
{
    read_cmd_line();

    # set status: running

    $build_report->{global}->{status} = 'Running';

    $build_report->{operations} = [];

    my $operations = $build_report->{operations};

    # loop over all packages, in dependency order

    foreach my $package_name (sort
			      {
				  $packages->{$a}->{order} <=> $packages->{$b}->{order}
			      }
			      keys %$packages)
    {
	if ($option_verbose)
	{
	    print "$0: examining $package_name\n";
	}

	my $package = $packages->{$package_name};

	if ($package->{disabled})
	{
	    if ($option_verbose)
	    {
		print "$0: $package_name skipped, disabled is $package->{disabled}\n";
	    }

	    next;
	}

	if ($package_name !~ /$option_regex_selector/i)
	{
	    if ($option_verbose)
	    {
		print "$0: $package_name skipped, not selected using --regex-selector\n";
	    }

	    next;
	}

	# loop over all installation operations

	foreach my $operation (
			       {
				operation => [ 'make', 'distclean', ],
				condition => $option_distclean && !$option_uninstall,
			       },
			       {
				operation => [
					      ("test", "!", '"`mtn ls unknown && mtn ls missing && mtn ls changed`"', ),
					      ( "&&", 'mtn', 'tag', "'$option_tag'", ),
					      ( "&&", 'make', ),
					     ],
				condition => $option_tag,
			       },
			       {
				operation => [ 'make', 'dist-keywords', '&&', 'make', 'clean', '&&', 'make', 'clean', ],
				condition => $option_distkeywords,
			       },
			       {
				operation => [ './configure', ],
				condition => $option_configure,
			       },
			       {
				operation => [ 'make', 'clean', ],
				condition => $option_clean,
			       },
			       {
				operation => [ 'make', ],
				condition => $option_compile,
			       },
			       {
				operation => [ 'make', 'check', ],
				condition => $option_check,
			       },
			       {
				operation => [ 'make', 'dist', ],
				condition => $option_dist,
			       },
			       {
				operation => [ 'make', 'distcheck', ],
				condition => $option_distcheck,
			       },
			       {
				operation => [ 'make', '&&', 'sudo', 'make', 'install', ],
				condition => $option_compile && !$option_uninstall && $option_install,
			       },
			       {
				operation => [ 'make', 'uninstall', ],
				condition => $option_uninstall,
			       },
			       {
				operation => [ 'mtn', 'cert', '\'%version\'', '--', 'build_report', '\'%report\'', ],
				condition => $option_certification_report,
			       },
			      )
	{
	    my $condition_value = 1;

	    # convert flexible hashes to arrays with a command line

	    if (ref $operation eq 'HASH')
	    {
		$condition_value = $operation->{condition};

		$operation = $operation->{operation};

		if ($option_verbose > 1)
		{
		    print "$0: $package_name [" . (join ' ', @$operation ) . "] translated from operations hash \n";
		}

	    }

	    # if the uninstall option is given

	    if ($option_uninstall)
	    {
		# but this operation is not uninstall

		if (exists $operation->[1]
		    && $operation->[1] ne 'uninstall')
		{
		    # don't execute, doesnot make sense

		    $condition_value = 0;

		    if ($option_verbose > 1)
		    {
			print "$0: $package_name [" . (join ' ', @$operation ) . "] condition turned to false \n";
		    }

		}
	    }

	    # if the operation's condition is true

	    if ($condition_value)
	    {
		if ($option_verbose > 1)
		{
		    print "$0: $package_name [" . (join ' ', @$operation ) . "] preparing to execute \n";
		}

		# if package directory exists

		my $target_directory = $package->{directory};

		if (-e $target_directory)
		{
		    # go to package directory

		    use Cwd;

		    my $current_directory = getcwd();

		    my $success = chdir $target_directory;

		    if (!$success)
		    {
			die "$0: cannot change from directory ($current_directory) to directory ($target_directory): $!";
		    }

		    # perform the operation on the package

		    my $package_options = $package->{$operation->[0]};

		    system_execute($package_name, @$operation, @$package_options);

		    # register that we did the operation for this package

		    push @$operations, { package_name => $package_name, operations => [ @$operation, @$package_options, ], };

		    my $success = chdir $current_directory;

		    if (!$success)
		    {
			die "$0: cannot change from directory ($target_directory) to directory ($current_directory): $!";
		    }
		}
		else
		{
		    if ($option_verbose)
		    {
			print "$0: skipped $package_name [" . (join ' ', @$operation) . "], directory not found, assuming this package source is not installed\n";
		    }
		}
	    }
	}
    }

    $build_report->{global}->{status} = 'Finished';

    report_exit(0);
}


sub read_cmd_line
{
    my $option_help = 0;
    my $option_packages = 0;

    my $result
	= GetOptions(
		     "certification-report!" => \$option_certification_report,
		     "check!" => \$option_check,
		     "clean!" => \$option_clean,
		     "compile!" => \$option_compile,
		     "configure!" => \$option_configure,
		     "dist!" => \$option_dist,
		     "distcheck!" => \$option_distcheck,
		     "distclean!" => \$option_distclean,
		     "distkeywords!" => \$option_distkeywords,
		     "dry-run!" => \$option_dry_run,
		     "help!" => \$option_help,
		     "install!" => \$option_install,
		     "packages" => \$option_packages,
		     "regex-selector=s" => \$option_regex_selector,
		     "tag=s" => \$option_tag,
		     "uninstall!" => \$option_uninstall,
		     "verbose+" => \$option_verbose,
		    );

    if (!$result)
    {
	die "$0: Error in option processing";
    }

    $build_report->{options}
	= {
	   certification_report => $option_certification_report,
	   check => $option_check,
	   clean => $option_clean,
	   compile => $option_compile,
	   configure => $option_configure,
	   dist => $option_dist,
	   distcheck => $option_distcheck,
	   distclean => $option_distclean,
	   distkeywords => $option_distkeywords,
	   dry_run => $option_dry_run,
	   help => $option_help,
	   install => $option_install,
	   packages => $option_packages,
	   regex_selector => $option_regex_selector,
	   tag => $option_tag,
	   uninstall => $option_uninstall,
	   verbose => $option_verbose,
	  };

    if ($option_help)
    {
	print
	    "
$0: configure, compile, check and install one package after another from a set of packages.

To disable a build stage, prefix the corresponding option with
'--no-', eg. to disable configure, use '--no-configure'.

To see what packages are known in the database, use the '--packages' option.

options:
    certification-report   annotate the (monotone) repository with the build_report.
    check                  check packages.
    clean                  clean before compiling.
    configure              configure before compiling.
    compile                compile packages.
    dist                   build distribution tarballs.
    distcheck              check created tarballs.
    distclean              distclean before compiling.
    dry-run                do not execute any command, just report what would be done.
    help                   print usage information.
    install                install packages.
    packages               print known packages, in order of installation.
    regex-selector         defines a regex to select specific packages.
    tag                    set this tag on all packages.
    uninstall              uninstall packages, cannot be combined with installation options.
    v|verbose              tell what is being done, specify multiple times to get
                           more feedback.

";

	print
	    "---\nconfiguration is now:\n"
		. ("  certification-report: $option_certification_report\n"
		   . "  check: $option_check\n"
		   . "  clean: $option_clean\n"
		   . "  compile: $option_compile\n"
		   . "  configure: $option_configure\n"
		   . "  dist: $option_dist\n"
		   . "  distcheck: $option_distcheck\n"
		   . "  distclean: $option_distclean\n"
		   . "  distkeywords: $option_distkeywords\n"
		   . "  dry-run: $option_dry_run\n"
		   . "  help: $option_help\n"
		   . "  install: $option_install\n"
		   . "  packages: $option_packages\n"
		   . "  regex-selector: $option_regex_selector\n"
		   . "  tag: $option_tag\n"
		   . "  uninstall: $option_uninstall\n"
		   . "  verbose: $option_verbose\n");

	exit 1;
    }


    if ($option_packages)
    {
	print
	    "$0: packages in order of installation are ("
		. (
		   join
		   ' ',
		   sort
		   {
		       $packages->{$a}->{order} <=> $packages->{$b}->{order}
		   }
		   grep
		   {
		       $_ =~ /$option_regex_selector/i
		   }
		   keys %$packages
		  )
		    . ")\n";

	exit 1;
    }


}


sub report_exit
{
    my $exit_code = shift;

    my $description = shift;

    $build_report->{global}->{time_end} = `date`;

    if (defined $description
        && $exit_code eq 3)
    {
	print "*** die: $description\n";
    }

    # yaml out the test report

    print Dump($build_report);

    # if there were errors

#     if ($error_count)
#     {
# 	# exit with failure

# 	$exit_code ||= 1;

# 	print "$0: exit_code $exit_code\n";

# 	exit $exit_code;
#     }

#     # else

#     else
    {
	# exit, possibly success

	exit $exit_code;
    }
}


sub report_message
{
    my $header = shift;

    my $trailer = shift;

    my $message = shift;

    my $lines = [ split '\n', $message, ];

    my $longest = 0;

    map
    {
	($longest < length) && ($longest = length)
    }
	@$lines;

    my $line = '-' x $longest;

    print "\n";
    print "$line\n" for 0 .. $header;
    print "\n";
    print "$message\n\n";
    print "$line\n" for 0 .. $trailer;
    print "\n";
}


sub system_execute
{
    my $package_name = shift;

    my $arguments = [ @_ ];

    my $monotone_id = `mtn automate get_base_revision_id`;

    chomp $monotone_id;

    #! to prevent monotone from interpreting the yaml as an option,
    #! we prefix the report with something that does not look like an
    #! option.

    my $report_text = Dump( { build_report => $build_report, }, ) . "\n";

    $arguments
	= [
	   map
	   {
	       s/%version/$monotone_id/g;
	       s/%report/$report_text/g;

	       # replace non-LDH characters: underscores

	       s/_/-/g;

	       $_;
	   }
	   @$arguments,
	  ];

    if (!$option_dry_run)
    {
	print "$0: $package_name [" . (join ' ', @$arguments) . "] executing\n";

	system join " ", @$arguments;

	if ($?)
	{
	    #! assume system has given a good error message

	    die "*** Error for package_name $package_name: $?";
	}

	if ($option_verbose)
	{
	    print "$0: $package_name [" . (join ' ', @$arguments ) . "] executed \n";
	}
    }
    else
    {
	if ($option_verbose)
	{
	    print "$0: $package_name [" . (join ' ', @$arguments ) . "] not executed, dry_run is $option_dry_run\n";
	}
    }
}


main();


