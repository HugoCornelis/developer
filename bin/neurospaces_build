#!/usr/bin/perl
#!/usr/bin/perl -w -d:ptkdb
#


use strict;


use Getopt::Long;

use YAML;


# options related to operation mode selection:

my $option_client = 0;
my $option_developer = 0;

# operation execution profile: default is configure, compile and install

my $option_certification_report = 0;
my $option_check = 0;
my $option_clean = 0;
my $option_compile = 1;
my $option_configure = 1;
my $option_directories_create = 0;
my $option_dist = 0;
my $option_distcheck = 0;
my $option_distclean = 0;
my $option_dist_dir = [];
my $option_distkeywords = 0;
my $option_dry_run = 0;
my $option_install = 1;
my $option_installed_versions = 1;
my $option_regex_selector = ".*";
my $option_repo_pull = 0;
my $option_repo_sync = 0;
my $option_repo_co = 0;
my $option_tag = 0;
my $option_uninstall = 0;
my $option_upload_server;
my $option_verbose = 0;

# options related to installation on a client machine

my $option_src_tag;
my $option_src_dir;
my $option_download_server;
my $option_unpack;

# options related to behavior of external applications

my $option_environment = [];


my $all_operations = [];


my $all_packages
    = {
       # the installer package is always disabled, unless overriden by the --enable option.

       installer => {
		     directory => "$ENV{HOME}/neurospaces_project/installer/source/snapshots/0",
		     disabled => 1,
		     order => 0,
		     version_control => {
					 port_number => 4696,
					},
		     version_script => 'neurospaces_build --version',
		    },
       geometry => {
		    directory => "$ENV{HOME}/neurospaces_project/geometry/source/snapshots/0",
		    disabled => 1,
		    order => 4,
		    version_script => 0,
		   },
       heccer => {
		  directory => "$ENV{HOME}/neurospaces_project/heccer/source/snapshots/0",
		  disabled => 0,
		  order => 2,
		  version_control => {
				      port_number => 4694,
				     },
		 },
       dash => {
		directory => "$ENV{HOME}/neurospaces_project/dash/source/snapshots/0",
		disabled => 1,
		order => 2,
		version_script => 0,
	       },
       gshell => {
		  directory => "$ENV{HOME}/neurospaces_project/gshell/source/snapshots/0",
		  disabled => 1,
		  order => 13,
		  version_script => 0,
		 },
       'model-container' => {
			     './configure' => [
					       '--with-delete-operation',
					      ],
			     directory => "$ENV{HOME}/neurospaces_project/model-container/source/snapshots/0",
			     disabled => 0,
			     order => 1,
			     target_name => 'model-container',
			     version_control => {
						 port_number => 4693,
						},
			    },
       'ns-genesis-SLI' => {
			    directory => "$ENV{HOME}/neurospaces_project/ns-genesis-SLI/source/snapshots/0",
			    disabled => 1,
			    order => 6,
			    version_control => {
						port_number => 4692,
					       },
			    version_script => 0,
			   },
       'project-browser' => {
			     directory => "$ENV{HOME}/neurospaces_project/project-browser/source/snapshots/0",
			     disabled => 1,
			     order => 7,
			     version_script => 'pb-version',
			    },
       ssp => {
	       directory => "$ENV{HOME}/neurospaces_project/ssp/source/snapshots/0",
	       disabled => 0,
	       order => 3,
	       version_control => {
				   port_number => 4695,
				  },
	      },
       studio => {
		  directory => "$ENV{HOME}/neurospaces_project/studio/source/snapshots/0",
		  disabled => 0,
		  order => 5,
		  version_script => 'neurospaces --version',
		 },
      };


my $build_report
    = {
       description => {
		       command => $0,
		       name => "Build report",
		      },
       global => {
# 		  config => $config,
# 		  error_count => $error_count,
		  status => 'initializing',
		  test_count => 0,
		  time_start => `date`,
		 },
       client => {
		  OS => $^O,
		 },
      };


$SIG{'__DIE__'}
    = sub
      {
	  use Carp;

	  print STDERR Carp::longmess(@_);

	  $build_report->{global}->{status} = 'Died: ' . join " ", @_;

	  report_exit(3, @_);
      };


$SIG{'INT'}
    = sub
      {
	  $build_report->{global}->{status} = 'Interrupted';

	  report_exit(2);
      };


sub main
{
    read_cmd_line();

    # set status: running

    $build_report->{global}->{status} = 'Running';

    # execute all operations

    all_operations_execute();

    # finish

    $build_report->{global}->{status} = 'Finished';

    report_exit(0);
}


sub all_operations_execute
{
    # initialize operations related matters

    $build_report->{operations} = [];

    my $operations = $build_report->{operations};

    # loop over all packages, in dependency order

    foreach my $package_name (sort
			      {
				  $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
			      }
			      keys %$all_packages)
    {
	if ($option_verbose)
	{
	    print "$0: examining package $package_name\n";
	}

	my $package = $all_packages->{$package_name};

	if ($package->{disabled})
	{
	    if ($option_verbose)
	    {
		print "$0: package $package_name skipped, disabled is $package->{disabled}\n";
	    }

	    next;
	}

	if ($package_name !~ /$option_regex_selector/i)
	{
	    if ($option_verbose)
	    {
		print "$0: package $package_name skipped, not selected using --regex-selector\n";
	    }

	    next;
	}

	# loop over all installation operations

	foreach my $all_operation (@$all_operations)
	{
	    my $condition_value = $all_operation->{condition};

	    my $operation = $all_operation->{operation};

	    my $description = $all_operation->{description} || (join ' ', @$operation );

	    # if the uninstall option is given

	    if ($option_uninstall)
	    {
		# but this operation is not uninstall

		if (ref $operation eq 'ARRAY'
		    && exists $operation->[5]
		    && $operation->[5] ne 'uninstall')
		{
		    # don't execute, doesnot make sense

		    $condition_value = 0;

		    if ($option_verbose > 1)
		    {
			print "$0: package $package_name [" . $description . "] condition turned to false \n";
		    }

		}
	    }

	    # if the operation's condition is true

	    if ($condition_value)
	    {
		if ($option_verbose > 1)
		{
		    print "$0: package $package_name [" . $description . "] preparing to execute \n";
		}

		# construct package directory

		my $target_directory = $package->{directory};

		# if we are working on a client machine

		if ($option_client)
		{
		    if (!defined $option_src_dir
			|| !defined $option_src_tag)
		    {
			die "$0: *** Error: you must set option_src_dir and option_src_tag when working in client mode";
		    }

		    # construct a target directory from the src-* options

		    $target_directory = $option_src_dir . "/" . $package_name . "-" . $option_src_tag;
		}

		# if this is perl code

		if (ref $operation eq 'CODE')
		{
		    # register that we are about to do this operation for this package

		    push @$operations, { package_name => $package_name, operations => $operation, };

		    if (!$option_dry_run)
		    {
			my $directory = $option_src_dir ? $option_src_dir : $target_directory;

			my $filename_base = $package->{target_name} || $package_name;

			my $filename = $filename_base . "-" . $option_src_tag . ".tar.gz";

			my $prefix = $option_download_server =~ m|://| ? '' : 'http://';

			my $url = $prefix . $option_download_server . "/neurospaces/" . $filename;

			my $result
			    = &$operation
				(
				 {
				  description => $description,
				  directory => $directory,
				  ( $option_src_tag ? (filename => $filename,) : (), ),
				  operations => $operations,
				  package => $package,
				  package_name => $package_name,
				  url => $url,
				 },
				);
		    }
		    else
		    {
			if ($option_verbose)
			{
			    # embedded perl code

			    use Data::Dumper;

			    local $Data::Dumper::Deparse = 1;

			    my $perl_code = Dumper($operation);

			    print "$0: package $package_name [" . (join ' ', $perl_code ) . "] not executed, dry_run is $option_dry_run\n";
			}
		    }
		}
		else
		{
		    # if package directory exists

		    if (-e $target_directory)
		    {
			# go to package directory

			use Cwd;

			my $current_directory = getcwd();

			if ($option_verbose > 1)
			{
			    print "$0: package $package_name, chdir from ($current_directory) to ($target_directory)\n";
			}

			my $success = chdir $target_directory;

			if (!$success)
			{
			    die "$0: *** Error: package $package_name cannot change from directory ($current_directory) to directory ($target_directory): $!";
			}

			# perform the operation on the package

			my $package_options = $package->{$operation->[0]};

			operation_execute
			    (
			     $operations,
			     {
			      description => $description,
			      keywords => $option_developer,
			      package_name => $package_name,
			     },
			     [
			      @$operation,
			      @{$package_options || []},
			     ],
			    );

			if ($option_verbose > 1)
			{
			    print "$0: package $package_name, chdir from ($target_directory) to ($current_directory)\n";
			}

			$success = chdir $current_directory;

			if (!$success)
			{
			    die "$0: *** Error: package $package_name, cannot change from directory ($target_directory) to directory ($current_directory): $!";
			}
		    }
		    else
		    {
			if ($option_verbose)
			{
			    print "$0: package $package_name skipped, [" . $description . "], directory ($target_directory) not found, assuming this package source is not installed\n";
			}
		    }
		}
	    }
	    else
	    {
		if ($option_verbose > 1)
		{
		    print "$0: package $package_name [" . $description . "] skipped, condition_value is $condition_value\n";
		}
	    }
	}
    }
}


sub read_cmd_line
{
    my $option_disable;
    my $option_enable;
    my $option_help = 0;
    my $option_help_all = 0;
    my $option_packages = 0;
    my $option_version;

    my $result
	= GetOptions(
		     # options related to operation mode selection:

		     "client!" => \$option_client,
		     "developer!" => \$option_developer,

		     # operation execution profile: default is configure, compile and install

		     "certification-report!" => \$option_certification_report,
		     "check!" => \$option_check,
		     "clean!" => \$option_clean,
		     "compile!" => \$option_compile,
		     "configure!" => \$option_configure,
		     "directories-create!" => \$option_directories_create,
		     "disable=s" => \$option_disable,
		     "dist!" => \$option_dist,
		     "distcheck!" => \$option_distcheck,
		     "distclean!" => \$option_distclean,
		     "dist-dir=s" => $option_dist_dir,
		     "distkeywords!" => \$option_distkeywords,
		     "dry-run!" => \$option_dry_run,
		     "enable=s" => \$option_enable,
		     "help!" => \$option_help,
		     "help-all!" => \$option_help_all,
		     "install!" => \$option_install,
		     "installed-versions!" => \$option_installed_versions,
		     "packages" => \$option_packages,
		     "regex-selector=s" => \$option_regex_selector,
		     "repo-pull=s" => \$option_repo_pull,
		     "repo-sync=s" => \$option_repo_sync,
		     "repo-co=s" => \$option_repo_co,
		     "tag=s" => \$option_tag,
		     "uninstall!" => \$option_uninstall,
		     "upload-server=s" => \$option_upload_server,
		     "verbose+" => \$option_verbose,
		     "version" => \$option_version,

		     # options related to installation on a client machine

		     "download-server=s" => \$option_download_server,
		     "src-tag=s" => \$option_src_tag,
		     "src-dir=s" => \$option_src_dir,
		     "unpack!" => \$option_unpack,

		     # options related to behavior of external applications

		     "environment=s" => $option_environment,
		    );

    if (!$result)
    {
	die "$0: *** Error: Error in option processing";
    }

    # process operation mode options

    #! we give client mode precedence over developer mode

    if (!$option_client
	&& !$option_developer)
    {
	$option_client = 1;
    }

    if ($option_client)
    {
	$option_developer = 0;
    }

    if ($option_developer)
    {
	$option_client = 0;
    }

    # fill in the build report

    $build_report->{options}
	= {
	   # options related to operation mode selection:

	   "client!" => $option_client,
	   "developer!" => $option_developer,

	   # operation execution profile: default is configure, compile and install

	   "certification-report!" => $option_certification_report,
	   "check!" => $option_check,
	   "clean!" => $option_clean,
	   "compile!" => $option_compile,
	   "configure!" => $option_configure,
	   "directories-create!" => $option_directories_create,
	   "disable=s" => $option_disable,
	   "dist!" => $option_dist,
	   "distcheck!" => $option_distcheck,
	   "distclean!" => $option_distclean,
	   "dist-dir=s" => $option_dist_dir,
	   "distkeywords!" => $option_distkeywords,
	   "dry-run!" => $option_dry_run,
	   "enable=s" => $option_enable,
	   "help!" => $option_help,
	   "help-all!" => $option_help_all,
	   "install!" => $option_install,
	   "installed-versions!" => $option_installed_versions,
	   "packages" => $option_packages,
	   "regex-selector=s" => $option_regex_selector,
	   "repo-pull=s" => $option_repo_pull,
	   "repo-sync=s" => $option_repo_sync,
	   "repo-co!" => $option_repo_co,
	   "tag=s" => $option_tag,
	   "uninstall!" => $option_uninstall,
	   "upload-server=s" => $option_upload_server,
	   "verbose+" => $option_verbose,
	   "version" => $option_version,

	   # options related to installation on a client machine

	   "download-server=s" => $option_download_server,
	   "src-tag=s" => $option_src_tag,
	   "src-dir=s" => $option_src_dir,
	   "unpack!" => $option_unpack,

	   # options related to behavior of external applications

	   "environment=s" => $option_environment,
	  };

    if ($option_version)
    {
	my $version = version();

	print $version . "\n";

	exit 1;
    }

    # process enable and disable options overhere, such that there
    # effect is mirrored in the help output

    if ($option_enable)
    {
	# loop over all packages, in dependency order

	foreach my $package_name (sort
				  {
				      $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
				  }
				  keys %$all_packages)
	{
	    # if should be enabled

	    if ($package_name =~ /$option_enable/)
	    {
		# enable but don't overwrite existing value

		my $package = $all_packages->{$package_name};

		if ($package->{disabled})
		{
		    $package->{disabled} = 0;
		}
	    }
	}
    }

    if ($option_disable)
    {
	# loop over all packages, in dependency order

	foreach my $package_name (sort
				  {
				      $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
				  }
				  keys %$all_packages)
	{
	    # if should be disabled

	    if ($package_name =~ /$option_disable/)
	    {
		# disable but don't overwrite existing value

		my $package = $all_packages->{$package_name};

		if (!$package->{disabled})
		{
		    $package->{disabled} = $option_disable;
		}
	    }
	}
    }

    my $tag_set_in_tag_database = 0;

    # merge operations with options that affect the execution of the
    # operations

    $all_operations
	= [
	   {
	    condition => $option_directories_create,
	    description => "creating directory",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		# create directory

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'mkdir', '--parents', $directory,
		     ],
		    );
	    },
	   },
	   {
	    condition => $option_repo_pull,
	    description => "pulling repository",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		my $repository_name = $directory . '/' . $package_name . 'mtn';

		my $port_number = $package_information->{version_control}->{port_number};

		# initialize the repository if necessary

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'test', '-f', $repository_name, '||', 'mtn', '--db', $repository_name, 'db', 'init',
		     ],
		    );

		# pull the repository

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'mtn', '--db', $repository_name, 'pull', "$option_repo_pull:$port_number",
		     ],
		    );
	    },
	   },
	   {
	    condition => $option_repo_sync,
	    description => 'syncing repository',
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		my $repository_name = $directory . '/' . $package_name . 'mtn';

		my $port_number = $package_information->{version_control}->{port_number};

		# initialize the repository if necessary

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'test', '-f', $repository_name, '||', 'mtn', '--db', $repository_name, 'db', 'init',
		     ],
		    );

		# sync the repository

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'mtn', '--db', $repository_name, 'sync', "$option_repo_sync:$port_number",
		     ],
		    );
	    },
	   },
	   {
	    condition => $option_repo_co,
	    description => "commiting to repository",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		my $repository_name = $directory . '/' . $package_name . 'mtn';

		my $port_number = $package_information->{version_control}->{port_number};

		# change the directory

		chdir $directory;

		# checkout code

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'mtn', '--db', $repository_name, '--branch', '0', 'co', '.',
		     ],
		    );
	    },
	   },
	   {
	    condition => $option_distclean && !$option_uninstall,
	    operation => [ 'make', 'distclean', ],
	   },
	   {
	    condition => $option_distkeywords,
	    operation => [
			  #! after keyword expansion, regenerate the
			  #! autotool related files that perhaps are
			  #! checked in.

			  ( 'make', 'dist-keywords', ),
			  ( '&&', 'make', 'clean', ),
			  ( '&&', 'make', 'clean', ),
			 ],
	   },
	   {
	    condition => $option_tag,
	    operation => [
			  ( "test", "!", '"`mtn ls unknown && mtn ls missing && mtn ls changed`"', ),
			  ( '&&', 'release-expand', "'%package'", "'%release_major'", "'%release_minor'", "'%release_micro'", "'%release_major-%release_minor'", 'hugo.cornelis@gmail.com', '--verbose', ),

			  #! after keyword expansion, regenerate the
			  #! autotool related files that perhaps are
			  #! checked in.

			  ( '&&', 'make', 'clean', ),
			  ( '&&', 'make', 'clean', ),
			  ( "&&", 'mtn', 'ci', "-m", "'1. Keywords only: $option_tag\n'", ),
			  ( "&&", "test", "!", '"`mtn ls unknown && mtn ls missing && mtn ls changed`"', ),
			 ],
	   },
	   {
	    condition => $option_tag,
	    operation => [
			  #! in a separate operation such that we have the correct %version

			  ( 'mtn', 'tag', '\'%version\'', "'$option_tag'", ),
			 ],
	   },
	   {
	    condition => $option_tag,
	    description => "putting the tag in the tag database",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $filename = $package_information->{filename};

		my $package_name = $package_information->{package_name};

		my $url = $package_information->{url};

		# if the tag has already been added for this run

		if ($tag_set_in_tag_database)
		{
		    # return

		    return;
		}

		use YAML;

		my $tag_database_filename = '/etc/neurospaces/tag_database.yml';

		my $tag_database = YAML::LoadFile($tag_database_filename);

		if (!$tag_database)
		{
		    die "$0: *** Error: cannot read $tag_database_filename";
		}

		if ($option_verbose > 1)
		{
		    print "$0: package $package_name [$description ($option_tag)] executing\n";
		}

		my $tags = $tag_database->{tags};

		push
		    @$tags,
		    {
		     'date' => `date`,
		     'regex-selector' => $option_regex_selector,
		     'tag' => $option_tag,
		    };

		YAML::DumpFile($tag_database_filename, $tag_database);

		# we do this at most once per run

		$tag_set_in_tag_database = 1;

		#t do a checkin of the configuration package (contains
		#t the tag_database).
	    },
	   },
	   {
	    condition => $option_download_server,
	    description => "downloading",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $filename = $package_information->{filename};

		my $package_name = $package_information->{package_name};

		my $url = $package_information->{url};

		# create the directory

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'mkdir', '--parents', $directory,
		     ],
		    );

		if ($option_verbose > 1)
		{
		    print "$0: package $package_name [$description from $url to $filename] executing\n";
		}

		# download the package

		use LWP::Simple;

		my $http_response = getstore($url, $directory . '/' . $filename);

		if (!is_success($http_response))
		{
		    warn "$0: *** Warning: $description from $option_download_server: $http_response";
		}
	    },
	   },
	   {
	    condition => $option_download_server || $option_unpack,
	    description => "unpacking",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $filename = $package_information->{filename};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		# change the directory

		chdir $directory;

		# unpack the package

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'tar', 'xfvz', $filename,
		     ],
		    );
	    },
	   },
	   {
	    condition => $option_configure,
	    operation => [ './configure', ],
	   },
	   {
	    condition => $option_clean,
	    operation => [ 'make', 'clean', ],
	   },
	   {
	    condition => $option_compile,
	    operation => [ 'make', ],
	   },
	   {
	    condition => $option_check,
	    operation => [ 'make', 'check', ],
	   },
	   {
	    condition => $option_dist,
	    operation => [ 'export', 'NEUROSPACES_RELEASE=1', '&&', 'make', 'dist', ],
	   },
	   {
	    condition => $option_distcheck,
	    operation => [ 'export', 'NEUROSPACES_RELEASE=1', '&&', 'make', 'distcheck', ],
	   },
	   {
	    #! always make as the regular user to avoid cluttering the
	    #! source directory with root owned files

	    condition => $option_compile && !$option_uninstall && $option_install,
	    operation => [ 'make', '&&', 'sudo', 'make', 'install', ],
	   },
	   {
	    condition => $option_installed_versions,
	    description => 'installed versions',
	    operation =>
	    sub
	    {
		my $package_information = shift;

		my $package = $package_information->{package};

		my $version_script = $package->{version_script};

		if (!defined $version_script)
		{
		    $version_script = "$package_information->{package_name} --version";
		}

		if ($version_script ne 0)
		{
		    system $version_script;
		}
	    },
	   },
	   {
	    condition => $option_uninstall,
	    operation => [ 'make', 'clean', '&&', 'sudo', 'make', 'uninstall', ],
	   },
	   {
	    condition => $option_upload_server,
	    description => "uploading",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $filename = $package_information->{filename};

		my $package_name = $package_information->{package_name};

		my $url = $package_information->{url};

		if (!$filename)
		{
		    die "$0: *** Error: no filename defined for uploading";
		}

		if ($option_verbose)
		{
		    print "$0: package $package_name [$description $filename to $option_upload_server] executing\n";
		}

		# change the directory

		chdir $directory;

		# upload the package

		$option_upload_server =~ m(((.*)://)?([^/]+)(.*));

		my $upload_protocol = $2 || 'https';

		my $upload_host = $3;

		my $upload_directory = $4;

		my $package_names
		    = {
		       ftp => 'Net::FTP',
		       https => 'HTTP::DAV',
		       sftp => 'Net::SFTP',
		      };

		my $package_name = $package_names->{$upload_protocol};

		my $login_info = YAML::LoadFile("$ENV{HOME}/.sourceforge_login");

		my $user = $login_info->{user};

		my $password = $login_info->{password};

		my $try_something_very_sophisticated_with_broken_libraries = 'no';

		if ($try_something_very_sophisticated_with_broken_libraries eq 'yes')
		{
		    my $loaded_protocol_module = eval "require $package_name";

		    if ($@)
		    {
			no strict "refs";

			if (exists ${"::"}{verbose} && $::option_verbose)
			{
			    print STDERR "$0: cannot load protocol module Net::$package_name because of: $@\n";
			    print STDERR "$0: continuing.\n";
			}
		    }

		    my $ftp;

		    if ($upload_protocol =~ /^s?ftp$/)
		    {
			$ftp
			    = eval "$package_name->new('$upload_host', Debug => 0, user => '$user', password => '$password', )"
				or die "$0: *** Error: for $filename: cannot connect to $upload_host: $@";
		    }
		    else
		    {
			$ftp
			    = eval "HTTP::DAV->new()"
				or die "$0: *** Error: for $filename: cannot connect to $upload_host: $@";

			$ftp->credentials
			    (
			     -user=> $user,
			     -pass => $password,
			     -url => $option_upload_server,
			    );

			$ftp->open( -url=> $option_upload_server, )
			    or die("$0: *** Error: cannot open $option_upload_server: " . $ftp->message() . "\n");
		    }

# 		    $ftp->login("anonymous", '-anonymous@')
# 			or die "$0: *** Error: for $filename: cannot login to $upload_host", $ftp->message();

		    $ftp->cwd($upload_directory)
			or die "$0: *** Error: for $filename: cannot change working directory to $upload_directory", $ftp->message();

		    if ($upload_protocol =~ /^s?ftp$/)
		    {
			$ftp->binary()
			    or die "$0: *** Error: for $filename: cannot switch to binary ftp mode", $ftp->message();

			$ftp->hash()
			    or die "$0: *** Error: for $filename: cannot enable hash printing", $ftp->message();
		    }

		    $ftp->put($filename)
			or die "$0: *** Error: for $filename: Net::FTP::put() failed ", $ftp->message();

		    if ($upload_protocol =~ /^s?ftp$/)
		    {
			$ftp->quit();
		    }
		    else
		    {
			$ftp->unlock();
		    }
		}

		# else we are trying a hardcoded solution that should work

		else
		{
		    use Expect;

		    my $expector = Expect->new();

# 		    #! see the expect manual for this one

# 		    $expector->raw_pty(1);

		    $expector->spawn('sftp', "$user\@$upload_host",)
			or die "$0: cannot spawn 'sftp': $!\n";

		    my ($matched_pattern_position,
			$error,
			$successfully_matching_string,
			$before_match,
			$after_match)
			= $expector->expect(15, "word:", );

		    $expector->send("$password\n");

		    my $prompt = "sftp>";

		    ($matched_pattern_position,
		     $error,
		     $successfully_matching_string,
		     $before_match,
		     $after_match)
			= $expector->expect(5, $prompt, );

		    $upload_directory =~ s|^/||;

		    $expector->send("cd $upload_directory\n");

		    ($matched_pattern_position,
		     $error,
		     $successfully_matching_string,
		     $before_match,
		     $after_match)
			= $expector->expect(5, $prompt, );

		    $expector->send("put '$filename'\n");

		    ($matched_pattern_position,
		     $error,
		     $successfully_matching_string,
		     $before_match,
		     $after_match)
			= $expector->expect(600, $prompt, );

		    $expector->send("quit\n");
		}
	    },
	   },
	   {
	    condition => (scalar @$option_dist_dir),
	    description => "copying files to the distribution directories",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $filename = $package_information->{filename};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		my $url = $package_information->{url};

		if (!$filename)
		{
		    die "$0: *** Error: no filename defined to copy to the distribution directories";
		}

		# change the directory

		chdir $directory;

		foreach my $dist_dir (@$option_dist_dir)
		{
		    # copy the package

		    operation_execute
			(
			 $operations,
			 {
			  description => $description,

			  #t always zero here

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'cp', $filename, $dist_dir,
			 ],
			);
		}
	    },
	   },
	   {
	    condition => $option_certification_report,
	    operation => [ 'mtn', 'cert', '\'%version\'', '--', 'build_report', '\'%report\'', ],
	   },
	  ];

    # process environment options

#     # tell neurospaces_harness if to send emails for this

#     $ENV{NEUROSPACES_HARNESS_OPTION_EMAIL} = $option_neurospaces_harness_email;

    # build the environment for external applications

    foreach my $environment_setting (@$option_environment)
    {
	$environment_setting =~ /^(.*?)=(.*)$/;

	my $variable = $1;

	my $value = $2;

	$ENV{$variable} = $value;
    }

    if ($option_verbose
	&& @$option_environment)
    {
	use YAML;

	print Dump(\%ENV);
    }

    # reporting options

    if ($option_help
        || $option_help_all
        || scalar @ARGV)
    {
	$0 =~ m(.*/(.*));

	my $program_name = $1;

	print
	    "

$program_name: configure, compile, check, install, tag and build
releases of packages selected from a set of packages.

$program_name can operate in two modes: the default one is for a
client machine, assuming a user who tries to install the packages.
The second mode is for a developer who follows the Neurospaces
conventions where to put the src code of the packages.  The main
difference between the two modes is where this script finds the source
code.

$program_name creates a matrix of packages (rows) and build operations
(columns).  $program_name goes through the matrix, packages first, and
performs one build operation after the other for the selected package.
The options select or deselect cells in the matrix.

To find out what packages are in the database, use the '--packages'
option.  Disabled packages are not put in the matrix, enabled packages
are.  To disable packages, use the '--disable' option with a regex
argument.  To enable packages, use the '--enable' option with a regex
argument.  After building the matrix, rows are selected using
'--regex-selector' option, which by default selects all rows.

To find out about the known build operations, use '--help'.  To
disable a build operation, prefix the corresponding option with
'--no-', eg. to disable configure, use '--no-configure'.

options related to operation mode selection:
    client                 execute in client mode (for regular users, default).
    developer              execute in developer mode.

options related to operation execution profile:
    certification-report   annotate the (monotone) repository with the build_report.
    check                  check packages.
    clean                  clean before compiling.
    configure              configure before compiling.
    compile                compile packages.
    directories            create package directory structure.
    disable                explicitly disable this regex of packages in the configuration.
    dist                   build distribution tarballs.
    distcheck              check created tarballs.
    distclean              distclean before compiling.
    dry-run                do not execute any command, just report what would be done.
    enable                 explicitly enable these regex of packages in the configuration.
    help                   print usage information.
    help-all               print usage, all packages and all operations.
    install                install packages.
    packages               print known packages, in order of build.
    regex-selector         defines a regex to select specific packages.
    repo-pull              pull the repositories from this server (e.g. virtual2.cbi.utsa.edu).
    repo-sync              sync the repositories with this server (e.g. virtual2.cbi.utsa.edu).
    repo-co                checkout the code from the repository.
    tag                    set this tag on all packages.
    uninstall              uninstall packages, cannot be combined with installation options.
    upload-server          enable uploading packages to this server (e.g. https://frs.sourceforge.net/uploads).
    v|verbose              tell what is being done, specify multiple times to get
                           more feedback.
    version                give version information.

options related to installation on a client machine:
    download-server        enable downloading packages from this server (e.g. downloads.sourceforge.net).
    src-tag                use this tag for finding src directories on a client machine.
    src-dir                use this dir as the base for directories on a client machine.

So on a client machine, for package xxx, the src are found in the
directory <src-dir>/xxx-<src-tag>.  From there the build starts as
usual.


options related to behavior of external applications:
    environment            fills in the environment, can be given multiple times.
                           e.g. environment NEUROSPACES_HARNESS_OPTION_EMAIL=1 generates emails for checks that fail.

";

	print Dump($build_report->{options});

	if ($option_help_all)
	{
	    print Dump(
		       {
			all_packages => $all_packages,
			all_operations => $all_operations,
		       },
		      );
	}

	exit 1;
    }

    if ($option_packages)
    {
	print
	    "$0: packages in order of build are ("
		. (
		   join
		   ' ',
		   sort
		   {
		       $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
		   }
		   grep
		   {
		       $_ =~ /$option_regex_selector/i
		   }
		   keys %$all_packages
		  )
		    . ")\n";

	exit 1;
    }

}


sub report_exit
{
    my $exit_code = shift;

    my $description = shift;

    $build_report->{global}->{time_end} = `date`;

    #! I remove the times here, just to ease the regression testing

    if ($ENV{NEUROSPACES_BUILD_TESTING})
    {
	delete $build_report->{global}->{time_end};
	delete $build_report->{global}->{time_start};
    }

    if (defined $description
        && $exit_code eq 3)
    {
	print "*** die: $description\n";
    }

    # yaml out the build report

    if ($option_verbose > 1)
    {
	print Dump($build_report);
    }

#     # if there were errors

#     if ($error_count)
#     {
# 	# exit with failure

# 	$exit_code ||= 1;

# 	print "$0: exit_code $exit_code\n";

# 	exit $exit_code;
#     }

#     # else

#     else
    {
	# exit, possibly success

	exit $exit_code;
    }
}


sub report_message
{
    my $header = shift;

    my $trailer = shift;

    my $message = shift;

    my $lines = [ split '\n', $message, ];

    my $longest = 0;

    map
    {
	($longest < length) && ($longest = length)
    }
	@$lines;

    my $line = '-' x $longest;

    print "\n";
    print "$line\n" for 0 .. $header;
    print "\n";
    print "$message\n\n";
    print "$line\n" for 0 .. $trailer;
    print "\n";
}


sub operation_execute
{
    my $operations = shift;

    my $environment = shift;

    my $arguments = shift;

    my $description = $environment->{description};

    my $keywords = defined $environment->{keywords} ? $environment->{keywords} : 1;

    my $package_name = $environment->{package_name};

    my $reported_arguments = [ @$arguments, ];

    # if keyword expansions

    if ($keywords)
    {
	# get monotone id

	my $monotone_id = `mtn automate get_base_revision_id`;

	chomp $monotone_id;

	# define release labels

	#! copied from release-extract

	my $log = [ `mtn log --last 1`, ];

# 	my $monotone_id
# 	    = [
# 	       map
# 	       {
# 		   s/.*Revision:\s*//;

# 		   s/\s*//g;

# 		   $_;
# 	       }
# 	       grep
# 	       {
# 		   m'Revision:';
# 	       }
# 	       @$log,
# 	      ];

	my $release_label = $option_tag;

	$release_label =~ m/([^-]+)-([^-]+)?(?:-([^-]+))?/;

	my $release_major = $1 || $monotone_id;

	my $release_minor = $2 || 0;

	my $release_micro = $3 || 0;

	$arguments
	    = [
	       map
	       {
		   s/%package/$package_name/g;
		   s/%release_major/$release_major/g;
		   s/%release_micro/$release_micro/g;
		   s/%release_minor/$release_minor/g;
		   s/%version/$monotone_id/g;

		   $_;
	       }
	       @$arguments,
	      ];

	#! to prevent monotone from interpreting the yaml as an option,
	#! we prefix the report with something that does not look like an
	#! option.

	my $report_text = Dump( { build_report => $build_report, }, ) . "\n";

	$reported_arguments
	    = [
	       map
	       {
		   my $argument = $_;

		   $argument =~ s/%report/$report_text/g;

		   # replace non-LDH characters: underscores

		   $argument =~ s/_/-/g;

		   $argument;
	       }
	       @$arguments,
	      ];
    }

    # register that we are about to do this operation for this package

    push @$operations, { description => $description, package_name => $package_name, operations => $reported_arguments, };

    if (!$option_dry_run)
    {
	print "$0: package $package_name [" . (join ' ', @$arguments) . "] executing\n";

	system join " ", @$arguments;

	if ($?)
	{
	    #! assume system has given a good error message

	    die "$0: *** Error: package $package_name: $?";
	}

	if ($option_verbose)
	{
	    print "$0: package $package_name [" . (join ' ', @$arguments ) . "] executed \n";
	}
    }
    else
    {
	if ($option_verbose)
	{
	    print "$0: package $package_name [" . (join ' ', @$arguments ) . "] not executed, dry_run is $option_dry_run\n";
	}
    }
}


sub version
{
    # $Format: "    my $version=\"${package}-${label}\";"$
    my $version="installer-python-2";

    return $version;
}


main();


