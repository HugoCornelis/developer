#!/usr/bin/perl
#!/usr/bin/perl -w -d:ptkdb
#


use strict;


use Getopt::Long;

use YAML;


# options related to operation mode selection:

my $option_client = 0;
my $option_developer = 0;

# operation execution profile: default is configure, compile and install

my $option_certification_report = 0;
my $option_check = 0;
my $option_clean = 0;
my $option_compile = 1;
my $option_configure = 1;
my $option_configure_type = 'release';
my $option_directories_create = 0;
my $option_dist = 0;
my $option_dist_dir = [];
my $option_distcheck = 0;
my $option_distclean = 0;
my $option_distkeywords = 0;
my $option_docs = 0;
my $option_dry_run = 0;
my $option_install = 1;
my $option_installed_versions = 1;
my $option_regex_selector = ".*";
my $option_repo_co = 0;
my $option_repo_pull = 0;
my $option_repo_serve = 0;
my $option_repo_status = 0;
my $option_repo_sync = 0;
my $option_tag = 0;
my $option_uninstall = 0;
my $option_upload_server;
my $option_verbose = 0;
my $option_website_prepare;
my $option_website_upload;

# options related to installation on a client machine

my $option_src_tag;
my $option_src_dir;
my $option_download_server;
my $option_unpack;

# options related to behavior of external applications

my $option_environment = [];


my $all_operations = [];


my $all_packages
    = {
       configuration => {
			 dependencies => {
					 },
			 directory => "$ENV{HOME}/neurospaces_project/configuration",
			 disabled => 1,
			 order => 27,
			 version_script => 0,
			},
       dash => {
		dependencies => {
				},
		directory => "$ENV{HOME}/neurospaces_project/dash/source/snapshots/0",
		disabled => 1,
		order => 2,
		version_script => 0,
	       },
       geometry => {
		    dependencies => {
				    },
		    directory => "$ENV{HOME}/neurospaces_project/geometry/source/snapshots/0",
		    disabled => 1,
		    order => 4,
		    version_script => 0,
		   },
       gshell => {
		  dependencies => {
				   'model-container' => 'for storing the model in computer memory',
				   heccer => 'for solving single neurons',
				   ssp => 'to schedule the solvers',
				  },
		  directory => "$ENV{HOME}/neurospaces_project/gshell/source/snapshots/0",
		  order => 13,
		  version_control => {
				      port_number => 4699,
				      repository => "$ENV{HOME}/neurospaces_project/MTN/gshell.mtn",
				     },
		  version_script => 'genesis-g3 --version',
		 },
       heccer => {
		  dependencies => {
				   'model-container' => 'for storing the model in computer memory',
				  },
		  directory => "$ENV{HOME}/neurospaces_project/heccer/source/snapshots/0",
		  disabled => 0,
		  operations => {
				 './configure' => {
						   debug => [
							     '"CFLAGS=-g -O0"',
							    ],
						   release => [
							       '"CFLAGS=-g -O9"',
							      ],
						  },
				},
		  order => 2,
		  version_control => {
				      port_number => 4694,
				      repository => "$ENV{HOME}/neurospaces_project/MTN/heccer.mtn",
				     },
		 },
       installer => {
		     directory => "$ENV{HOME}/neurospaces_project/installer/source/snapshots/0",
		     disabled => 0, # disabled => 1,
		     order => 0,
		     version_control => {
					 port_number => 4696,
					 repository => "$ENV{HOME}/neurospaces_project/MTN/neurospaces-developer.mtn",
					},
		     version_script => 'neurospaces_build --version',
		    },
       'model-container' => {
			     #t make distinction between debug and release

			     './configure' => [
					       '--with-delete-operation',
					      ],
			     directory => "$ENV{HOME}/neurospaces_project/model-container/source/snapshots/0",
			     disabled => 0,
			     order => 1,
			     target_name => 'model-container',
			     version_control => {
						 port_number => 4693,
						 repository => "$ENV{HOME}/neurospaces_project/MTN/model-container.mtn",
						},
			    },
       neurospaces_prcs => {
			    directory => "$ENV{HOME}/neurospaces_project/model-container/source/snapshots/prcs.0",
			    disabled => 'obsoleted by the model-container under mtn control rather than prcs',
			    order => 0.5,
			    version_control => {
						commands => {
							     missing => undef,
							     status => [
									'prcs',
									'diff',
									'neurospaces.prj',
									'`prcs 2>/dev/null execute --not ".*\(directory\|symlink\)" neurospaces.prj | grep -v "neurospaces\.prj" | grep -v "purkinjespine" `',
									'--',
									'--unified',
								       ],
							     unknown => undef,
							    },
					       },
			    version_script => 'prcsentry Project-Version',
			   },
       'ns-genesis-SLI' => {
			    dependencies => {
					     'model-container' => 'for storing the model in computer memory',
					     heccer => 'for solving single neurons',
					    },
			    directory => "$ENV{HOME}/neurospaces_project/ns-genesis-SLI/source/snapshots/0",
			    order => 6,
			    version_control => {
						port_number => 4692,
						repository => "$ENV{HOME}/neurospaces_project/MTN/ns-gen.mtn",
					       },
			    version_script => 0,
			   },
       'project-browser' => {
			     dependencies => {
					      'model-container' => 'for storing the model in computer memory',
					      heccer => 'for solving single neurons',
					      ssp => 'to schedule the solvers',
					     },
			     directory => "$ENV{HOME}/neurospaces_project/project-browser/source/snapshots/0",
			     disabled => 1,
			     order => 7,
			     version_control => {
						 port_number => 4697,
						 repository => "$ENV{HOME}/neurospaces_project/MTN/neurospacesweb.mtn",
						},
			     version_script => 'pb-version',
			    },
       ssp => {
	       dependencies => {
				'model-container' => 'for storing the model in computer memory',
				heccer => 'for solving single neurons',
			       },
	       directory => "$ENV{HOME}/neurospaces_project/ssp/source/snapshots/0",
	       disabled => 0,
	       order => 3,
	       version_control => {
				   port_number => 4695,
				   repository => "$ENV{HOME}/neurospaces_project/MTN/ssp.mtn",
				  },
	      },
       studio => {
		  dependencies => {
				   'model-container' => 'for storing the model in computer memory',
				   heccer => 'for solving single neurons',
				   ssp => 'to schedule the solvers',
				  },
		  directory => "$ENV{HOME}/neurospaces_project/studio/source/snapshots/0",
		  disabled => 0,
		  order => 5,
		  version_control => {
				      port_number => 4698,
				      repository => "$ENV{HOME}/neurospaces_project/MTN/studio.mtn",
				     },
		  version_script => 'neurospaces --version',
		 },
       system => {
		  directory => "$ENV{HOME}/neurospaces_project/.",
		  disabled => 1,
		  order => 29,
		  version_script => 0,
		 },
       userdocs => {
		    directory => "$ENV{HOME}/neurospaces_project/userdocs/source/snapshots/0",
		    disabled => 0,
		    order => 30,
		    version_control => {
					port_number => 4700,
					repository => "$ENV{HOME}/neurospaces_project/MTN/userdocs.mtn",
				       },
		    version_script => 0,
		   },
      };


my $version_control_servers
    = [
       {
	name => 'default',
	address => 'virtual2.cbi.utsa.edu',
       },
       {
	name => 'default2',
	address => 'repo.cbi.utsa.edu',
       },
       {
	name => 'default3',
	address => 'repo-genesis3.cbi.utsa.edu',
       },
       {
	name => 'backup_server',
	address => '129.115.117.50',
       },
      ];


my $build_report
    = {
       description => {
		       command => $0,
		       name => "Build report",
		      },
       global => {
# 		  config => $config,
# 		  error_count => $error_count,
		  status => 'initializing',
		  test_count => 0,
		  time_start => `date`,
		 },
       client => {
		  OS => $^O,
		 },
      };


$SIG{'__DIE__'}
    = sub
      {
	  use Carp;

	  print STDERR Carp::longmess(@_);

	  $build_report->{global}->{status} = 'Died: ' . join " ", @_;

	  report_exit(3, @_);
      };


$SIG{'INT'}
    = sub
      {
	  $build_report->{global}->{status} = 'Interrupted';

	  report_exit(2);
      };


#
# daemonize()
#
# Daemonize the running process by setting a session id, optionally close
# shared resources between child and parent (files), and print a diagnostic
# message on STDOUT.  '$pid' is replaced with the child process id in the
# diagnostic message.
#
# returns the created process id if $options->{return} is set, otherwise
# exits.
#

sub daemonize
{
    my $close_files = shift;

    my $options = shift;

    my $message = $options->{message} || '';

    my $pid;

#     mlog("daemonize ($$)", "forking");

    if ($pid = fork())
    {
# 	mlog("daemonize ($$)", "forked");

        # parent : print optional message and exit or return

	if ($message)
	{
	    $message =~ s/\$pid/$pid/g;

	    print($message);
	}

	if ($options->{return})
	{
# 	    mlog("daemonize ($$)", "forked : return");

	    return $pid;
	}
	else
	{
# 	    mlog("daemonize ($$)", "forked : exit");

	    exit(0);
	}
    }

    # child : create session, optionally close shared resources.

    # set default result

    my $result = 1;

#     mlog("daemonize ($$)", "forked : cd");

    use POSIX;

    POSIX::setsid();
    chdir('/');

    if ($close_files)
    {
# 	mlog("daemonize ($$)", "closing files");

	# unlock shared resources : close all file descriptors.

	use FileHandle;

	my $closed = FileHandle->new(">/tmp/closed.txt");

	my $files = POSIX::sysconf(POSIX::_SC_OPEN_MAX);

	if ($closed)
	{
	    print $closed "Closing $files file handles.\n";
	}

	if ($close_files > 0)
	{
	    $files = $close_files;
	}

	while ($files > -1)
	{
	    my $result = "not done";

	    if (!defined $closed || $closed->fileno() != $files)
	    {
		$result = POSIX::close($files) || -1;
	    }

	    if (defined $closed)
	    {
		print $closed "Closed file handle $files : $result\n";
	    }

	    $files--;
	}

	$closed->close();
    }

#     mlog("daemonize ($$)", "done");

    return $result;
}


sub main
{
    read_cmd_line();

    # set status: running

    $build_report->{global}->{status} = 'Running';

    # execute all operations

    all_operations_execute();

    # finish

    $build_report->{global}->{status} = 'Finished';

    report_exit(0);
}


sub all_operations_execute
{
    # initialize operations related matters

    $build_report->{operations} = [];

    my $operations = $build_report->{operations};

    # loop over all packages, in dependency order

    foreach my $package_name (sort
			      {
				  $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
			      }
			      keys %$all_packages)
    {
	if ($option_verbose)
	{
	    print "$0: examining package $package_name\n";
	}

	my $package = $all_packages->{$package_name};

	if ($package->{disabled})
	{
	    if ($option_verbose)
	    {
		print "$0: package $package_name skipped, disabled is $package->{disabled}\n";
	    }

	    next;
	}

	if ($package_name !~ /$option_regex_selector/i)
	{
	    if ($option_verbose)
	    {
		print "$0: package $package_name skipped, not selected using --regex-selector\n";
	    }

	    next;
	}

	# loop over all installation operations

	foreach my $all_operation (@$all_operations)
	{
	    my $condition_value = $all_operation->{condition};

	    my $operation = $all_operation->{operation};

	    my $description = $all_operation->{description} || (join ' ', @$operation );

	    # if the uninstall option is given

	    if ($option_uninstall)
	    {
		# but this operation is not uninstall

		if (ref $operation eq 'ARRAY'
		    && exists $operation->[5]
		    && $operation->[5] ne 'uninstall')
		{
		    # don't execute, doesnot make sense

		    $condition_value = 0;

		    if ($option_verbose > 1)
		    {
			print "$0: package $package_name [" . $description . "] condition turned to false \n";
		    }

		}
	    }

	    # if the operation's condition is true

	    if ($condition_value)
	    {
		if ($option_verbose > 1)
		{
		    print "$0: package $package_name [" . $description . "] preparing to execute \n";
		}

		# construct package directory

		my $target_directory = $package->{directory};

		# if we are working on a client machine

		if ($option_client)
		{
		    if (!defined $option_src_dir
			|| !defined $option_src_tag)
		    {
			die "$0: *** Error: you must set option_src_dir and option_src_tag when working in client mode";
		    }

		    # construct a target directory from the src-* options

		    $target_directory = $option_src_dir . "/" . $package_name . "-" . $option_src_tag;
		}

		# if this is perl code

		if (ref $operation eq 'CODE')
		{
		    # register that we are about to do this operation for this package

		    push @$operations, { package_name => $package_name, operations => $operation, };

		    if (!$option_dry_run)
		    {
			my $directory = $option_src_dir ? $option_src_dir : $target_directory;

			my $filename_base = $package->{target_name} || $package_name;

			my $filename = $filename_base . "-" . $option_src_tag . ".tar.gz";

			my $prefix = $option_download_server =~ m|://| ? '' : 'http://';

			my $url = $prefix . $option_download_server . "/neurospaces/" . $filename;

			my $result
			    = &$operation
				(
				 {
				  description => $description,
				  directory => $directory,
				  ( $option_src_tag ? (filename => $filename,) : (), ),
				  operations => $operations,
				  package => $package,
				  package_name => $package_name,
				  url => $url,
				 },
				);
		    }
		    else
		    {
			if ($option_verbose)
			{
			    # embedded perl code

			    use Data::Dumper;

			    local $Data::Dumper::Deparse = 1;

			    my $perl_code = Dumper($operation);

			    print "$0: package $package_name [" . (join ' ', $perl_code ) . "] not executed, dry_run is $option_dry_run\n";
			}
		    }
		}

		# if the operation is not perl code

		else
		{
		    # if package directory exists

		    if (-e $target_directory)
		    {
			# go to package directory

			use Cwd;

			my $current_directory = getcwd();

			if ($option_verbose > 1)
			{
			    print "$0: package $package_name, chdir from ($current_directory) to ($target_directory)\n";
			}

			my $success = chdir $target_directory;

			if (!$success)
			{
			    die "$0: *** Error: package $package_name cannot change from directory ($current_directory) to directory ($target_directory): $!";
			}

			# add options specific to this operation and package

			#! so here the model container gets configured with --delete-operation

			#t also need separation between debug and release overhere

			my $package_options = [];

			push
			    @$package_options,
				@{$package->{$operation->[0]} || []};

			# make difference between options specific for release and debug builds

			if ($package->{operations}->{$operation->[0]})
			{
			    # construct variable name for type of build: remove things like './' from configure lines

			    my $text = $operation->[0];

			    $text =~ s(\.)()g;
			    $text =~ s(/)()g;

			    $text = "\$option_" . $text . "_type";

			    # get the build type from the options

			    my $type = eval $text;

			    if ($@)
			    {
				die $@;
			    }

			    # construct options for this operation

			    my $build_type_options = $package->{operations}->{$operation->[0]}->{$type};

			    push
				@$package_options,
				    @$build_type_options;
			}

			# perform the operation on the package

			operation_execute
			    (
			     $operations,
			     {
			      description => $description,
			      keywords => $option_developer,
			      package_name => $package_name,
			     },
			     [
			      @$operation,
			      @$package_options,
			     ],
			    );

			if ($option_verbose > 1)
			{
			    print "$0: package $package_name, chdir from ($target_directory) to ($current_directory)\n";
			}

			$success = chdir $current_directory;

			if (!$success)
			{
			    die "$0: *** Error: package $package_name, cannot change from directory ($target_directory) to directory ($current_directory): $!";
			}
		    }
		    else
		    {
			if ($option_verbose)
			{
			    print "$0: package $package_name skipped, [" . $description . "], directory ($target_directory) not found, assuming this package source is not installed\n";
			}
		    }
		}
	    }
	    else
	    {
		if ($option_verbose > 1)
		{
		    print "$0: package $package_name [" . $description . "] skipped, condition_value is $condition_value\n";
		}
	    }
	}
    }
}


sub read_cmd_line
{
    my $option_disable;
    my $option_enable;
    my $option_help = 0;
    my $option_help_all = 0;
    my $option_help_operations = 0;
    my $option_help_packages = 0;
    my $option_help_repositories;
    my $option_version;

    my $result
	= GetOptions(
		     # options related to operation mode selection:

		     "client!" => \$option_client,
		     "developer!" => \$option_developer,

		     # operation execution profile: default is configure, compile and install

		     "certification-report!" => \$option_certification_report,
		     "check!" => \$option_check,
		     "clean!" => \$option_clean,
		     "compile!" => \$option_compile,
		     "configure!" => \$option_configure,
		     "configure-type=s" => \$option_configure_type,
		     "directories-create!" => \$option_directories_create,
		     "disable=s" => \$option_disable,
		     "dist!" => \$option_dist,
		     "distcheck!" => \$option_distcheck,
		     "distclean!" => \$option_distclean,
		     "dist-dir=s" => $option_dist_dir,
		     "distkeywords!" => \$option_distkeywords,
		     "docs!" => \$option_docs,
		     "dry-run!" => \$option_dry_run,
		     "enable=s" => \$option_enable,
		     "help!" => \$option_help,
		     "help-all!" => \$option_help_all,
		     "help-operations!" => \$option_help_operations,
		     "help-packages!" => \$option_help_packages,
		     "help-repositories!" => \$option_help_repositories,
		     "install!" => \$option_install,
		     "installed-versions!" => \$option_installed_versions,
		     "regex-selector=s" => \$option_regex_selector,
		     "repo-co!" => \$option_repo_co,
		     "repo-pull=s" => \$option_repo_pull,
		     "repo-serve!" => \$option_repo_serve,
		     "repo-status!" => \$option_repo_status,
		     "repo-sync=s" => \$option_repo_sync,
		     "tag=s" => \$option_tag,
		     "uninstall!" => \$option_uninstall,
		     "upload-server=s" => \$option_upload_server,
		     "verbose+" => \$option_verbose,
		     "version" => \$option_version,
		     "website-prepare!" => \$option_website_prepare,
		     "website-upload!" => \$option_website_upload,

		     # options related to installation on a client machine

		     "download-server=s" => \$option_download_server,
		     "src-tag=s" => \$option_src_tag,
		     "src-dir=s" => \$option_src_dir,
		     "unpack!" => \$option_unpack,

		     # options related to behavior of external applications

		     "environment=s" => $option_environment,
		    );

    if (!$result)
    {
	die "$0: *** Error: Error in option processing";
    }

    # process operation mode options

    #! we give client mode precedence over developer mode

    if (!$option_client
	&& !$option_developer)
    {
	$option_client = 1;
    }

    if ($option_client)
    {
	$option_developer = 0;
    }

    if ($option_developer)
    {
	$option_client = 0;
    }

    # fill in the build report

    $build_report->{options}
	= {
	   # options related to operation mode selection:

	   "client!" => $option_client,
	   "developer!" => $option_developer,

	   # operation execution profile: default is configure, compile and install

	   "certification-report!" => $option_certification_report,
	   "check!" => $option_check,
	   "clean!" => $option_clean,
	   "compile!" => $option_compile,
	   "configure!" => $option_configure,
	   "configure-type=s" => $option_configure_type,
	   "directories-create!" => $option_directories_create,
	   "disable=s" => $option_disable,
	   "dist!" => $option_dist,
	   "distcheck!" => $option_distcheck,
	   "distclean!" => $option_distclean,
	   "dist-dir=s" => $option_dist_dir,
	   "distkeywords!" => $option_distkeywords,
	   "docs!" => $option_docs,
	   "dry-run!" => $option_dry_run,
	   "enable=s" => $option_enable,
	   "help!" => $option_help,
	   "help-all!" => $option_help_all,
	   "help-operations!" => $option_help_operations,
	   "help-packages!" => $option_help_packages,
	   "help-repositories!" => $option_help_repositories,
	   "install!" => $option_install,
	   "installed-versions!" => $option_installed_versions,
	   "regex-selector=s" => $option_regex_selector,
	   "repo-co!" => $option_repo_co,
	   "repo-pull=s" => $option_repo_pull,
	   "repo-serve!" => $option_repo_serve,
	   "repo-status!" => $option_repo_status,
	   "repo-sync=s" => $option_repo_sync,
	   "tag=s" => $option_tag,
	   "uninstall!" => $option_uninstall,
	   "upload-server=s" => $option_upload_server,
	   "verbose+" => $option_verbose,
	   "version" => $option_version,
	   "website-prepare!" => $option_website_prepare,
	   "website-upload!" => $option_website_upload,

	   # options related to installation on a client machine

	   "download-server=s" => $option_download_server,
	   "src-tag=s" => $option_src_tag,
	   "src-dir=s" => $option_src_dir,
	   "unpack!" => $option_unpack,

	   # options related to behavior of external applications

	   "environment=s" => $option_environment,
	  };

    if ($option_version)
    {
	my $version = version();

	print $version . "\n";

	exit 1;
    }

    # process enable and disable options overhere, such that there
    # effect is mirrored in the help output

    if ($option_enable)
    {
	# loop over all packages, in dependency order

	foreach my $package_name (sort
				  {
				      $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
				  }
				  keys %$all_packages)
	{
	    # if should be enabled

	    if ($package_name =~ /$option_enable/)
	    {
		# enable but don't overwrite existing value

		my $package = $all_packages->{$package_name};

		if ($package->{disabled})
		{
		    $package->{disabled} = 0;
		}
	    }
	}
    }

    if ($option_disable)
    {
	# loop over all packages, in dependency order

	foreach my $package_name (sort
				  {
				      $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
				  }
				  keys %$all_packages)
	{
	    # if should be disabled

	    if ($package_name =~ /$option_disable/)
	    {
		# disable but don't overwrite existing value

		my $package = $all_packages->{$package_name};

		if (!$package->{disabled})
		{
		    $package->{disabled} = $option_disable;
		}
	    }
	}
    }

    my $tag_set_in_tag_database = 0;

    # merge operations with options that affect the execution of the
    # operations

    $all_operations
	= [
	   {
	    condition => $option_repo_serve,
	    description => 'serving source code repositories',
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		my $repository_name
		    = $package_information->{package}->{version_control}->{repository}
			|| $directory . '/' . $package_name . '/' . 'mtn';

		my $port_number = $package_information->{package}->{version_control}->{port_number};

		# if not enough information for serving

		if (not -f $repository_name)
		{
		    die "$0: *** Error: cannot serve repository, repository_name not set";
		}

		if (not $port_number)
		{
		    die "$0: *** Error: cannot serve repository, port_number not set";
		}

# 		# translate well known names to a routable address

# 		my $repo_server = version_control_translate_server($option_repo_serve);

		# initialize the repository if necessary

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'test', '-f', $repository_name, '||', 'mtn', '--db', $repository_name, 'db', 'init',
		     ],
		    );

		# detach

		my $pid
		    = daemonize
			(1,
			 {
			  message => "$0: daemonizing for $description, $package_name\n",
			  return => 1,
			 },
			);

		if ($pid ne 1)
		{
		    # serve the repository

		    operation_execute
			(
			 $operations,
			 {
			  description => $description,

			  #t always zero here, but I guess this simply depends on working in client mode ?

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  # 		      'mtn', '--db', $repository_name, 'serve', "$repo_server:$port_number",
			  'mtn', '--db', $repository_name, 'serve', "--bind=:$port_number",
			 ],
			);

		    # never return

		    exit 1;
		}
	    },
	   },
	   {
	    condition => $option_directories_create,
	    description => "creating directory",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		# create directory

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'mkdir', '-p', $directory,
		     ],
		    );
	    },
	   },
	   {
	    condition => $option_repo_pull,
	    description => "pulling repository",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		my $repository_name
		    = $package_information->{package}->{version_control}->{repository}
			|| $directory . '/' . $package_name . '/' . 'mtn';

		my $port_number = $package_information->{package}->{version_control}->{port_number};

		# create repository directory

		my $repository_directory = $repository_name;

		$repository_directory =~ s((.*)/.*)($1);

		operation_execute
		    (
		     $operations,
		     {
		      description => "$description (creating repository directory)",

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'mkdir', '-p', $repository_directory,
		     ],
		    );

		# initialize the repository if necessary

		operation_execute
		    (
		     $operations,
		     {
		      description => "$description: (initializing the repository)",

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'test', '-f', $repository_name, '||', 'mtn', '--db', $repository_name, 'db', 'init',
		     ],
		    );

		# if not enough information for pulling

		if (not -f $repository_name)
		{
		    die "$0: *** Error: cannot pull repository, repository_name not set";
		}

		if (not $port_number)
		{
		    die "$0: *** Error: cannot pull repository, port_number not set";
		}

		# translate well known names to a routable address

		my $repo_server = version_control_translate_server($option_repo_pull);

		# pull the repository

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'mtn', '--db', $repository_name, 'pull', "$repo_server:$port_number", '"*"',
		     ],
		    );
	    },
	   },
	   {
	    condition => $option_repo_co,
	    description => "checkout or update from repository",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		my $repository_name
		    = $package_information->{package}->{version_control}->{repository}
			|| $directory . '/' . $package_name . '/' . 'mtn';

		my $port_number = $package_information->{package}->{version_control}->{port_number};

		# if not enough information for checkout

		if (not -f $repository_name)
		{
		    die "$0: *** Error: cannot checkout from repository, repository_name not set";
		}

		if (not $port_number)
		{
		    die "$0: *** Error: cannot checkout from repository, port_number not set";
		}

		# change the directory

		if (not chdir $directory)
		{
		    die "$0: *** Error: cannot change to directory $directory";
		}

		# merge code

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
# 		      'test', '-d', '_MTN',
# 		      '||',
		      'mtn', '--db', $repository_name, '--branch', '0', 'merge',
		     ],
		    );

		# checkout code

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'test', '-d', '_MTN',
		      '||', 'mtn', '--db', $repository_name, '--branch', '0', 'co', '.',
		     ],
		    );

		# update code

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'mtn', '--db', $repository_name, '--branch', '0', 'update',
		     ],
		    );
	    },
	   },
	   {
	    condition => $option_distclean && !$option_uninstall,
	    operation => [ 'make', 'distclean', ],
	   },
	   {
	    condition => $option_distkeywords,
	    operation => [
			  #! after keyword expansion, regenerate the
			  #! autotool related files that perhaps are
			  #! checked in.

			  ( 'make', 'dist-keywords', ),
			  ( '&&', 'make', 'clean', ),
			  ( '&&', 'make', 'clean', ),
			 ],
	   },
	   {
	    condition => $option_tag,
	    operation => [
			  ( "test", "!", '"`mtn ls unknown && mtn ls missing && mtn ls changed`"', ),
			  ( '&&', 'release-expand', "'%package'", "'%release_major'", "'%release_minor'", "'%release_micro'", "'%release_major-%release_minor'", 'hugo.cornelis@gmail.com', '--verbose', ),

			  #! after keyword expansion, regenerate the
			  #! autotool related files that perhaps are
			  #! checked in.

			  ( '&&', 'make', 'clean', ),
			  ( '&&', 'make', 'clean', ),
			  ( "&&", 'mtn', 'ci', "-m", "'1. Keywords only: $option_tag\n'", ),
			  ( "&&", "test", "!", '"`mtn ls unknown && mtn ls missing && mtn ls changed`"', ),
			 ],
	   },
	   {
	    condition => $option_tag,
	    operation => [
			  #! in a separate operation such that we have the correct %version
			  #! gets replaced by `mtn automate get_base_revision_id`
			  #! during build variable substitution in sub operation_execute()

			  ( 'mtn', 'tag', '\'%version\'', "'$option_tag'", ),
			 ],
	   },
	   {
	    condition => $option_tag,
	    description => "putting the tag in the tag database",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $filename = $package_information->{filename};

		my $package_name = $package_information->{package_name};

		my $url = $package_information->{url};

		# if the tag has already been added for this run

		if ($tag_set_in_tag_database)
		{
		    # return

		    return;
		}

		use YAML;

		my $tag_database_filename = '/etc/neurospaces/tag_database.yml';

		my $tag_database = YAML::LoadFile($tag_database_filename);

		if (!$tag_database)
		{
		    die "$0: *** Error: cannot read $tag_database_filename";
		}

		if ($option_verbose > 1)
		{
		    print "$0: package $package_name [$description ($option_tag)] executing\n";
		}

		my $tags = $tag_database->{tags};

		push
		    @$tags,
		    {
		     'date' => `date`,
		     'regex-selector' => $option_regex_selector,
		     'tag' => $option_tag,
		    };

		YAML::DumpFile($tag_database_filename, $tag_database);

		# we do this at most once per run

		$tag_set_in_tag_database = 1;

		#t do a checkin of the configuration package (contains
		#t the tag_database).
	    },
	   },
	   {
	    condition => $option_download_server,
	    description => "downloading",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $filename = $package_information->{filename};

		my $package_name = $package_information->{package_name};

		my $url = $package_information->{url};

		# create the directory

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'mkdir', '-p', $directory,
		     ],
		    );

		if ($option_verbose > 1)
		{
		    print "$0: package $package_name [$description from $url to $filename] executing\n";
		}

		if ($option_download_server =~ m(^file://))
		{
		    # create the directory

		    operation_execute
			(
			 $operations,
			 {
			  description => $description,

			  #t always zero here, but I guess this simply depends on working in client mode ?

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'mkdir', '-p', $directory,
			 ],
			);

		    # copy the tarball

		    operation_execute
			(
			 $operations,
			 {
			  description => $description,

			  #t always zero here, but I guess this simply depends on working in client mode ?

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'cp', $filename, $directory . $filename,
			 ],
			);

		}
		else
		{
		    # download the package

		    use LWP::Simple;

		    my $http_response = getstore($url, $directory . '/' . $filename);

		    if (!is_success($http_response))
		    {
			warn "$0: *** Warning: $description from $option_download_server: $http_response";
		    }
		}
	    },
	   },
	   {
	    condition => $option_download_server || $option_unpack,
	    description => "unpacking",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $filename = $package_information->{filename};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		# change the directory

		chdir $directory;

		# unpack the package

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'tar', 'xfvz', $filename,
		     ],
		    );
	    },
	   },

	   # everything that is compilation related needs a configure script, so create it.

	   {
	    condition => $option_configure || $option_compile || $option_check || $option_install,
	    operation => [ 'test', '-f', './configure', '||', './autogen.sh', ],
	   },
	   {
	    condition => $option_configure,
	    operation => [ './configure', ],
	   },

	   # everything that is compilation related needs makefiles, so create them.

	   {
	    condition => $option_compile || $option_check || $option_install,
	    operation => [ 'test', '-f', './Makefile', '||', './configure', ],
	   },
	   {
	    condition => $option_clean,
	    operation => [ 'make', 'clean', ],
	   },
	   {
	    condition => $option_compile,
	    operation => [ 'make', ],
	   },
	   {
	    condition => $option_check,
	    operation => [ 'make', 'check', ],
	   },
	   {
	    condition => $option_dist,
	    operation => [ 'export', 'NEUROSPACES_RELEASE=1', '&&', 'make', 'dist', ],
	   },
	   {
	    condition => $option_distcheck,
	    operation => [ 'export', 'NEUROSPACES_RELEASE=1', '&&', 'make', 'distcheck', ],
	   },
	   {
	    #! always make as the regular user to avoid cluttering the
	    #! source directory with root owned files

	    condition => $option_compile && !$option_uninstall && $option_install,
	    operation => [ 'make', '&&', 'sudo', 'make', 'install', ],
	   },
	   {
	    condition => $option_docs,
	    operation => [ 'make', 'docs', ],
	   },
	   {
	    condition => $option_website_prepare,
	    operation => [ 'make', 'html-upload-prepare', ],
	   },
	   {
	    condition => $option_website_upload,
	    operation => [ 'make', 'html-upload', ],
	   },
	   {
	    condition => $option_installed_versions,
	    description => 'installed versions',
	    operation =>
	    sub
	    {
		my $package_information = shift;

		my $package = $package_information->{package};

		my $version_script = $package->{version_script};

		if (!defined $version_script)
		{
		    $version_script = "$package_information->{package_name} --version";
		}

		if ($version_script ne 0)
		{
		    system $version_script;
		}
	    },
	   },
	   {
	    condition => $option_uninstall,
	    operation => [ 'make', 'clean', '&&', 'sudo', 'make', 'uninstall', ],
	   },
	   {
	    condition => $option_upload_server,
	    description => "uploading",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $filename = $package_information->{filename};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		my $url = $package_information->{url};

		if (!$filename)
		{
		    die "$0: *** Error: no filename defined for uploading";
		}

		if ($option_verbose)
		{
		    print "$0: package $package_name [$description $filename to $option_upload_server] executing\n";
		}

		# change the directory

		chdir $directory;

		# upload the package

		$option_upload_server =~ m(((.*)://)?([^/]+)(.*));

		my $upload_protocol = $2 || 'https';

		my $upload_host = $3;

		my $upload_directory = $4;

		my $module_names
		    = {
		       file => '-1',
		       ftp => 'Net::FTP',
		       https => 'HTTP::DAV',
		       sftp => 'Net::SFTP',
		      };

		my $module_name = $module_names->{$upload_protocol};

		my $login_info = YAML::LoadFile("$ENV{HOME}/.sourceforge_login");

		my $user = $login_info->{user};

		my $password = $login_info->{password};

		my $try_something_very_sophisticated_with_broken_libraries = 'no';

		if ($try_something_very_sophisticated_with_broken_libraries eq 'yes')
		{
		    my $loaded_protocol_module = eval "require $module_name";

		    if ($@)
		    {
			no strict "refs";

			if (exists ${"::"}{verbose} && $::option_verbose)
			{
			    print STDERR "$0: cannot load protocol module $module_name because of: $@\n";
			    print STDERR "$0: continuing.\n";
			}
		    }

		    my $ftp;

		    if ($upload_protocol =~ /^s?ftp$/)
		    {
			$ftp
			    = eval "$module_name->new('$upload_host', Debug => 0, user => '$user', password => '$password', )"
				or die "$0: *** Error: for $filename: cannot connect to $upload_host: $@";
		    }
		    else
		    {
			$ftp
			    = eval "HTTP::DAV->new()"
				or die "$0: *** Error: for $filename: cannot connect to $upload_host: $@";

			$ftp->credentials
			    (
			     -user=> $user,
			     -pass => $password,
			     -url => $option_upload_server,
			    );

			$ftp->open( -url=> $option_upload_server, )
			    or die("$0: *** Error: cannot open $option_upload_server: " . $ftp->message() . "\n");
		    }

# 		    $ftp->login("anonymous", '-anonymous@')
# 			or die "$0: *** Error: for $filename: cannot login to $upload_host", $ftp->message();

		    $ftp->cwd($upload_directory)
			or die "$0: *** Error: for $filename: cannot change working directory to $upload_directory", $ftp->message();

		    if ($upload_protocol =~ /^s?ftp$/)
		    {
			$ftp->binary()
			    or die "$0: *** Error: for $filename: cannot switch to binary ftp mode", $ftp->message();

			$ftp->hash()
			    or die "$0: *** Error: for $filename: cannot enable hash printing", $ftp->message();
		    }

		    $ftp->put($filename)
			or die "$0: *** Error: for $filename: Net::FTP::put() failed ", $ftp->message();

		    if ($upload_protocol =~ /^s?ftp$/)
		    {
			$ftp->quit();
		    }
		    else
		    {
			$ftp->unlock();
		    }
		}

		# else we are trying a hardcoded solution that should work

		else
		{
		    if ($upload_protocol eq 'sftp')
		    {
			use Expect;

			my $expector = Expect->new();

			#! see the expect manual for this one

			$expector->raw_pty(1);

			$expector->spawn('sftp', "$user\@$upload_host",)
			    or die "$0: cannot spawn 'sftp': $!\n";

			my ($matched_pattern_position,
			    $error,
			    $successfully_matching_string,
			    $before_match,
			    $after_match)
			    = $expector->expect(15, "word:", );

			$expector->send("$password\n");

			my $prompt = "sftp>";

			($matched_pattern_position,
			 $error,
			 $successfully_matching_string,
			 $before_match,
			 $after_match)
			    = $expector->expect(5, $prompt, );

			$upload_directory =~ s|^/||;

			$expector->send("cd $upload_directory\n");

			($matched_pattern_position,
			 $error,
			 $successfully_matching_string,
			 $before_match,
			 $after_match)
			    = $expector->expect(5, $prompt, );

			$expector->send("put '$filename'\n");

			($matched_pattern_position,
			 $error,
			 $successfully_matching_string,
			 $before_match,
			 $after_match)
			    = $expector->expect(600, $prompt, );

			$expector->send("quit\n");
		    }
		    elsif ($upload_protocol eq 'file')
		    {
			# construct the target directory

			my $target_directory = $upload_host . $upload_directory;

			# make sure the target directory is rooted

			if ($target_directory !~ /^\//)
			{
			    $target_directory = "/$target_directory";
			}

			# create the directory

			operation_execute
			    (
			     $operations,
			     {
			      description => $description,

			      #t always zero here, but I guess this simply depends on working in client mode ?

			      keywords => 0,
			      package_name => $package_name,
			     },
			     [
			      'mkdir', '-p', $target_directory,
			     ],
			    );

			# copy the tarball

			operation_execute
			    (
			     $operations,
			     {
			      description => $description,

			      #t always zero here, but I guess this simply depends on working in client mode ?

			      keywords => 0,
			      package_name => $package_name,
			     },
			     [
			      'cp', $filename, $target_directory,
			     ],
			    );

		    }
		    else
		    {
			die "$0: *** Error: unknown upload protocol $upload_protocol";
		    }
		}
	    },
	   },
	   {
	    condition => (scalar @$option_dist_dir),
	    description => "copying files to the distribution directories",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $filename = $package_information->{filename};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		my $url = $package_information->{url};

		if (!$filename)
		{
		    die "$0: *** Error: no filename defined to copy to the distribution directories";
		}

		# change the directory

		chdir $directory;

		foreach my $dist_dir (@$option_dist_dir)
		{
		    # copy the package

		    operation_execute
			(
			 $operations,
			 {
			  description => $description,

			  #t always zero here

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'cp', $filename, $dist_dir,
			 ],
			);
		}
	    },
	   },
	   {
	    condition => $option_certification_report,
	    operation => [ 'mtn', 'cert', '\'%version\'', '--', 'build_report', '\'%report\'', ],
	   },
	   {
	    condition => $option_repo_status,
	    description => 'comparing workspace with source code repository branch head',
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		my $repository_name
		    = $package_information->{package}->{version_control}->{repository}
			|| $directory . '/' . $package_name . '/' . 'mtn';

		my $port_number = $package_information->{package}->{version_control}->{port_number};

		# print header

		my $text = "$0: *** package $package_name";

		print "\n\n" . ("-" x length $text) . "\n$text\n";

# 		# if not enough information for comparing

# 		if (not -f $repository_name)
# 		{
# 		    die "$0: *** Error: cannot compare with repository, repository_name not set";
# 		}

# 		if (not $port_number)
# 		{
# 		    die "$0: *** Error: cannot compare with repository, port_number not set";
# 		}

		# change the directory

		chdir $directory;

		# construct a default set with information commands

		my $information_sets
		    = {
		       missing => [ "mtn", "ls", "missing", ],
		       status => [ 'mtn', 'status', ],
		       unknown => [ "mtn", "ls", "unknown", ],
		      };

		# go through all informational operations

		foreach my $information_set (
					     qw(
						missing
						unknown
						status
					       )
					    )
		{
		    # and overwrite with specific commands for this package if applicable

		    #! exists such that a '0' or undef can erase the default information_set command

		    if (exists $package_information->{package}->{version_control}->{commands}->{$information_set})
		    {
			$information_sets->{$information_set}
			    = $package_information->{package}->{version_control}->{commands}->{$information_set};
		    }
		}

		# go through all informational operations

		foreach my $information_set (
					     qw(
						missing
						unknown
						status
					       )
					    )
		{
		    # if the information_set command is defined

		    if ($information_sets->{$information_set})
		    {
			# execute the information_set command

			operation_execute
			    (
			     $operations,
			     {
			      description => "information_set $information_set",

			      #t always zero here, but I guess this simply depends on working in client mode ?

			      keywords => 0,
			      package_name => $package_name,
			     },
			     $information_sets->{$information_set},
			    );
		    }
		}
	    },
	   },
	   {
	    condition => $option_repo_sync,
	    description => 'syncing repository',
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		my $repository_name
		    = $package_information->{package}->{version_control}->{repository}
			|| $directory . '/' . $package_name . '/' . 'mtn';

		my $port_number = $package_information->{package}->{version_control}->{port_number};

		# if not enough information for syncing

		if (not -f $repository_name)
		{
		    die "$0: *** Error: cannot sync repository, repository_name not set";
		}

		if (not $port_number)
		{
		    die "$0: *** Error: cannot sync repository, port_number not set";
		}

		# translate well known names to a routable address

		my $repo_server = version_control_translate_server($option_repo_sync);

		# initialize the repository if necessary

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'test', '-f', $repository_name, '||', 'mtn', '--db', $repository_name, 'db', 'init',
		     ],
		    );

		# sync the repository

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'mtn', '--db', $repository_name, 'sync', "$repo_server:$port_number",
		     ],
		    );
	    },
	   },
	  ];

    # process environment options

#     # tell neurospaces_harness if to send emails for this

#     $ENV{NEUROSPACES_HARNESS_OPTION_EMAIL} = $option_neurospaces_harness_email;

    # build the environment for external applications

    foreach my $environment_setting (@$option_environment)
    {
	$environment_setting =~ /^(.*?)=(.*)$/;

	my $variable = $1;

	my $value = $2;

	$ENV{$variable} = $value;
    }

    if ($option_verbose
	&& @$option_environment)
    {
	use YAML;

	print Dump(\%ENV);
    }

    # reporting options

    if ($option_help
        || $option_help_all
        || scalar @ARGV)
    {
	$0 =~ m(.*/(.*));

	my $program_name = $1;

	print Dump($build_report->{options});

	print
	    "

$program_name: configure, compile, check, install, tag and build
releases of packages selected from a set of packages.

$program_name can operate in two modes: the default one is for a
client machine, assuming a user who tries to install the packages.
The second mode is for a developer who follows the Neurospaces
conventions where to put the src code of the packages.  The main
difference between the two modes is where this script finds the source
code.

$program_name creates a matrix of packages (rows) and build operations
(columns).  $program_name goes through the matrix, packages first, and
performs one build operation after the other for the selected package.
The options select or deselect cells in the matrix.

To find out what packages are in the database, use the '--help-packages'
option.  Disabled packages are not put in the matrix, enabled packages
are.  To disable packages, use the '--disable' option with a regex
argument.  To enable packages, use the '--enable' option with a regex
argument.  After building the matrix, rows are selected using
'--regex-selector' option, which by default selects all rows.

To find out about the known build operations, use '--help'.  To
disable a build operation, prefix the corresponding option with
'--no-', eg. to disable configure, use '--no-configure'.

options related to operation mode selection:
    --client                 execute in client mode (for regular users, default).
    --developer              execute in developer mode.

options related to operation execution profile:
    --certification-report   annotate the (monotone) repository with the build_report.
    --check                  check packages.
    --clean                  clean before compiling.
    --compile                compile packages.
    --configure              configure before compiling.
    --configure-type         type of configuration (default is 'release').
    --directories-create     create package directory structure.
    --disable                explicitly disable this regex of packages in the configuration.
    --dist                   build distribution tarballs.
    --distcheck              check created tarballs.
    --distclean              distclean before compiling.
    --distkeywords           do keyword expansion (be careful with this one).
    --docs                   generate docs during compilation.
    --dry-run                do not execute any command, just report what would be done.
    --enable                 explicitly enable these regex of packages in the configuration.
    --help                   print usage information.
    --help-all               print usage, all packages and all operations.
    --help-operations        print known operations.
    --help-packages          print known packages, in order of build.
    --help-repositories      print known source code repositories.
    --install                install packages.
    --regex-selector         defines a regex to select specific packages.
    --repo-co                checkout or update the workspace source code.
    --repo-pull              pull the repositories from this server (e.g. virtual2.cbi.utsa.edu).
    --repo-serve             start the version control program in server mode to give others access to your code.
                             this will automatically fork processes as needed and return control to the terminal.
    --repo-status            compare workspace with source code repository branch head.
    --repo-sync              sync the repositories with this server (e.g. virtual2.cbi.utsa.edu).
    --tag                    set this tag on all packages.
    --uninstall              uninstall packages, cannot be combined with installation options.
    --upload-server          enable uploading packages to this server (e.g. https://frs.sourceforge.net/uploads).
    --version                give version information.
    --v|verbose              tell what is being done, specify multiple times to get more feedback.
    --website-prepare        prepare the website on your developer machine.
    --website-upload         upload the website to the webserver.

options related to installation on a client machine:
    --download-server        enable downloading packages from this server (e.g. downloads.sourceforge.net).
    --src-tag                use this tag for finding src directories on a client machine.
    --src-dir                use this dir as the base for directories on a client machine.

So on a client machine, for package xxx, the src are found in the
directory <src-dir>/xxx-<src-tag>.  From there the build starts as
usual.


options related to behavior of external applications:
    --environment            fills in the environment, can be given multiple times.
                             e.g. environment NEUROSPACES_HARNESS_OPTION_EMAIL=1 generates emails for tests that fail.

";

	if ($option_help_all)
	{
	    print Dump(
		       {
			all_packages => $all_packages,
			all_operations => $all_operations,
		       },
		      );
	}

	exit 1;
    }

    if ($option_help_operations)
    {
	print
	    "$0:\n  operations in order of build:\n    - "
		. (
		   join
		   "\n    - ",
		   grep
		   {
		       $_ =~ /$option_regex_selector/i
		   }
		   map
		   {
		       $_->{description} || join ' ', @{$_->{operation} || []},
		   }
		   @$all_operations,
		  )
		    . "\n";

	exit 1;
    }

    if ($option_help_packages)
    {
	print
	    "$0:\n  enabled packages in order of build:\n    - "
		. (
		   join
		   "\n    - ",
		   sort
		   {
		       $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
		   }
		   grep
		   {
		       not $all_packages->{$_}->{disabled}
		   }
		   grep
		   {
		       $_ =~ /$option_regex_selector/i
		   }
		   keys %$all_packages
		  )
		    . "\n";

	exit 1;
    }

    if ($option_help_repositories)
    {
	my $repositories
	    = [
	       map
	       {
		   my $package_information = $all_packages->{$_};

		   my $repository_name
		       = $package_information->{version_control}->{repository}
			   || $package_information->{directory} . '/' . 'mtn';

		   {
		       package => $_,
		       repository_name => $repository_name,
		   };
	       }
	       sort
	       {
		   $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
	       }
	       grep
	       {
		   not $all_packages->{$_}->{disabled}
	       }
	       grep
	       {
		   $_ =~ /$option_regex_selector/i
	       }
	       keys %$all_packages
	      ];

	use YAML;

	print Dump( { $0 => { repositories => $repositories, }, }, );
	
	exit 1;
    }

}


sub report_exit
{
    my $exit_code = shift;

    my $description = shift;

    $build_report->{global}->{time_end} = `date`;

    #! I remove the times here, just to ease the regression testing

    if ($ENV{NEUROSPACES_BUILD_TESTING})
    {
	delete $build_report->{global}->{time_end};
	delete $build_report->{global}->{time_start};
    }

    if (defined $description
        && $exit_code eq 3)
    {
	print "*** die: $description\n";
    }

    # yaml out the build report

    if ($option_verbose > 1)
    {
	print Dump($build_report);
    }

#     # if there were errors

#     if ($error_count)
#     {
# 	# exit with failure

# 	$exit_code ||= 1;

# 	print "$0: exit_code $exit_code\n";

# 	exit $exit_code;
#     }

#     # else

#     else
    {
	# exit, possibly success

	exit $exit_code;
    }
}


sub report_message
{
    my $header = shift;

    my $trailer = shift;

    my $message = shift;

    my $lines = [ split '\n', $message, ];

    my $longest = 0;

    map
    {
	($longest < length) && ($longest = length)
    }
	@$lines;

    my $line = '-' x $longest;

    print "\n";
    print "$line\n" for 0 .. $header;
    print "\n";
    print "$message\n\n";
    print "$line\n" for 0 .. $trailer;
    print "\n";
}


sub operation_execute
{
    my $operations = shift;

    my $environment = shift;

    my $arguments = shift;

    my $description = $environment->{description};

    my $keywords = defined $environment->{keywords} ? $environment->{keywords} : 1;

    my $package_name = $environment->{package_name};

    my $reported_arguments = [ @$arguments, ];

    # if keyword expansions

    if ($keywords)
    {
	# get monotone id

	my $monotone_id = `mtn automate get_base_revision_id`;

	chomp $monotone_id;

	# define release labels

	#! copied from release-extract

	my $log = [ `mtn log --last 1`, ];

# 	my $monotone_id
# 	    = [
# 	       map
# 	       {
# 		   s/.*Revision:\s*//;

# 		   s/\s*//g;

# 		   $_;
# 	       }
# 	       grep
# 	       {
# 		   m'Revision:';
# 	       }
# 	       @$log,
# 	      ];

	my $release_label = $option_tag;

	$release_label =~ m/([^-]+)-([^-]+)?(?:-([^-]+))?/;

	my $release_major = $1 || $monotone_id;

	my $release_minor = $2 || 0;

	my $release_micro = $3 || 0;

	$arguments
	    = [
	       map
	       {
		   s/%package/$package_name/g;
		   s/%release_major/$release_major/g;
		   s/%release_micro/$release_micro/g;
		   s/%release_minor/$release_minor/g;
		   s/%version/$monotone_id/g;

		   $_;
	       }
	       @$arguments,
	      ];

	#! to prevent monotone from interpreting the yaml as an option,
	#! we prefix the report with something that does not look like an
	#! option.

	my $report_text = Dump( { build_report => $build_report, }, ) . "\n";

	$reported_arguments
	    = [
	       map
	       {
		   my $argument = $_;

		   $argument =~ s/%report/$report_text/g;

		   # replace non-LDH characters: underscores

		   $argument =~ s/_/-/g;

		   $argument;
	       }
	       @$arguments,
	      ];
    }

    # register that we are about to do this operation for this package

    push @$operations, { description => $description, package_name => $package_name, operations => $reported_arguments, };

    if (!$option_dry_run)
    {
	print "$0: package $package_name [" . (join ' ', @$arguments) . "] executing\n";

	system join " ", @$arguments;

	if ($?)
	{
	    #! assume system has given a good error message

	    die "$0: *** Error: package $package_name: $?";
	}

	if ($option_verbose)
	{
	    print "$0: package $package_name [" . (join ' ', @$arguments ) . "] executed \n";
	}
    }
    else
    {
	if ($option_verbose)
	{
	    print "$0: package $package_name [" . (join ' ', @$arguments ) . "] not executed, dry_run is $option_dry_run\n";
	}
    }
}


sub version
{
    # $Format: "    my $version=\"${package}-${label}\";"$
    my $version="installer-python-5";

    return $version;
}


sub version_control_translate_server
{
    my $server_name = shift;

    # by default, the result is the given name

    my $result = $server_name;

    # loop over all known servers

    foreach my $version_control_server (@$version_control_servers)
    {
	# if the server name matches

	if ($server_name eq $version_control_server->{name})
	{
	    # translate

	    $result = $version_control_server->{address};

	    # break loop

	    last;
	}
    }

    # return result

    return $result;
}


main();


