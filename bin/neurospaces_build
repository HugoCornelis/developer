#!/usr/bin/perl
#!/usr/bin/perl -w -d:ptkdb
#


use strict;


use Getopt::Long;

use YAML;


# options related to operation mode selection:

my $option_client = 0;
my $option_developer = 0;

# operation execution profile: default is configure, compile and install

my $option_certification_report = 0;
my $option_check = 0;
my $option_clean = 0;
my $option_compile = 1;
my $option_configure = 1;
my $option_configure_type = 'release';
my $option_countcode;
my $option_directories_create = 0;
my $option_dist = 0;
my $option_dist_dir = [];
my $option_distcheck = 0;
my $option_distclean = 0;
my $option_distkeywords = 0;
my $option_docs = 0;
my $option_dry_run = 0;
my $option_install = 1;
my $option_installed_versions = 1;
my $option_keep_going;
my $option_regex_selector = ".*";
my $option_repo_ci = 0;
my $option_repo_clone = 0;
my $option_repo_co = 0;
my $option_repo_history = 0;
my $option_repo_history_last = 2;
my $option_repo_init = 0;
my $option_repo_migrate = 0;
my $option_repo_pull = 0;
my $option_repo_push = 0;
my $option_repo_revert = 0;
my $option_repo_serve = 0;
my $option_repo_status = 0;
my $option_repo_sync = 0;
my $option_tag = 0;
my $option_uninstall = 0;
my $option_upload_server;
my $option_upstream_version;
my $option_verbose = 0;
my $option_website_prepare;
my $option_website_upload;


# options for source code and package distribution.
my $option_pkg_deb = 0;
my $option_pkg_deb_dir = 0;
my $option_pkg_rpm = 0;
my $option_pkg_rpm_dir = 0;
my $option_pkg_tar = 0;
my $option_pkg_tar_dir = 0;
my $option_version_major = 0;
my $option_version_minor = 0;
my $option_version_micro = 0;
my $option_version_tag = 0;
my $option_release_tag = 0;

# options related to installation on a client machine

my $option_src_tag;
my $option_src_dir;
my $option_download_server = 0;
my $option_unpack;

# options related to behavior of external applications

my $option_environment = [];


my $all_operations = [];


my $whole_build_configuration;

use YAML;

if (-f '/etc/neurospaces/developer/build.yml')
{
    eval
    {
	$whole_build_configuration = YAML::LoadFile('/etc/neurospaces/developer/build.yml');
    };

    if ($@)
    {
	die "$0: *** Error: reading file /etc/neurospaces/developer/build.yml ($@)";
    }
}


my $all_packages
    = {
       experiment => {
		      directory => "$ENV{HOME}/neurospaces_project/experiment/source/snapshots/0",
		      operations => {
				     './configure' => {
						       debug => [
								 "CFLAGS=-g -O0",
								],
						       release => [
								   "CFLAGS=-g -O9",
								  ],
						      },
				    },
		      order => 1.5,
		      version_control => {
					  port_number => 4703,
					  repository => "$ENV{HOME}/neurospaces_project/MTN/experiment.mtn",
					 },
		     },
       configuration => {
			 dependencies => {
					 },
			 directory => "$ENV{HOME}/neurospaces_project/configuration",
			 disabled => 1,
			 order => 27,
			 version_script => 0,
			},
       dash => {
		dependencies => {
				},
		directory => "$ENV{HOME}/neurospaces_project/dash/source/snapshots/0",
		disabled => 1,
		order => 2,
		version_script => 0,
	       },
       geometry => {
		    dependencies => {
				    },
		    directory => "$ENV{HOME}/neurospaces_project/geometry/source/snapshots/0",
		    disabled => 1,
		    order => 4,
		    version_script => 0,
		   },
       gshell => {
		  dependencies => {
				   'model-container' => 'for storing the model in computer memory',
				   heccer => 'for solving single neurons',
				   ssp => 'to schedule the solvers',
				  },
		  directory => "$ENV{HOME}/neurospaces_project/gshell/source/snapshots/0",
		  order => 13,
		  version_control => {
				      port_number => 4699,
				      repository => "$ENV{HOME}/neurospaces_project/MTN/gshell.mtn",
				     },
		  version_script => 'genesis-g3 --version',
		 },
      'g-tube' => {
		   directory => "$ENV{HOME}/neurospaces_project/g-tube/source/snapshots/0",
		   disabled => 'g-tube is not complete yet',
		   order => 30,
		   version_control => {
				       repository => "$ENV{HOME}/neurospaces_project/g-tube/source/snapshots/0/.hg",
				      },
		   version_script => 0,
		  },
       heccer => {
		  dependencies => {
				   'model-container' => 'for storing the model in computer memory',
				  },
		  directory => "$ENV{HOME}/neurospaces_project/heccer/source/snapshots/0",
		  disabled => 0,
		  operations => {
				 './configure' => {
						   debug => [
							     "CFLAGS=-g -O0",
							    ],
						   release => [
							       "CFLAGS=-g -O9",
							      ],
						  },
				},
		  order => 2,
		  version_control => {
				      port_number => 4694,
				      repository => "$ENV{HOME}/neurospaces_project/MTN/heccer.mtn",
				     },
		 },
       developer => {
		     directory => "$ENV{HOME}/neurospaces_project/developer/source/snapshots/0",
		     disabled => 0, # disabled => 1,
		     order => 0,
		     version_control => {
					 port_number => 4696,
					 repository => "$ENV{HOME}/neurospaces_project/MTN/developer.mtn",
					},
		     version_script => 'neurospaces_build --version',
		    },
       'model-container' => {
			     directory => "$ENV{HOME}/neurospaces_project/model-container/source/snapshots/0",
			     disabled => 0,
			     operations => {
					    './configure' => {
							      debug => [
									"CFLAGS=-g -O0",
								       ],
							      release => [
									  "CFLAGS=-g -O9",
									 ],
							     },
					   },
			     order => 1,
			     version_control => {
						 port_number => 4693,
						 repository => "$ENV{HOME}/neurospaces_project/MTN/model-container.mtn",
						},
			    },
       exchange => {
		    dependencies => {
				     'model-container' => 'for storing the model in computer memory',
				    },
		    directory => "$ENV{HOME}/neurospaces_project/exchange/source/snapshots/0",
		    order => 6.5,
		    version_control => {
					port_number => 4701,
					repository => "$ENV{HOME}/neurospaces_project/MTN/exchange.mtn",
				       },
		    version_script => 'neurospaces_exchange --version',
		   },
       neurospaces_prcs => {
			    directory => "$ENV{HOME}/neurospaces_project/model-container/source/snapshots/prcs.0",
			    disabled => 'obsoleted by the model-container under mtn control rather than prcs',
			    order => 0.5,
			    version_control => {
						commands => {
							     missing => undef,
							     status => [
									'prcs',
									'diff',
									'neurospaces.prj',
									'`prcs 2>/dev/null execute --not ".*\(directory\|symlink\)" neurospaces.prj | grep -v "neurospaces\.prj" | grep -v "purkinjespine" `',
									'--',
									'--unified',
								       ],
							     unknown => undef,
							    },
					       },
			    version_script => 'prcsentry Project-Version',
			   },
       'ns-sli' => {
		    dependencies => {
				     'model-container' => 'for storing the model in computer memory',
				     heccer => 'for solving single neurons',
				    },
		    directory => "$ENV{HOME}/neurospaces_project/ns-sli/source/snapshots/0",
		    order => 6,
		    operations => {
				   './configure' => {
						     debug => [
							       "CFLAGS=-g -O0",
							      ],
						     release => [
								 "CFLAGS=-g -O9",
								],
						    },
				  },
		    version_control => {
					port_number => 4692,
					repository => "$ENV{HOME}/neurospaces_project/MTN/ns-sli.mtn",
				       },
		    version_script => 0,
		   },
       'project-browser' => {
			     dependencies => {
					      'model-container' => 'for storing the model in computer memory',
					      heccer => 'for solving single neurons',
					      ssp => 'to schedule the solvers',
					     },
			     directory => "$ENV{HOME}/neurospaces_project/project-browser/source/snapshots/0",
			     disabled => 1,
			     order => 7,
			     version_control => {
						 port_number => 4697,
						 repository => "$ENV{HOME}/neurospaces_project/MTN/neurospacesweb.mtn",
						},
			     version_script => 'pb-version',
			    },
       publications => {
			directory => "$ENV{HOME}/neurospaces_project/publications/source/snapshots/0",
			disabled => 'Allan\'s experiment working area',
			order => 32,
			version_control => {
					    port_number => 4702,
					    repository => "$ENV{HOME}/neurospaces_project/MTN/publications.mtn",
					   },
			version_script => 0,
		       },
       rtxi => {
		directory => "$ENV{HOME}/neurospaces_project/rtxi/source/snapshots/0",
		disabled => 'slow progress, yet important',
		order => 29,
		version_control => {
				    port_number => 4704,
				    repository => "$ENV{HOME}/neurospaces_project/MTN/rtxi.mtn",
				   },
		version_script => 0,
	       },
       ssp => {
	       dependencies => {
				'model-container' => 'for storing the model in computer memory',
				heccer => 'for solving single neurons',
			       },
	       directory => "$ENV{HOME}/neurospaces_project/ssp/source/snapshots/0",
	       disabled => 0,
	       order => 3,
	       version_control => {
				   port_number => 4695,
				   repository => "$ENV{HOME}/neurospaces_project/MTN/ssp.mtn",
				  },
	      },

       sspy => {
	       dependencies => {
				'model-container' => 'for storing the model in computer memory',
				heccer => 'for solving single neurons',
			       },
	       directory => "$ENV{HOME}/neurospaces_project/sspy/source/snapshots/0",
	       disabled => "Still under development.",
	       order => 3.1,
	       version_control => {
				   port_number => 4705,
				   repository => "$ENV{HOME}/neurospaces_project/MTN/sspy.mtn",
				  },
	      },

       studio => {
		  dependencies => {
				   'model-container' => 'for storing the model in computer memory',
				   heccer => 'for solving single neurons',
				   ssp => 'to schedule the solvers',
				  },
		  directory => "$ENV{HOME}/neurospaces_project/studio/source/snapshots/0",
		  disabled => 0,
		  order => 5,
		  version_control => {
				      port_number => 4698,
				      repository => "$ENV{HOME}/neurospaces_project/MTN/studio.mtn",
				     },
		  version_script => 'neurospaces --version',
		 },
       system => {
		  directory => "$ENV{HOME}/neurospaces_project/.",
		  disabled => 1,
		  order => 129,
		  version_script => 0,
		 },
       userdocs => {
		    directory => "$ENV{HOME}/neurospaces_project/userdocs/source/snapshots/0",
		    disabled => 0,
		    order => 31,
		    version_control => {
					port_number => 4700,
					repository => "$ENV{HOME}/neurospaces_project/MTN/userdocs.mtn",
				       },
		    version_script => 0,
		   },
      };


my $version_control_servers
    = [
       {
	name => 'default',
	address => 'repo-genesis3.cbi.utsa.edu',
       },
       {
	name => 'default2',
	address => 'repo.cbi.utsa.edu',
       },
       {
	name => 'backup_server',
	address => '84.193.227.151',
       },
       {
	name => 'mercurial_server',
	address => 'http://repo-genesis3.cbi.utsa.edu/hg/',
       },
      ];


my $build_report
    = {
       description => {
		       command => $0,
		       name => "Build report",
		      },
       global => {
# 		  config => $config,
# 		  error_count => $error_count,
		  status => 'initializing',
		  test_count => 0,
		  time_start => `date`,
		 },
       client => {
		  OS => $^O,
		 },
      };


$SIG{'__DIE__'}
    = sub
      {
	  use Carp;

	  print STDERR Carp::longmess(@_);

	  $build_report->{global}->{status} = 'Died: ' . join " ", @_;

	  report_exit(3, @_);
      };


$SIG{'INT'}
    = sub
      {
	  $build_report->{global}->{status} = 'Interrupted';

	  report_exit(2);
      };


#
# daemonize()
#
# Daemonize the running process by setting a session id, optionally close
# shared resources between child and parent (files), and print a diagnostic
# message on STDOUT.  '$pid' is replaced with the child process id in the
# diagnostic message.
#
# returns the created process id if $options->{return} is set, otherwise
# exits.
#

sub daemonize
{
    my $close_files = shift;

    my $options = shift;

    my $message = $options->{message} || '';

    my $pid;

#     mlog("daemonize ($$)", "forking");

    if ($pid = fork())
    {
# 	mlog("daemonize ($$)", "forked");

        # parent : print optional message and exit or return

	if ($message)
	{
	    $message =~ s/\$pid/$pid/g;

	    print($message);
	}

	if ($options->{return})
	{
# 	    mlog("daemonize ($$)", "forked : return");

	    return $pid;
	}
	else
	{
# 	    mlog("daemonize ($$)", "forked : exit");

	    exit(0);
	}
    }

    # child : create session, optionally close shared resources.

    # set default result

    my $result = 1;

#     mlog("daemonize ($$)", "forked : cd");

    use POSIX;

    POSIX::setsid();
    chdir('/');

    if ($close_files)
    {
# 	mlog("daemonize ($$)", "closing files");

	# unlock shared resources : close all file descriptors.

	use FileHandle;

	my $closed = FileHandle->new(">/tmp/closed.txt");

	my $files = POSIX::sysconf(POSIX::_SC_OPEN_MAX);

	if ($closed)
	{
	    print $closed "Closing $files file handles.\n";
	}

	if ($close_files > 0)
	{
	    $files = $close_files;
	}

	while ($files > -1)
	{
	    my $result = "not done";

	    if (!defined $closed || $closed->fileno() != $files)
	    {
		$result = POSIX::close($files) || -1;
	    }

	    if (defined $closed)
	    {
		print $closed "Closed file handle $files : $result\n";
	    }

	    $files--;
	}

	$closed->close();
    }

#     mlog("daemonize ($$)", "done");

    return $result;
}


sub main
{
    read_cmd_line();

    # set status: running

    $build_report->{global}->{status} = 'Running';

    # execute all operations

    all_operations_execute();

    # finish

    $build_report->{global}->{status} = 'Finished';

    report_exit(0);
}


sub all_operations_execute
{
    # initialize operations related matters

    $build_report->{operations} = [];

    my $operations = $build_report->{operations};

    # loop over all packages, in dependency order

    foreach my $package_name (sort
			      {
				  $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
			      }
			      keys %$all_packages)
    {
	if ($option_verbose)
	{
	    print "$0: examining package $package_name\n";
	}

	my $package = $all_packages->{$package_name};

	if ($package->{disabled})
	{
	    if ($option_verbose)
	    {
		print "$0: package $package_name skipped, disabled is $package->{disabled}\n";
	    }

	    next;
	}

	if ($package_name !~ /$option_regex_selector/i)
	{
	    if ($option_verbose)
	    {
		print "$0: package $package_name skipped, not selected using --regex-selector\n";
	    }

	    next;
	}

	# loop over all installation operations

	foreach my $all_operation (@$all_operations)
	{
	    my $condition_value = $all_operation->{condition};

	    my $operation = $all_operation->{operation};

	    my $description = $all_operation->{description} || (join ' ', @$operation );

	    # if the uninstall option is given

	    if ($option_uninstall)
	    {
		# but this operation is not uninstall

		if (ref $operation eq 'ARRAY'
		    && exists $operation->[5]
		    && $operation->[5] ne 'uninstall')
		{
		    # don't execute, doesnot make sense

		    $condition_value = 0;

		    if ($option_verbose > 1)
		    {
			print "$0: package $package_name [" . $description . "] condition turned to false \n";
		    }

		}
	    }

	    # if the operation's condition is true

	    if ($condition_value)
	    {
		if ($option_verbose > 1)
		{
		    print "$0: package $package_name [" . $description . "] preparing to execute \n";
		}

		# construct package directory

		my $target_directory = $package->{directory};

		# if we are working on a client machine

		if ($option_client)
		{
		    if (!defined $option_src_dir
			|| !defined $option_src_tag)
		    {
			die "$0: *** Error: you must set option_src_dir and option_src_tag when working in client mode";
		    }

		    # construct a target directory from the src-* options

		    $target_directory = $option_src_dir . "/" . $package_name . "-" . $option_src_tag;
		}

		# if this is perl code

		if (ref $operation eq 'CODE')
		{
		    # register that we are about to do this operation for this package

		    push @$operations, { package_name => $package_name, operations => $operation, };

		    if (!$option_dry_run)
		    {
			my $directory = $option_src_dir ? $option_src_dir : $target_directory;

			my $filename = $package_name . "-" . (defined $option_src_tag ? $option_src_tag : '') . ".tar.gz";

			my $prefix = $option_download_server =~ m|://| ? '' : 'http://';

			my $url = $prefix . $option_download_server . "/neurospaces/" . $filename;

			my $result
			    = &$operation
				(
				 {
				  description => $description,
				  directory => $directory,
				  ( $option_src_tag ? (filename => $filename,) : (), ),
				  operations => $operations,
				  package => $package,
				  package_name => $package_name,
				  url => $url,
				 },
				);
		    }
		    else
		    {
			if ($option_verbose)
			{
			    # embedded perl code

			    use Data::Dumper;

			    local $Data::Dumper::Deparse = 1;

			    my $perl_code = Dumper($operation);

			    print "$0: package $package_name [" . (join ' ', $perl_code ) . "] not executed, dry_run is $option_dry_run\n";
			}
		    }
		}

		# if the operation is not perl code

		else
		{
		    # if package directory exists

		    if (-e $target_directory)
		    {
			# go to package directory

			use Cwd;

			my $current_directory = getcwd();

			if ($option_verbose > 1)
			{
			    print "$0: package $package_name, chdir from ($current_directory) to ($target_directory)\n";
			}

			my $success = chdir $target_directory;

			if (!$success)
			{
			    die "$0: *** Error: package $package_name cannot change from directory ($current_directory) to directory ($target_directory): $!";
			}

			# add options specific to this operation and package

			#! so here the model container gets configured with --delete-operation

			#t also need separation between debug and release overhere

			my $package_options = [];

			push
			    @$package_options,
				@{$package->{$operation->[0]} || []};

			# make difference between options specific for release and debug builds

			if ($package->{operations}->{$operation->[0]})
			{
			    # construct variable name for type of build: remove things like './' from configure lines

			    my $text = $operation->[0];

			    $text =~ s(\.)()g;
			    $text =~ s(/)()g;

			    $text = "\$option_" . $text . "_type";

			    # get the build type from the options

			    my $type = eval $text;

			    if ($@)
			    {
				die $@;
			    }

			    # construct options for this operation

			    my $build_type_options = $package->{operations}->{$operation->[0]}->{$type};

			    push
				@$package_options,
				    @$build_type_options;
			}

			# perform the operation on the package

			operation_execute
			    (
			     $operations,
			     {
			      description => $description,
			      keywords => $option_developer,
			      package_name => $package_name,
			     },
			     [
			      @$operation,
			      @$package_options,
			     ],
			    );

			if ($option_verbose > 1)
			{
			    print "$0: package $package_name, chdir from ($target_directory) to ($current_directory)\n";
			}

			$success = chdir $current_directory;

			if (!$success)
			{
			    die "$0: *** Error: package $package_name, cannot change from directory ($target_directory) to directory ($current_directory): $!";
			}
		    }
		    else
		    {
			if ($option_verbose)
			{
			    print "$0: package $package_name skipped, [" . $description . "], directory ($target_directory) not found, assuming this package source is not installed\n";
			}
		    }
		}
	    }
	    else
	    {
		if ($option_verbose > 1)
		{
		    print "$0: package $package_name [" . $description . "] skipped, condition_value is $condition_value\n";
		}
	    }
	}
    }
}


#
# sub($make_target)
#
# subroutine parses the version and release tags and
# returns them in an array for executing via operation_execute.
# The argument for the make target is use to ensure that the
# code can be used for packaging tars, rpms and debs.
sub parse_release_tags
{

  my $make_target = shift;
  my $major;
  my $minor;
  my $micro;
  my $label;
  my $email;

  my $command;
  
  push(@$command, 'release-expand');

  if($option_version_tag)
  {
      my @ver = split(/\./,$option_version_tag);
      
      $major = $ver[0];
      $minor = $ver[1];
      
      push(@$command, '--major');
      push(@$command, $major);
      push(@$command, '--minor');
      push(@$command, $minor);

      if($#ver == 2)
      {
	$micro = $ver[2];

	push(@$command, '--micro');
	push(@$command, $micro);

      }

  }
  else
  {

    if($option_version_major)
    {
      push(@$command, '--major');
      push(@$command, $option_version_major);
    }

    if($option_version_minor)
    {
      push(@$command, '--minor');
      push(@$command, $option_version_minor);
    }

    if($option_version_micro)
    {
      push(@$command, '--micro');
      push(@$command, $option_version_micro);
    }

  }

  if($option_release_tag)
  {
    push(@$command, '--label');
    push(@$command, $option_release_tag);
  }

  push(@$command, '&&');
  push(@$command, 'make');
  push(@$command, $make_target);
  
  return $command;
}

sub read_cmd_line
{
    my $option_disable;
    my $option_enable;
    my $option_help = 0;
    my $option_help_all = 0;
    my $option_help_operations = 0;
    my $option_help_packages = 0;
    my $option_help_repositories;
    my $option_version;

    my $result
	= GetOptions(
		     # options related to operation mode selection:

		     "client!" => \$option_client,
		     "developer!" => \$option_developer,

		     # operation execution profile: default is configure, compile and install

		     "certification-report!" => \$option_certification_report,
		     "check!" => \$option_check,
		     "clean!" => \$option_clean,
		     "compile!" => \$option_compile,
		     "configure!" => \$option_configure,
		     "configure-type=s" => \$option_configure_type,
		     "countcode=s" => \$option_countcode,
		     "directories-create!" => \$option_directories_create,
		     "disable=s" => \$option_disable,
		     "dist!" => \$option_dist,
		     "distcheck!" => \$option_distcheck,
		     "distclean!" => \$option_distclean,
		     "dist-dir=s" => $option_dist_dir,
		     "distkeywords!" => \$option_distkeywords,
		     "docs!" => \$option_docs,
		     "dry-run!" => \$option_dry_run,
		     "enable=s" => \$option_enable,
		     "help!" => \$option_help,
		     "help-all!" => \$option_help_all,
		     "help-operations!" => \$option_help_operations,
		     "help-packages!" => \$option_help_packages,
		     "help-repositories!" => \$option_help_repositories,
		     "install!" => \$option_install,
		     "installed-versions!" => \$option_installed_versions,
		     "keep-going!" => \$option_keep_going,
		     "pkg-deb" => \$option_pkg_deb,
		     "pkg-deb-dir=s" => \$option_pkg_deb_dir,
		     "pkg-rpm" => \$option_pkg_rpm,
		     "pkg-rpm-dir=s" => \$option_pkg_rpm_dir,
		     "pkg-tar" => \$option_pkg_tar,
		     "pkg-tar-dir=s" => \$option_pkg_tar_dir,
		     "regex-selector=s" => \$option_regex_selector,
		     "release-tag=s" => \$option_release_tag,
		     "repo-ci=s" => \$option_repo_ci,
		     "repo-clone=s" => \$option_repo_clone,
		     "repo-co!" => \$option_repo_co,
		     "repo-init!" => \$option_repo_init,
		     "repo-migrate!" => \$option_repo_migrate,
		     "repo-history!" => \$option_repo_history,
		     "repo-history-last=i" => \$option_repo_history_last,
		     "repo-pull=s" => \$option_repo_pull,
		     "repo-push=s" => \$option_repo_push,
		     "repo-revert!" => \$option_repo_revert,
		     "repo-serve!" => \$option_repo_serve,
		     "repo-status!" => \$option_repo_status,
		     "repo-sync=s" => \$option_repo_sync,
		     "tag=s" => \$option_tag,
		     "uninstall!" => \$option_uninstall,
		     "upload-server=s" => \$option_upload_server,
		     "upstream-version=s" => \$option_upstream_version,
		     "verbose+" => \$option_verbose,
		     "version" => \$option_version,
		     "version-tag=s" => \$option_version_tag,
		     "website-prepare!" => \$option_website_prepare,
		     "website-upload!" => \$option_website_upload,

		     # options related to installation on a client machine

		     "download-server=s" => \$option_download_server,
		     "src-tag=s" => \$option_src_tag,
		     "src-dir=s" => \$option_src_dir,
		     "unpack!" => \$option_unpack,

		     # options related to behavior of external applications

		     "environment=s" => $option_environment,
		    );

    if (!$result)
    {
	die "$0: *** Error: Error in option processing";
    }

    # process operation mode options

    #! we give client mode precedence over developer mode

    if (!$option_client
	&& !$option_developer)
    {
	$option_client = 1;
    }

    if ($option_client)
    {
	$option_developer = 0;
    }

    if ($option_developer)
    {
	$option_client = 0;
    }

    # fill in the build report

    $build_report->{options}
	= {
	   # options related to operation mode selection:

	   "client!" => $option_client,
	   "developer!" => $option_developer,

	   # operation execution profile: default is configure, compile and install

	   "certification-report!" => $option_certification_report,
	   "check!" => $option_check,
	   "clean!" => $option_clean,
	   "compile!" => $option_compile,
	   "configure!" => $option_configure,
	   "configure-type=s" => $option_configure_type,
	   "countcode=s" => $option_countcode,
	   "directories-create!" => $option_directories_create,
	   "disable=s" => $option_disable,
	   "dist!" => $option_dist,
	   "distcheck!" => $option_distcheck,
	   "distclean!" => $option_distclean,
	   "dist-dir=s" => $option_dist_dir,
	   "distkeywords!" => $option_distkeywords,
	   "docs!" => $option_docs,
	   "dry-run!" => $option_dry_run,
	   "enable=s" => $option_enable,
	   "help!" => $option_help,
	   "help-all!" => $option_help_all,
	   "help-operations!" => $option_help_operations,
	   "help-packages!" => $option_help_packages,
	   "help-repositories!" => $option_help_repositories,
	   "install!" => $option_install,
	   "installed-versions!" => $option_installed_versions,
	   "keep-going!" => $option_keep_going,
	   "pkg-deb!" => $option_pkg_deb,
	   "pkg-deb-dir=s" => $option_pkg_deb_dir,
	   "pkg-rpm!" => $option_pkg_rpm,
	   "pkg-rpm-dir=s" => $option_pkg_rpm_dir,
	   "pkg-tar!" => $option_pkg_tar,
	   "pkg-tar-dir=s" => $option_pkg_tar_dir,
	   "regex-selector=s" => $option_regex_selector,
	   "release-tag=s" => $option_release_tag,
	   "repo-ci=s" => $option_repo_ci,
	   "repo-clone=s" => $option_repo_clone,
	   "repo-co!" => $option_repo_co,
	   "repo-init!" => $option_repo_init,
	   "repo-migrate!" => $option_repo_migrate,
	   "repo-history!" => $option_repo_history,
	   "repo-history-last=i" => $option_repo_history_last,
	   "repo-pull=s" => $option_repo_pull,
	   "repo-push=s" => $option_repo_push,
	   "repo-revert!" => $option_repo_revert,
	   "repo-serve!" => $option_repo_serve,
	   "repo-status!" => $option_repo_status,
	   "repo-sync=s" => $option_repo_sync,
	   "tag=s" => $option_tag,
	   "uninstall!" => $option_uninstall,
	   "upload-server=s" => $option_upload_server,
	   "upstream-version=s" => $option_upstream_version,
	   "verbose+" => $option_verbose,
	   "version" => $option_version,
	   "version=s" => $option_version_tag,
	   "website-prepare!" => $option_website_prepare,
	   "website-upload!" => $option_website_upload,

	   # options related to installation on a client machine

	   "download-server=s" => $option_download_server,
	   "src-tag=s" => $option_src_tag,
	   "src-dir=s" => $option_src_dir,
	   "unpack!" => $option_unpack,

	   # options related to behavior of external applications

	   "environment=s" => $option_environment,
	  };

    if ($option_version)
    {
	my $version = version();

	print $version . "\n";

	exit 1;
    }

    # process enable and disable options overhere, such that there
    # effect is mirrored in the help output

    if ($option_enable)
    {
	# loop over all packages, in dependency order

	foreach my $package_name (sort
				  {
				      $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
				  }
				  keys %$all_packages)
	{
	    # if should be enabled

	    if ($package_name =~ /$option_enable/)
	    {
		# enable but don't overwrite existing value

		my $package = $all_packages->{$package_name};

		if ($package->{disabled})
		{
		    $package->{disabled} = 0;
		}
	    }
	}
    }

    if ($option_disable)
    {
	# loop over all packages, in dependency order

	foreach my $package_name (sort
				  {
				      $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
				  }
				  keys %$all_packages)
	{
	    # if should be disabled

	    if ($package_name =~ /$option_disable/)
	    {
		# disable but don't overwrite existing value

		my $package = $all_packages->{$package_name};

		if (!$package->{disabled})
		{
		    $package->{disabled} = $option_disable;
		}
	    }
	}
    }

    my $tag_set_in_tag_database = 0;

    my $monotone_version = monotone_version();

    # merge operations with options that affect the execution of the
    # operations

    $all_operations
	= [
	   {
	    condition => $option_repo_init,
	    description => 'initializing repository',
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		#t where does this default value come from?  Cannot work correctly?

		my $repository_name
		    = $package_information->{package}->{version_control}->{repository}
			|| $directory . '/' . $package_name . '/' . 'mtn';

		#
		# Check to see if the repository name ends with .mtn, if not we assume it ends
		# in .hg, in which case we don't need the port number since mercurial serves over http.
		#

		if ($repository_name =~ m/^.*\.mtn$/)
		{
		  # initialize the repository if necessary

		  operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'test', '-f', $repository_name, '||', 'mtn', '--db', $repository_name, 'db', 'init',
		     ],
		    );
		}
		else
		{
		    my $repo_server = version_control_translate_server('default');

		    # MERCURIAL init

		    # operations:
		    #   initialize the repo:
		    #      hg init http://repo-genesis3.cbi.utsa.edu/hg/g-tube ${HOME}/neurospaces_project/g-tube/source/snapshots/0/
		    # performs a clone of a repository if the project workspace isn't present.

		    operation_execute
			(
			 $operations,
			 {
			  description => $description,

			  #t always zero here, but I guess this simply depends on working in client mode ?

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'hg', 'clone', "http://$repo_server/hg/$package_name", $directory,
			 ],
			);
		}
	    },
	   },

	   {
	    condition => $option_repo_migrate,
	    description => 'migrating monotone repositories to latest schema',
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		#t where does this default value come from?  Cannot work correctly?

		my $repository_name
		    = $package_information->{package}->{version_control}->{repository}
			|| $directory . '/' . $package_name . '/' . 'mtn';

		#
		# Check to see if the repository name ends with .mtn, if not we assume it ends
		# in .hg, in which case we don't need the port number since mercurial serves over http.
		#

		if ($repository_name =~ m/^.*\.mtn$/)
		{
		  # initialize the repository if necessary

		  operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'test', '-f', $repository_name, '&&', 'mtn', '--db', $repository_name, 'db', 'migrate',
		     ],
		    );
		}
		
	    },
	   },
	   {
	    condition => $option_repo_serve,
	    description => 'serving source code repositories',
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		#t where does this default value come from?  Cannot work correctly?

		my $repository_name
		    = $package_information->{package}->{version_control}->{repository}
			|| $directory . '/' . $package_name . '/' . 'mtn';

		my $port_number = $package_information->{package}->{version_control}->{port_number};

		# if not enough information for serving

		if (not -f $repository_name and not -d $repository_name)
		{
		    die "$0: *** Error: cannot serve repository, repository_name not set";
		}

		if (not $port_number and $repository_name =~ m/^.*\.mtn$/)
		{
		    die "$0: *** Error: cannot serve repository, port_number not set";
		}

# 		# translate well krnown names to a routable address

# 		my $repo_server = version_control_translate_server($option_repo_serve);

		# initialize the repository if necessary

		#t MONOTONE

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'test', '-f', $repository_name, '||', 'mtn', '--db', $repository_name, 'db', 'init',
		     ],
		    );

		# detach

		my $pid
		    = daemonize
			(1,
			 {
			  message => "$0: daemonizing for $description, $package_name\n",
			  return => 1,
			 },
			);

		if ($pid ne 1)
		{
		    # serve the repository

		    # MERCURIAL serve
		    # command: hg serve
		    # Very different from monotone, uses a simple http gateway to serve the repository
		    # and provides a web interface for browsing the code. You can still designate a port
		    # like in monotone. The mercurial repository uses a different method for serving
		    # the repos.

		    #t MONOTONE

		    operation_execute
			(
			 $operations,
			 {
			  description => $description,

			  #t always zero here, but I guess this simply depends on working in client mode ?

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  # 		      'mtn', '--db', $repository_name, 'serve', "$repo_server:$port_number",
			  'mtn', '--db', $repository_name, 'serve', "--bind=0.0.0.0:$port_number",
			 ],
			);

		    # never return

		    exit 1;
		}
	    },
	   },
	   {
	    condition => $option_directories_create,
	    description => "creating directory",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		# create directory

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'mkdir', '-p', $directory,
		     ],
		    );
	    },
	   },
	   {
	    condition => $option_repo_pull,
	    description => "pulling repository",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		#t where does this default value come from?  Cannot work correctly?

		my $repository_name
		    = $package_information->{package}->{version_control}->{repository}
			|| $directory . '/' . $package_name . '/' . 'mtn';

		my $repo_server = version_control_translate_server($option_repo_pull);

		#
		# Check to see if the repository name ends with .mtn, if not we assume it ends
		# in .hg, in which case we don't need the port number since mercurial serves over http.
		#

		if ($repository_name =~ m/^.*\.mtn$/)
		{
		    # initialize the repository if necessary

		    my $port_number = $package_information->{package}->{version_control}->{port_number};

		    # create repository directory

		    my $repository_directory = $repository_name;

		    $repository_directory =~ s((.*)/.*)($1);

		    operation_execute
			(
			 $operations,
			 {
			  description => "$description (creating repository directory)",

			  #t always zero here, but I guess this simply depends on working in client mode ?

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'mkdir', '-p', $repository_directory,
			 ],
			);

		    operation_execute
			(
			 $operations,
			 {
			  description => "$description: (initializing the repository)",

			  #t always zero here, but I guess this simply depends on working in client mode ?

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'test', '-f', $repository_name, '||', 'mtn', '--db', $repository_name, 'db', 'init',
			 ],
			);

		    # if not enough information for pulling

		    if (not -f $repository_name)
		    {
			die "$0: *** Error: cannot pull repository, repository_name not set";
		    }

		    if (not $port_number and $repository_name =~ m/^.*\.mtn$/)
		    {
			die "$0: *** Error: cannot pull repository, port_number not set";
		    }

		    # translate well known names to a routable address

		    # pull the repository

		    operation_execute
			(
			 $operations,
			 {
			  description => $description,

			  #t always zero here, but I guess this simply depends on working in client mode ?

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'mtn', '--db', $repository_name, 'pull', '--ticker=count', "$repo_server:$port_number", '"*"',
			 ],
			);

	      }
	      else
	      {
		  # MERCURIAL PULL

		  # hg pull http://repo-genesis3.cbi.utsa.edu/hg/g-tube
		  # hg pull http://$repo_server/hg/$package_name

		  # change the directory

		  if (not chdir $directory)
		  {
		      die "$0: *** Error: cannot change to directory $directory";
		  }

		  operation_execute
		      (
		       $operations,
		       {
			description => $description,
			keywords => 0,
			package_name => $package_name,
		       },
		       [
			'hg', 'pull',
		       ],
		      );
	      }
	    },
	   },
	   {
	    condition => $option_repo_push,
	    description => "pushing repository",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		#t where does this default value come from?  Cannot work correctly?

		my $repository_name
		    = $package_information->{package}->{version_control}->{repository}
			|| $directory . '/' . $package_name . '/' . 'mtn';

		my $port_number = $package_information->{package}->{version_control}->{port_number};

		# create repository directory

		my $repository_directory = $repository_name;

		$repository_directory =~ s((.*)/.*)($1);

		operation_execute
		    (
		     $operations,
		     {
		      description => "$description (creating repository directory)",

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'mkdir', '-p', $repository_directory,
		     ],
		    );

		# initialize the repository if necessary

		#t MONOTONE

		operation_execute
		    (
		     $operations,
		     {
		      description => "$description: (initializing the repository)",

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'test', '-f', $repository_name, '||', 'mtn', '--db', $repository_name, 'db', 'init',
		     ],
		    );

		# if not enough information for pushing

		if (not -f $repository_name and not -d $repository_name)
		{
		    die "$0: *** Error: cannot push repository, repository_name not set";
		}

		if (not $port_number and $repository_name =~ m/^.*\.mtn$/)
		{
		    die "$0: *** Error: cannot push repository, port_number not set";
		}

		# translate well known names to a routable address

		my $repo_server = version_control_translate_server($option_repo_push);

		# push the repository

		#t MONOTONE

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'mtn', '--db', $repository_name, 'push', '--ticker=count', "$repo_server:$port_number", '"*"',
		     ],
		    );

		# MERCURIAL 
		# hg push http://repo-genesis3.cbi.utsa.edu/hg/gui

	    },
	   },
	   {
	    condition => (0 and $option_repo_clone),
	    description => "checkout or update the workspace source code from a remote repository",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		#t where does this default value come from?  Cannot work correctly?

		my $repository_name
		    = $package_information->{package}->{version_control}->{repository}
			|| $directory . '/' . $package_name . '/' . 'mtn';

		my $port_number = $package_information->{package}->{version_control}->{port_number};

		# if not enough information for clone

		if (not -f $repository_name and not -d $repository_name)
		{
		    die "$0: *** Error: cannot clone from repository, repository_name not set";
		}

		if (not $port_number and $repository_name =~ m/^.*\.mtn$/)
		{
		    die "$0: *** Error: cannot clone from repository, port_number not set";
		}

		# change the directory

		if (not chdir $directory)
		{
		    die "$0: *** Error: cannot change to directory $directory";
		}

		#
		# Check to see if the repository name ends with .mtn, if not we assume it ends
		# in .hg, in which case we don't need the port number since mercurial serves over http.
		#

		if ($repository_name =~ m/^.*\.mtn$/)
		{
		    # initialize the repository if necessary

		    #t MONOTONE

		    my $port_number = $package_information->{package}->{version_control}->{port_number};

		    # create repository directory

		    my $repository_directory = $repository_name;

		    $repository_directory =~ s((.*)/.*)($1);

		    # translate well known names to a routable address

		    my $repo_server = version_control_translate_server($option_repo_clone);

		    # clone the source code in the remote repository

		    #t MONOTONE

		    operation_execute
			(
			 $operations,
			 {
			  description => $description,

			  #t always zero here, but I guess this simply depends on working in client mode ?

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'mtn', '--db', $repository_name, 'clone', "$repo_server:$port_number", '--branch', '0',
			 ],
			);

		}
		else
		{

		    # MERCURIAL REMOTE CHECKOUT

		    #t Mando?
		}
	    },
	   },
	   {
	    condition => $option_repo_co,
	    description => "checkout or update the workspace source code from a local repository",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		#t where does this default value come from?  Cannot work correctly?

		my $repository_name
		    = $package_information->{package}->{version_control}->{repository}
			|| $directory . '/' . $package_name . '/' . 'mtn';

		my $port_number = $package_information->{package}->{version_control}->{port_number};

		# if not enough information for checkout

		if (not -f $repository_name and not -d $repository_name)
		{
		    die "$0: *** Error: cannot checkout from repository, repository_name not set";
		}

		#t port number commented out, impedes the automated
		#t addition of new software components

# 		if (not $port_number and $repository_name =~ m/^.*\.mtn$/)
# 		{
# 		    die "$0: *** Error: cannot checkout from repository, port_number not set";
# 		}

		# change the directory

		if (not chdir $directory)
		{
		    die "$0: *** Error: cannot change to directory $directory";
		}

		# merge code

		if ($repository_name =~ m/^.*\.mtn$/)
		{
		    # if allowed by the configuration, default is yes

		    if (not $whole_build_configuration->{no_automated_merges})
		    {
			operation_execute
			    (
			     $operations,
			     {
			      description => $description,

			      #t always zero here, but I guess this simply depends on working in client mode ?

			      keywords => 0,
			      package_name => $package_name,
			     },
			     [
			      'mtn', '--db', $repository_name, '--branch', '0', 'merge',
			     ],
			    );
		    }

		    # checkout code

		    operation_execute
			(
			 $operations,
			 {
			  description => $description,

			  #t always zero here, but I guess this simply depends on working in client mode ?

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'test', '-d', '_MTN',
			  '||', 'mtn', '--db', $repository_name, '--branch', '0', 'co', '.',
			 ],
			);

		    # update code

		    my @update_args;

		    my $upstream_version_options = [ '--branch', '0', ];

		    if ($option_upstream_version)
		    {
			$upstream_version_options = [ split /\s/, $option_upstream_version, ];
		    }

		    if ($monotone_version >= 0.45)
		    {
			@update_args = [
					'/bin/echo', '-n', 'from', 'base_revision_id', ' ',
					'&&', 'mtn', 'automate', 'get_base_revision_id',
					'&&', 'mtn', '--db', $repository_name, @$upstream_version_options, 'update','--move-conflicting-paths',
					'&&', '/bin/echo', '-n', 'to', 'base_revision_id', ' ',
					'&&', 'mtn', 'automate', 'get_base_revision_id',
				       ];
		    }
		    else
		    {
			@update_args = [
					'/bin/echo', '-n', 'from', 'base_revision_id', ' ',
					'&&', 'mtn', 'automate', 'get_base_revision_id',
					'&&', 'mtn', '--db', $repository_name, @$upstream_version_options, 'update',
					'&&', '/bin/echo', '-n', 'to', 'base_revision_id', ' ',
					'&&', 'mtn', 'automate', 'get_base_revision_id',
				       ];
		    }

		    operation_execute
			(
			 $operations,
			 {
			  description => $description,

			  #t always zero here, but I guess this simply depends on working in client mode ?

			  keywords => 0,
			  package_name => $package_name,
			 },
			 @update_args,
			);

		}
		else
		{
		    # MERCURIAL merge
		    # command: hg merge

		    #t check first for outstanding changes in the workspace
		    #t   if found, die
		    #t
		    #t then hg merge (as below, puts the result in the workspace)
		    #t
		    #t automated hg commit (with -C option for checkin comment?)
		    #t
		    #t then contineu with test -d .hg

		    # change the directory

		    if (not chdir $directory)
		    {
			die "$0: *** Error: cannot change to directory $directory";
		    }

		    # note: mercurial aborts if there is nothing to merge

		    operation_execute
			(
			 $operations,
			 {
			  description => $description,

			  #t always zero here, but I guess this simply depends on working in client mode ?

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'hg', 'merge', '||', 'true',
			 ],
			);

		    # checkout code

		    operation_execute
			(
			 $operations,
			 {
			  description => $description,

			  #t always zero here, but I guess this simply depends on working in client mode ?

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'test', '-d', '.hg',
			  '||', 'hg', 'checkout', '-r', '0',
			 ],
			);

		    # update code

		    # MERCURIAL update checkout
		    # these two are actually aliased to each other because of how it pulls a workspace.
		    # You simply update to a particular revision number.
		    # hg update [-r revision]

		    operation_execute
			(
			 $operations,
			 {
			  description => $description,

			  #t always zero here, but I guess this simply depends on working in client mode ?

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'hg', 'update',
			 ],
			);

		}

	    },
	   },
	   {
	    condition => $option_distclean && !$option_uninstall,
	    operation => [ 'make', 'distclean', ],
	   },
	   {
	    condition => $option_distkeywords,
	    operation => [
			  #! after keyword expansion, regenerate the
			  #! autotool related files that perhaps are
			  #! checked in.

			  ( 'make', 'dist-keywords', ),
			  ( '&&', 'make', 'clean', ),
			  ( '&&', 'make', 'clean', ),
			 ],
	   },
	   {
	    condition => $option_tag,
	    operation => [
			  #t MONOTONE

			  # MERCURIAL 
			  # hg status
			  # this shows all changed or missing files in the repository. 
			  # doesn't have any exact equivalen to monotones missing or unknown commands.
			  # status essentially does all of it.
			  ( "test", "!", '"`mtn ls unknown && mtn ls missing && mtn ls changed`"', ),
			  ( '&&', 'release-expand', "--package", "'%package'", "--major", "'%release_major'", 
			    "--minor", "'%release_minor'", "--micro", "'%release_micro'", "--label", 
			    "'%release_major-%release_minor'", "--email",'hugo.cornelis@gmail.com', '--verbose', ),

			  #! after keyword expansion, regenerate the
			  #! autotool related files that perhaps are
			  #! checked in.

			  ( '&&', 'make', 'clean', ),
			  ( '&&', 'make', 'clean', ),
# 			  ( "&&", 'mtn', 'ci', "-m", "'1. Keywords only: $option_tag\n'", ),
			  ( "&&", "test", "!", '"`mtn ls unknown && mtn ls missing`"', ),
			 ],

	   },
	   {
	    condition => $option_tag,
	    operation => [
			  #t MONOTONE

			  #! in a separate operation such that we have the correct %version
			  #! gets replaced by `mtn automate get_base_revision_id`
			  #! during build variable substitution in sub operation_execute()

			  ( 'mtn', 'tag', '\'%version\'', "'$option_tag'", ),
			 ],

                         # MERCURIAL
                         # hg tag -m '\'%version\'' $option_tag
                         # needs to be noted that in mercurial a tag is just an alias for
                         # branch so this may not be what we need here. The arbitrary metadata
                         # system described earlier is probably more in line with what monotone
                         # uses as tags.

	   },
	   {
	    condition => $option_tag,
	    description => "putting the tag in the tag database",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $filename = $package_information->{filename};

		my $package_name = $package_information->{package_name};

		my $url = $package_information->{url};

		# if the tag has already been added for this run

		if ($tag_set_in_tag_database)
		{
		    # return

		    return;
		}

		use YAML;

		my $tag_database_filename = '/etc/neurospaces/tag_database.yml';

		my $tag_database = YAML::LoadFile($tag_database_filename);

		if (!$tag_database)
		{
		    die "$0: *** Error: cannot read $tag_database_filename";
		}

		if ($option_verbose > 1)
		{
		    print "$0: package $package_name [$description ($option_tag)] executing\n";
		}

		my $tags = $tag_database->{tags};

		push
		    @$tags,
		    {
		     'date' => `date`,
		     'regex-selector' => $option_regex_selector,
		     'label' => $option_tag,
		    };

		YAML::DumpFile($tag_database_filename, $tag_database);

		# we do this at most once per run

		$tag_set_in_tag_database = 1;

		#t do a checkin of the configuration package (contains
		#t the tag_database).
	    },
	   },
	   {
	    condition => $option_download_server,
	    description => "downloading",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $filename = $package_information->{filename};

		my $package_name = $package_information->{package_name};

		my $url = $package_information->{url};

		# create the directory

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'mkdir', '-p', $directory,
		     ],
		    );

		if ($option_verbose > 1)
		{
		    print "$0: package $package_name [$description from $url to $filename] executing\n";
		}

		if ($option_download_server =~ m(^file://))
		{
		    # create the directory

		    operation_execute
			(
			 $operations,
			 {
			  description => $description,

			  #t always zero here, but I guess this simply depends on working in client mode ?

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'mkdir', '-p', $directory,
			 ],
			);

		    # copy the tarball

		    operation_execute
			(
			 $operations,
			 {
			  description => $description,

			  #t always zero here, but I guess this simply depends on working in client mode ?

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'cp', $filename, $directory . $filename,
			 ],
			);

		}
		else
		{
		    # download the package

		    use LWP::Simple;

		    my $http_response = getstore($url, $directory . '/' . $filename);

		    if (!is_success($http_response))
		    {
			warn "$0: *** Warning: $description from $option_download_server: $http_response";
		    }
		}
	    },
	   },
	   {
	    condition => $option_download_server || $option_unpack,
	    description => "unpacking",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $filename = $package_information->{filename};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		# change the directory

		chdir $directory;

		# unpack the package

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'tar', 'xfvz', $filename,
		     ],
		    );
	    },
	   },

	   # everything that is compilation related needs a configure script, so create it.

	   {
	    condition => $option_configure || $option_compile || $option_check || $option_install,
	    operation => [ 'test', '-f', './configure', '||', './autogen.sh', ],
	   },
	   {
	    condition => $option_configure,
	    operation => [ './configure', ],
	   },

	   # everything that is compilation related needs makefiles, so create them.

	   {
	    condition => $option_compile || $option_check || $option_install,
	    operation => [ 'test', '-f', './Makefile', '||', './configure', ],
	   },
	   {
	    condition => $option_clean,
	    operation => [ 'make', 'clean', ],
	   },
	   {
	    condition => $option_countcode,
	    description => "count lines, words, characters in the implementation files",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $filename = $package_information->{filename};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		# change the directory

		chdir $directory;

		# countcode on C implementation files

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'wc', '</dev/null', '2>/dev/null', '`', 'find', '.', '-type', 'f', '-iname', '"*.c"', '-o', '-iname', '"*.h"', '|', 'grep', '-v', '"_Inline"', '`', '||', 'true',
		     ],
		    );

		# countcode on perl implementation files

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'wc', '</dev/null', '2>/dev/null', '`', '(', 'find', '.', '-type', 'f', '-iname', '"*.pm"', '&&', 'find', '2>/dev/null', 'perl', '-type', 'f', ')', '|', 'sort', '|', 'uniq', '|', 'grep', '-v', '"~$"', '|', 'grep', '-v', '"_Inline"', '`', '||', 'true',
		     ],
		    );

		# countcode on python implementation files

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'wc', '</dev/null', '2>/dev/null', '`', '(', 'find', '.', '-type', 'f', '-iname', '"*.py"', '&&', 'find', '2>/dev/null', 'python', '-type', 'f', ')', '|', 'sort', '|', 'uniq', '|', 'grep', '-v', '"~$"', '|', 'grep', '-v', '"_Inline"', '`', '||', 'true',
		     ],
		    );

		# countcode on script files

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'wc', '</dev/null', '2>/dev/null', '2>/dev/null', '`', '(', 'find', '2>/dev/null', 'bin', '-type', 'f', ')', '|', 'sort', '|', 'uniq', '|', 'grep', '-v', '"~$"', '|', 'grep', '-v', '"_Inline"', '`', '||', 'true',
		     ],
		    );

		# countcode on ndf implementation files

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'wc', '</dev/null', '2>/dev/null', '`', '(', 'find', '.', '-type', 'f', '-iname', '"*.ndf"', ')', '|', 'sort', '|', 'uniq', '|', 'grep', '-v', '"~$"', '|', 'grep', '-v', '"_Inline"', '`', '||', 'true',
		     ],
		    );

	    },
	   },
	   {
	    condition => $option_compile,
	    operation => [ 'make', ],
	   },
	   {
	    condition => $option_check,
	    operation => [ 'make', 'check', ],
	   },
	   {
	    condition => $option_dist,
	    operation => [ 'export', 'NEUROSPACES_RELEASE=1', '&&', 'make', 'dist'],
	   },
	   {
	    condition => $option_distcheck,
	    operation => [ 'export', 'NEUROSPACES_RELEASE=1', '&&', 'make', 'distcheck', ],
	   },
	   {
	    condition => $option_pkg_deb,
	    description => 'Build debian packages with release tags',
	    operation =>
	    sub
	    {
		my $package_information = shift;

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		
		# change the directory

		chdir $directory;

		my $command = parse_release_tags('pkg-deb');
		

		operation_execute
		  (
		   $operations,
		   {
		    description => $description,
		    keywords => 0,
		    package_name => $package_name,
		   },
		   $command,
		  );

		# Debian format:
		#    <name>_<version>-<release>_<architecture>.deb

		# Code isn't needed for now. 
# 		my $deb_prefix = "$package_name" . "_" . "$major.$minor";
		
# 		if(defined $micro)
# 		{
# 		  $deb_prefix .= ".$micro";
# 		}

# 		$deb_prefix .= "-$label";

		my $deb = `find $directory | grep $package_name | grep \\\\.deb\$`;
		chomp($deb);
		my $dsc = `find $directory | grep $package_name | grep \\.dsc\$`;
		chomp($dsc);
		my $changes = `find $directory | grep $package_name | grep \\.changes\$`;
		chomp($changes);
		my $build_log = $directory . "/build_debian.log";
		chomp($build_log);


		if(!-e $deb)
		{
		  print "Debian package for package $package_name was not created.\n";
		}
		else
		{
		  print "Debian package for package $package_name was created: $deb\n";
		}



		if($option_pkg_deb_dir)
		{

		  if(!-d $option_pkg_deb_dir)
		  {
		    operation_execute
		      (
		       $operations,
		       {
			description => $description,
			keywords => 0,
			package_name => $package_name,
		       },
		       [
			'mkdir', '-p', $option_pkg_deb_dir,
		       ],
		      );
 
		  }

		  #
		  # Since this produces multiple files we need to place them all into a directory. 
		  my $deb_dir = $option_pkg_deb_dir;


		  if(!-d $deb_dir)
		  {
		    operation_execute
		      (
		       $operations,
		       {
			description => $description,
			keywords => 0,
			package_name => $package_name,
		       },
		       [
			'mkdir', '-p', $deb_dir,
		       ],
		      );
		  }

		  # now we copy over each file built in the debian package build. 
		  # perform a check for the existence of the file to prevent it from
		  # stopping the neurospaces_build script. The build log should always
		  # be copied over. 
		  if(-d $deb_dir)
		  {


		    if(-e $deb)
		    {
		      operation_execute
			(
			 $operations,
			 {
			  description => $description,
			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'cp', '-f', $deb, $deb_dir,
			 ],
			);
		    }


		    if(-e $dsc)
		    {
		      operation_execute
			(
			 $operations,
			 {
			  description => $description,
			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'cp', '-f', $dsc, $deb_dir,
			 ],
			);
		    }



		    if(-e $changes)
		    {
		      operation_execute
			(
			 $operations,
			 {
			  description => $description,
			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'cp', '-f', $changes, $deb_dir,
			 ],
			);
		    }

		    my $target_build_log = $deb_dir . "/build_" . $package_name . ".log";
		    
		    if(-e $build_log)
		    {
		      operation_execute
			(
			 $operations,
			 {
			  description => $description,
			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'cp', '-f', $build_log, $target_build_log,
			 ],
			);
		    }



		  }
		  else
		  {
		    print "Error: Directory $deb_dir could not be created.\n";
		    print "Can't copy deb files.\n";
		  }

		}

	    },
	   },

	   {
	    condition => $option_pkg_rpm,
	    description => 'Build RPM packages with release tags',
	    operation =>
	    sub
	    {
		my $package_information = shift;

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		
		# change the directory

		chdir $directory;

		my $command = parse_release_tags('pkg-rpm');

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,
		      keywords => 0,
		      package_name => $package_name,
		     },
		     $command,
		    );

		my $pkgdir = $directory . "/RPM_BUILD";

		my @rpmfiles = `find $pkgdir/RPMS | grep $package_name | grep \\.rpm\$`;
		chomp(@rpmfiles);
		
		my $srpmfile = `find $pkgdir/SRPMS | grep $package_name | grep \\.rpm\$`;
		chomp($srpmfile);

		my $build_log = $directory . "/build_rpm.log";
		chomp($build_log);

		if( @rpmfiles > 0 )
		{

		  if(!-e $rpmfiles[0])
		  {
		    print "RPM file for package $package_name was not created.\n";
		    return;
		  }
		  else
		  {
		    print "RPM file for package $package_name was created: $rpmfiles[0]\n";
		  }

		}

		if($option_pkg_rpm_dir)
		{
		  #
		  # Since this produces multiple files we need to place them all into a directory. 
		  my $rpm_dir = $option_pkg_rpm_dir;
		
		  if(!-d $rpm_dir)
		  {
		    operation_execute
		      (
		       $operations,
		       {
			description => $description,
			keywords => 0,
			package_name => $package_name,
		       },
		       [
			'mkdir', '-p', $rpm_dir,
		       ],
		      );
		  }

		  # copy over each rpm file. 
		  if(-d $rpm_dir)
		  {

		    foreach my $rpmfile(@rpmfiles)
		    {
		      if(-e $rpmfile)
		      {
			operation_execute
			  (
			   $operations,
			   {
			    description => $description,
			    keywords => 0,
			    package_name => $package_name,
			   },
			   [
			    'cp', '-f', $rpmfile, $rpm_dir,
			   ],
			  );
		      }

		    }


		    # Assuming we only have one source rpm.
		    if(-e $srpmfile)
		    {
		      operation_execute
			(
			 $operations,
			 {
			  description => $description,
			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'cp', '-f', $srpmfile, $rpm_dir,
			 ],
			);
		    }

		
		    my $target_build_log = $rpm_dir . "/build_" . $package_name . ".log";

		    if(-e $build_log)
		    {
		      operation_execute
			(
			 $operations,
			 {
			  description => $description,
			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'cp', '-f', $build_log, $target_build_log,
			 ],
			);
		    }


		  }
		  else
		  {
		    print "Error: Directory $rpm_dir could not be created.\n";
		    print "Can't copy RPM files.\n";
		  }

		}

	      }
	   },

	   {
	    condition => $option_pkg_tar,
	    description => 'Build source tarballs with release tags',
	    operation =>
	    sub
	    {
		my $package_information = shift;

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		
		# change the directory

		chdir $directory;

		my $command = parse_release_tags('dist');

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,
		      keywords => 0,
		      package_name => $package_name,
		     },
		     $command,
		    );

# May reuse this code later. 
# 		my $tarball = "$package_name-$major.$minor";
		
# 		if(defined $micro)
# 		{
# 		  $tarball .= ".$micro";
# 		}

# 		$tarball .= "-$label.tar.gz";

		#t this type of test cannot work reliably: fi what if multiple tarballs are found?r
		
		# mando 9/17/2010: Added a '-' to the end of the package name to narrow
		# down the hits, only thing that should meet the criteria is a developer tarball.
		# Also added the maxdepth option to ensure it only searched the top level directory.
		# Only way it can fail is if there is more than one developer tarball in the top
		# level directory. Should not happen on cron runs alone since it performs a clean.

		my $tarball = `find $directory -maxdepth 1| grep $package_name- | grep \.tar\.gz\$`;
		chomp($tarball);


		if(!-e $tarball)
		{

		  print "Source dist for package $package_name was not created.\n";
		  return;

		}
		else
		{
		  print "Source dist for package $package_name was created: $tarball\n";

		}


		if($option_pkg_tar_dir)
		{

		  if(!-d $option_pkg_tar_dir)
		  {
		    operation_execute
		      (
		       $operations,
		       {
			description => $description,
			keywords => 0,
			package_name => $package_name,
		       },
		       [
			'mkdir', '-p', $option_pkg_tar_dir,
		       ],
		      );
 
		  }

		  if(-d $option_pkg_tar_dir)
		  {

		    #
		    # At this point the tarball exists so we 
		    # delete the old tarball before copying over
		    # the new.
		    operation_execute
		      (
		       $operations,
		       {
			description => $description,
			keywords => 0,
			package_name => $package_name,
		       },
		       [
			'rm', '-f', "$option_pkg_tar_dir/$package_name-*.tar.gz",
		       ],
		      );

		    operation_execute
		      (
		       $operations,
		       {
			description => $description,
			keywords => 0,
			package_name => $package_name,
		       },
		       [
			'cp', '-f', $tarball, $option_pkg_tar_dir,
		       ],
		      );
		  }
		  else
		  {
		    print "Error: Directory $option_pkg_tar_dir could not be created.\n";
		  }

		}

	    },
	   },
	   {
	    #! always make as the regular user to avoid cluttering the
	    #! source directory with root owned files

	    condition => $option_compile && !$option_uninstall && $option_install,
	    operation => [ 'make', '&&', 'sudo', 'make', 'install', ],
	   },
	   {
	    condition => $option_docs,
	    operation => [ 'make', 'docs', ],
	   },
	   {
	    condition => $option_website_prepare,
	    operation => [ 'make', 'html-upload-prepare', ],
	   },
	   {
	    condition => $option_website_upload,
	    operation => [ 'make', 'html-upload', ],
	   },
	   {
	    condition => $option_installed_versions,
	    description => 'installed versions',
	    operation =>
	    sub
	    {
		my $package_information = shift;

		my $package = $package_information->{package};

		my $version_script = $package->{version_script};

		if (!defined $version_script)
		{
		    $version_script = "$package_information->{package_name} --version";
		}

		if ($version_script ne 0)
		{
		    system $version_script;
		}
	    },
	   },
	   {
	    condition => $option_uninstall,
	    operation => [ 'make', 'clean', '&&', 'sudo', 'make', 'uninstall', ],
	   },
	   {
	    condition => $option_repo_ci,
	    description => "checkin to a local repository",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		#t where does this default value come from?  Cannot work correctly?

		my $repository_name
		    = $package_information->{package}->{version_control}->{repository}
			|| $directory . '/' . $package_name . '/' . 'mtn';

		my $port_number = $package_information->{package}->{version_control}->{port_number};

		# if not enough information for checkout

		if (not -f $repository_name and not -d $repository_name)
		{
		    die "$0: *** Error: cannot checkout from repository, repository_name not set";
		}

		if (not $port_number and $repository_name =~ m/^.*\.mtn$/)
		{
		    die "$0: *** Error: cannot checkout from repository, port_number not set";
		}

		# change the directory

		if (not chdir $directory)
		{
		    die "$0: *** Error: cannot change to directory $directory";
		}

		# merge code

		#t MERCURIAL merge
		# command: hg merge

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
# 		      'test', '-d', '_MTN',
# 		      '||',
		      'mtn', '--db', $repository_name, '--branch', '0', 'merge',
		     ],
		    );

		# checkin code

		#t MERCURAL commit
		# hg commit

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
# 		      'test', '-d', '_MTN',
# 		      '||',
		      'mtn', '--db', $repository_name, '--branch', '0', 'ci', '.', '--message', $option_repo_ci,
		     ],
		    );

		# update code

		#t MONOTONE
		
		# MERCURIAL update checkout
		# these two are actually aliased to each other because of how it pulls a workspace. 
		# You simply update to a particular revision number.
		# hg update [-r revision]

		my @update_args;

		my $upstream_version_options = [ '--branch', '0', ];

		if ($option_upstream_version)
		{
		    $upstream_version_options = [ split /\s/, $option_upstream_version, ];
		}

		if ($monotone_version >= 0.45)
		{
		    @update_args = [ 'mtn', 'automate', 'get_base_revision_id',
				     '&&', 'mtn', '--db', $repository_name, @$upstream_version_options, 'update','--move-conflicting-paths', ];
	        }
	        else
	        {
		    @update_args = [ 'mtn', 'automate', 'get_base_revision_id',
				     '&&', 'mtn', '--db', $repository_name, @$upstream_version_options, 'update', ];
		}

		operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     @update_args,
		    );
	    },
	   },
	   {
	    condition => $option_upload_server,
	    description => "uploading",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $filename = $package_information->{filename};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		my $url = $package_information->{url};

		if (!$filename)
		{
		    die "$0: *** Error: no filename defined for uploading";
		}

		if ($option_verbose)
		{
		    print "$0: package $package_name [$description $filename to $option_upload_server] executing\n";
		}

		# change the directory

		chdir $directory;

		# upload the package

		$option_upload_server =~ m(((.*)://)?([^/]+)(.*));

		my $upload_protocol = $2 || 'https';

		my $upload_host = $3;

		my $upload_directory = $4;

		my $module_names
		    = {
		       file => '-1',
		       ftp => 'Net::FTP',
		       https => 'HTTP::DAV',
		       sftp => 'Net::SFTP',
		      };

		my $module_name = $module_names->{$upload_protocol};

		my $login_info = YAML::LoadFile("$ENV{HOME}/.sourceforge_login");

		my $user = $login_info->{user};

		my $password = $login_info->{password};

		my $try_something_very_sophisticated_with_broken_libraries = 'no';

		if ($try_something_very_sophisticated_with_broken_libraries eq 'yes')
		{
		    my $loaded_protocol_module = eval "require $module_name";

		    if ($@)
		    {
			no strict "refs";

			if (exists ${"::"}{verbose} && $::option_verbose)
			{
			    print STDERR "$0: cannot load protocol module $module_name because of: $@\n";
			    print STDERR "$0: continuing.\n";
			}
		    }

		    my $ftp;

		    if ($upload_protocol =~ /^s?ftp$/)
		    {
			$ftp
			    = eval "$module_name->new('$upload_host', Debug => 0, user => '$user', password => '$password', )"
				or die "$0: *** Error: for $filename: cannot connect to $upload_host: $@";
		    }
		    else
		    {
			$ftp
			    = eval "HTTP::DAV->new()"
				or die "$0: *** Error: for $filename: cannot connect to $upload_host: $@";

			$ftp->credentials
			    (
			     -user=> $user,
			     -pass => $password,
			     -url => $option_upload_server,
			    );

			$ftp->open( -url=> $option_upload_server, )
			    or die("$0: *** Error: cannot open $option_upload_server: " . $ftp->message() . "\n");
		    }

# 		    $ftp->login("anonymous", '-anonymous@')
# 			or die "$0: *** Error: for $filename: cannot login to $upload_host", $ftp->message();

		    $ftp->cwd($upload_directory)
			or die "$0: *** Error: for $filename: cannot change working directory to $upload_directory", $ftp->message();

		    if ($upload_protocol =~ /^s?ftp$/)
		    {
			$ftp->binary()
			    or die "$0: *** Error: for $filename: cannot switch to binary ftp mode", $ftp->message();

			$ftp->hash()
			    or die "$0: *** Error: for $filename: cannot enable hash printing", $ftp->message();
		    }

		    $ftp->put($filename)
			or die "$0: *** Error: for $filename: Net::FTP::put() failed ", $ftp->message();

		    if ($upload_protocol =~ /^s?ftp$/)
		    {
			$ftp->quit();
		    }
		    else
		    {
			$ftp->unlock();
		    }
		}

		# else we are trying a hardcoded solution that should work

		else
		{
		    if ($upload_protocol eq 'sftp')
		    {
			use Expect;

			my $expector = Expect->new();

			#! see the expect manual for this one

			$expector->raw_pty(1);

			$expector->spawn('sftp', "$user\@$upload_host",)
			    or die "$0: cannot spawn 'sftp': $!\n";

			my ($matched_pattern_position,
			    $error,
			    $successfully_matching_string,
			    $before_match,
			    $after_match)
			    = $expector->expect(15, "word:", );

			$expector->send("$password\n");

			my $prompt = "sftp>";

			($matched_pattern_position,
			 $error,
			 $successfully_matching_string,
			 $before_match,
			 $after_match)
			    = $expector->expect(5, $prompt, );

			$upload_directory =~ s|^/||;

			$expector->send("cd $upload_directory\n");

			($matched_pattern_position,
			 $error,
			 $successfully_matching_string,
			 $before_match,
			 $after_match)
			    = $expector->expect(5, $prompt, );

			$expector->send("put '$filename'\n");

			($matched_pattern_position,
			 $error,
			 $successfully_matching_string,
			 $before_match,
			 $after_match)
			    = $expector->expect(600, $prompt, );

			$expector->send("quit\n");
		    }
		    elsif ($upload_protocol eq 'file')
		    {
			# construct the target directory

			my $target_directory = $upload_host . $upload_directory;

			# make sure the target directory is rooted

			if ($target_directory !~ /^\//)
			{
			    $target_directory = "/$target_directory";
			}

			# create the directory

			operation_execute
			    (
			     $operations,
			     {
			      description => $description,

			      #t always zero here, but I guess this simply depends on working in client mode ?

			      keywords => 0,
			      package_name => $package_name,
			     },
			     [
			      'mkdir', '-p', $target_directory,
			     ],
			    );

			# copy the tarball

			operation_execute
			    (
			     $operations,
			     {
			      description => $description,

			      #t always zero here, but I guess this simply depends on working in client mode ?

			      keywords => 0,
			      package_name => $package_name,
			     },
			     [
			      'cp', $filename, $target_directory,
			     ],
			    );

		    }
		    else
		    {
			die "$0: *** Error: unknown upload protocol $upload_protocol";
		    }
		}
	    },
	   },
	   {
	    condition => (scalar @$option_dist_dir),
	    description => "copying files to the distribution directories",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $filename = $package_information->{filename};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		my $url = $package_information->{url};

		if (!$filename)
		{
		    die "$0: *** Error: no filename defined to copy to the distribution directories";
		}

		# change the directory

		chdir $directory;

		foreach my $dist_dir (@$option_dist_dir)
		{
		    # create directory

		    if (!-d $dist_dir)
		    {
			operation_execute
			    (
			     $operations,
			     {
			      description => $description,

			      #t always zero here, but I guess this simply depends on working in client mode ?

			      keywords => 0,
			      package_name => $package_name,
			     },
			     [
			      'mkdir', '-p', $dist_dir,
			     ],
			    );
		    }

		    # copy the package

		    operation_execute
			(
			 $operations,
			 {
			  description => $description,

			  #t always zero here

			  keywords => 0,
			  package_name => $package_name,
			 },
			 [
			  'cp', $filename, $dist_dir,
			 ],
			);
		}
	    },
	   },
	   {
	    condition => $option_certification_report,

	    #t MONOTONE

	    operation => [ 'mtn', 'cert', '\'%version\'', '--', 'build_report', '\'%report\'', ],

	    # MERCURIAL cert
	    # mercurial doesn't yet have it's own cert functionality. 
	    # It's on a TODO, more info here: http://mercurial.selenic.com/wiki/ArbitraryMetadata
	   },
	   {
	    condition => $option_repo_status,
	    description => 'comparing workspace with source code repository branch head',
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		#t where does this default value come from?  Cannot work correctly?

		my $repository_name
		    = $package_information->{package}->{version_control}->{repository}
			|| $directory . '/' . $package_name . '/' . 'mtn';

		my $port_number = $package_information->{package}->{version_control}->{port_number};

		# print header

		my $text = "$0: *** package $package_name";

		print "\n\n" . ("-" x length $text) . "\n$text\n";

# 		# if not enough information for comparing

# 		if (not -f $repository_name and not -d $repository_name)
# 		{
# 		    die "$0: *** Error: cannot compare with repository, repository_name not set";
# 		}

# 		if (not $port_number and $repository_name =~ m/^.*\.mtn$/)
# 		{
# 		    die "$0: *** Error: cannot compare with repository, port_number not set";
# 		}

		# change the directory

		my $success = chdir $directory;

		if (!$success)
		{
		    die "$0: *** Error: package $package_name cannot change from directory to directory ($directory): $!";
		}

		# construct a default set with information commands

		my $information_sets
		    = {
		       #t MERCURIAL
		       #t hg status

		       missing => [ "mtn", "ls", "missing", ],
		       status => [ 'mtn', 'status', ],
		       unknown => [ "mtn", "ls", "unknown", ],
		      };

		# go through all informational operations

		foreach my $information_set (
					     qw(
						missing
						unknown
						status
					       )
					    )
		{
		    # and overwrite with specific commands for this package if applicable

		    #! exists such that a '0' or undef can erase the default information_set command

		    if (exists $package_information->{package}->{version_control}->{commands}->{$information_set})
		    {
			$information_sets->{$information_set}
			    = $package_information->{package}->{version_control}->{commands}->{$information_set};
		    }
		}

		# go through all informational operations

		foreach my $information_set (
					     qw(
						status
						missing
						unknown
					       )
					    )
		{
		    # if the information_set command is defined

		    if ($information_sets->{$information_set})
		    {
			# execute the information_set command

			operation_execute
			    (
			     $operations,
			     {
			      description => "information_set $information_set",

			      #t always zero here, but I guess this simply depends on working in client mode ?

			      keywords => 0,
			      package_name => $package_name,
			     },
			     $information_sets->{$information_set},
			    );
		    }
		}
	    },
	   },
	   {
	    condition => $option_repo_history,
	    description => 'asking for past revision information',
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		#t where does this default value come from?  Cannot work correctly?

		my $repository_name
		    = $package_information->{package}->{version_control}->{repository}
			|| $directory . '/' . $package_name . '/' . 'mtn';

		my $port_number = $package_information->{package}->{version_control}->{port_number};

		# print header

		my $text = "$0: *** package $package_name";

		print "\n\n" . ("-" x length $text) . "\n$text\n";

# 		# if not enough information for comparing

# 		if (not -f $repository_name and not -d $repository_name)
# 		{
# 		    die "$0: *** Error: cannot compare with repository, repository_name not set";
# 		}

# 		if (not $port_number and $repository_name =~ m/^.*\.mtn$/)
# 		{
# 		    die "$0: *** Error: cannot compare with repository, port_number not set";
# 		}

		# change the directory

		my $success = chdir $directory;

		if (!$success)
		{
		    die "$0: *** Error: package $package_name cannot change from directory to directory ($directory): $!";
		}

		# construct a default set with information commands

		my $history_sets
		    = {
		       #t for MERCURIAL
		       #t hg log

		       log => [ "mtn", "log", "--last", $option_repo_history_last, ],
		       status => [ 'mtn', 'status', ],
		      };

		# go through all log operations

		foreach my $history_set (
					 qw(
					    status
					    log
					  )
					)
		{
		    # and overwrite with specific commands for this package if applicable

		    #! exists such that a '0' or undef can erase the default history_set command

		    if (exists $package_information->{package}->{version_control}->{commands}->{$history_set})
		    {
			$history_sets->{$history_set}
			    = $package_information->{package}->{version_control}->{commands}->{$history_set};
		    }
		}

		# go through all log operations

		foreach my $history_set (
					 qw(
					    status
					    log
					  )
					)
		{
		    # if the history_set command is defined

		    if ($history_sets->{$history_set})
		    {
			# execute the history_set command

			operation_execute
			    (
			     $operations,
			     {
			      description => "history_set $history_set",

			      #t always zero here, but I guess this simply depends on working in client mode ?

			      keywords => 0,
			      package_name => $package_name,
			     },
			     $history_sets->{$history_set},
			    );
		    }
		}
	    },
	   },
	   {
	    condition => $option_repo_revert,
	    operation => [ 'mtn', 'revert', '.', ],
	   },
	   {
	    condition => $option_repo_sync,
	    description => 'syncing repository',
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# get specific arguments

		my $description = $package_information->{description};

		my $directory = $package_information->{directory};

		my $operations = $package_information->{operations};

		my $package_name = $package_information->{package_name};

		#t where does this default value come from?  Cannot work correctly?

		my $repository_name
		    = $package_information->{package}->{version_control}->{repository}
			|| $directory . '/' . $package_name . '/' . 'mtn';



		# translate well known names to a routable address

		my $repo_server = version_control_translate_server($option_repo_sync);

		#
		# Check to see if the repository name ends with .mtn, if not we assume it ends
		# in .hg, in which case we don't need the port number since mercurial serves over http.
		#

		if ($repository_name =~ m/^.*\.mtn$/)
		{
		  #t MONOTONE

		  my $port_number = $package_information->{package}->{version_control}->{port_number};

		  # if not enough information for syncing for monotone

		  if (not -f $repository_name)
		  {
		    die "$0: *** Error: cannot sync repository, repository_name not set";
		  }

		  if (not $port_number and $repository_name =~ m/^.*\.mtn$/)
		  {
		    die "$0: *** Error: cannot sync repository, port_number not set";
		  }

		  # initialize the repository if necessary

		  operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'test', '-f', $repository_name, '||', 'mtn', '--db', $repository_name, 'db', 'init',
		     ],
		    );

		  # sync the repository

		  #t MONOTONE

		  operation_execute
		    (
		     $operations,
		     {
		      description => $description,

		      #t always zero here, but I guess this simply depends on working in client mode ?

		      keywords => 0,
		      package_name => $package_name,
		     },
		     [
		      'mtn', '--db', $repository_name, 'sync', '--ticker=count', "$repo_server:$port_number",
		     ],
		    );

		}
		else
		{

		  # MERCURIAL sync

		  # operations:
		  #   initialize the repo: 
		  #      hg clone http://repo-genesis3.cbi.utsa.edu/hg/g-tube ${HOME}/neurospaces_project/g-tube/source/snapshots/0/
		  #   cd ${HOME}/neurospaces_project/g-tube/source/snapshots/0
		  #   hg pull
		  #   (hg merge)? since you can't push if you have multiple heads.
		  #   hg push

		  # performs a clone of a repository if the project workspace isn't present.
# 		  my $mercurial_server = $repo_server . '/' . $package_name;

# 		  operation_execute
# 		    (
# 		     $operations,
# 		     {
# 		      description => $description,

# 		      #t always zero here, but I guess this simply depends on working in client mode ?

# 		      keywords => 0,
# 		      package_name => $package_name,
# 		     },
# 		     [
# 		      'test', '-f', $repository_name, '||', 'hg', 'clone', $mercurial_server, $directory,
# 		     ],
# 		    );


		  # first perform a pull -u to pull and update.
# 		  operation_execute
# 		    (
# 		     $operations,
# 		     {
# 		      description => $description,

# 		      keywords => 0,
# 		      package_name => $package_name,
# 		     },
# 		     [
# 		      'hg', 'pull', '-u', $mercurial_server,
# 		     ],
# 		    );


		  # then perform a push, a sync must be done in two operations.
		  # note: this push operation should always fail since the ssh key
		  # setup hasn't been properly installed on repo-genesis3. The final implementation
		  # should use something like ssh://repo-genesis3.cbi.utsa.edu for the $mercurial_server call.
# 		  operation_execute
# 		    (
# 		     $operations,
# 		     {
# 		      description => $description,

# 		      keywords => 0,
# 		      package_name => $package_name,
# 		     },
# 		     [
# 		      'hg', 'push', $mercurial_server,
# 		     ],
# 		    );


		}

		},
	      },
	   ];

    # process environment options

#     # tell neurospaces_harness if to send emails for this

#     $ENV{NEUROSPACES_HARNESS_OPTION_EMAIL} = $option_neurospaces_harness_email;

    # build the environment for external applications

    foreach my $environment_setting (@$option_environment)
    {
	$environment_setting =~ /^(.*?)=(.*)$/;

	my $variable = $1;

	my $value = $2;

	$ENV{$variable} = $value;
    }

    if ($option_verbose
	&& @$option_environment)
    {
	use YAML;

	print Dump(\%ENV);
    }

    # if there is a local package configuration

    if ($whole_build_configuration)
    {
	# merge

	require Data::Utilities;

	my $merged_packages = Data::Merger::merger($all_packages, $whole_build_configuration->{all_packages});
    }

    # check validity of the package configuration

    foreach my $first_package_name (keys %$all_packages)
    {
	my $first_package = $all_packages->{$first_package_name};

	foreach my $second_package_name (keys %$all_packages)
	{
	    next if $first_package_name eq $second_package_name;

	    my $second_package = $all_packages->{$second_package_name};

	    # if the version control port numbers are the same

	    if ($first_package->{version_control}
		and $first_package->{version_control}->{port_number}
		and $second_package->{version_control}
		and $second_package->{version_control}->{port_number})
	    {
		if ($first_package->{version_control}->{port_number}
		    eq $second_package->{version_control}->{port_number})
		{
		    die "$0: *** Error: package $first_package_name and $second_package_name have the same version control port number";
		}
	    }
	}
    }

    # reporting options

    if ($option_help
        || scalar @ARGV)
    {
	$0 =~ m(.*/(.*));

	my $program_name = $1;

	print Dump($build_report->{options});

	print
	    "

$program_name: configure, compile, check, install, tag and build
releases of packages selected from a set of packages.

$program_name can operate in two modes: the default one is for a
client machine, assuming a user who tries to install the packages.
The second mode is for a developer who follows the Neurospaces
conventions where to put the src code of the packages.  The main
difference between the two modes is where this script finds the source
code.

$program_name creates a matrix of packages (rows) and build operations
(columns).  $program_name goes through the matrix, packages first, and
performs one build operation after the other for the selected package.
The options select or deselect cells in the matrix.

To find out what packages are in the database, use the '--help-packages'
option.  Disabled packages are not put in the matrix, enabled packages
are.  To disable packages, use the '--disable' option with a regex
argument.  To enable packages, use the '--enable' option with a regex
argument.  After building the matrix, rows are selected using
'--regex-selector' option, which by default selects all rows.

To find out about the known build operations, use '--help'.  To
disable a build operation, prefix the corresponding option with
'--no-', eg. to disable configure, use '--no-configure'.

options related to operation mode selection:
    --client                 execute in client mode (for regular users, default).
    --developer              execute in developer mode.

options related to operation execution profile:
    --certification-report   annotate the (monotone) repository with the build_report.
    --check                  check packages.
    --clean                  clean before compiling.
    --compile                compile packages.
    --configure              configure before compiling.
    --configure-type         type of configuration (default is 'release').
    --countcode              countcode at different times during the build.
    --directories-create     create package directory structure.
    --disable                explicitly disable this regex of packages in the configuration.
    --dist                   build distribution tarballs.
    --distcheck              check created tarballs.
    --distclean              distclean before compiling.
    --distkeywords           do keyword expansion (be careful with this one).
    --docs                   generate docs during compilation.
    --dry-run                do not execute any command, just report what would be done.
    --enable                 explicitly enable these regex of packages in the configuration.
    --help                   print usage information.
    --help-all               print usage, all packages and all operations.
    --help-operations        print known operations.
    --help-packages          print known packages, in order of build.
    --help-repositories      print known source code repositories.
    --install                install packages.
    --installed-versions     print the installed version of each software package.
    --keep-going             keep going in case of non-fatal errors (ala make -k).
    --pkg-deb                build debian packages for each software component.
    --pkg-deb-dir            Directory to place debian packages after a debian build.
    --pkg-rpm                build RPM packages for each software component.
    --pkg-rpm-dir            Directory to place RPM packages after an RPM build.
    --pkg-tar                build source tarballs for each software package.
    --pkg-tar-dir            Directory to place source tarballs into after creating a dist.
    --regex-selector         defines a regex to select specific packages.
    --release-tag            Sets a release tag for source code distribution.
    --repo-ci                commit all modifications with the given changelog description.
    --repo-clone             checkout or update the workspace source code from a remote repository.
    --repo-co                checkout or update the workspace source code from a local repository.
    --repo-init              initialize those local repositories that do not exist yet.
    --repo-history           show locally stored history information of enabled software components.
    --repo-history-last      number of history records to show.
    --repo-pull              pull the repositories from this server (e.g. repo-genesis3.cbi.utsa.edu).
    --repo-push              push the repositories to this server (e.g. repo-genesis3.cbi.utsa.edu).
    --repo-serve             start the version control program in server mode to give others access to your code.
                             this will automatically fork processes as needed and return control to the terminal.
    --repo-status            compare workspace with source code repository branch head.
    --repo-sync              sync the repositories with this server (e.g. repo-genesis3.cbi.utsa.edu).
    --tag                    set this tag on all packages.
    --uninstall              uninstall packages, cannot be combined with installation options.
    --upload-server          enable uploading packages to this server (e.g. https://frs.sourceforge.net/uploads).
    --version                give version information.
    --version-tag            The software version for a source code distribution release.
    --v|verbose              tell what is being done, specify multiple times to get more feedback.
    --website-prepare        prepare the website on your developer machine.
    --website-upload         upload the website to the webserver.

options related to installation on a client machine:
    --download-server        enable downloading packages from this server (e.g. downloads.sourceforge.net).
    --src-tag                use this tag for finding src directories on a client machine.
    --src-dir                use this dir as the base for directories on a client machine.

So on a client machine, for package xxx, the src are found in the
directory <src-dir>/xxx-<src-tag>.  From there the build starts as
usual.


options related to behavior of external applications:
    --environment            fills in the environment, can be given multiple times.
                             e.g. environment NEUROSPACES_HARNESS_OPTION_EMAIL=1 generates emails for tests that fail.

";

    }

    # reporting options

    if ($option_help_all)
    {
	$0 =~ m(.*/(.*));

	my $program_name = $1;

	print Dump(
		   {
		    options => $build_report->{options},
		    usage =>
	    "

$program_name: configure, compile, check, install, tag and build
releases of packages selected from a set of packages.

$program_name can operate in two modes: the default one is for a
client machine, assuming a user who tries to install the packages.
The second mode is for a developer who follows the Neurospaces
conventions where to put the src code of the packages.  The main
difference between the two modes is where this script finds the source
code.

$program_name creates a matrix of packages (rows) and build operations
(columns).  $program_name goes through the matrix, packages first, and
performs one build operation after the other for the selected package.
The options select or deselect cells in the matrix.

To find out what packages are in the database, use the '--help-packages'
option.  Disabled packages are not put in the matrix, enabled packages
are.  To disable packages, use the '--disable' option with a regex
argument.  To enable packages, use the '--enable' option with a regex
argument.  After building the matrix, rows are selected using
'--regex-selector' option, which by default selects all rows.

To find out about the known build operations, use '--help'.  To
disable a build operation, prefix the corresponding option with
'--no-', eg. to disable configure, use '--no-configure'.

options related to operation mode selection:
    --client                 execute in client mode (for regular users, default).
    --developer              execute in developer mode.

options related to operation execution profile:
    --certification-report   annotate the (monotone) repository with the build_report.
    --check                  check packages.
    --clean                  clean before compiling.
    --compile                compile packages.
    --configure              configure before compiling.
    --configure-type         type of configuration (default is 'release').
    --countcode              countcode at different times during the build.
    --directories-create     create package directory structure.
    --disable                explicitly disable this regex of packages in the configuration.
    --dist                   build distribution tarballs.
    --distcheck              check created tarballs.
    --distclean              distclean before compiling.
    --distkeywords           do keyword expansion (be careful with this one).
    --docs                   generate docs during compilation.
    --dry-run                do not execute any command, just report what would be done.
    --enable                 explicitly enable these regex of packages in the configuration.
    --help                   print usage information.
    --help-all               print usage, all packages and all operations.
    --help-operations        print known operations.
    --help-packages          print known packages, in order of build.
    --help-repositories      print known source code repositories.
    --install                install packages.
    --installed-versions     print the installed version of each software package.
    --keep-going             keep going in case of non-fatal errors (ala make -k).
    --pkg-deb                build debian packages for each software component.
    --pkg-deb-dir            Directory to place debian packages after a debian build.
    --pkg-rpm                build RPM packages for each software component.
    --pkg-rpm-dir            Directory to place RPM packages after an RPM build.
    --pkg-tar                build source tarballs for each software package.
    --pkg-tar-dir            Directory to place source tarballs into after creating a dist.
    --regex-selector         defines a regex to select specific packages.
    --release-tag            Sets a release tag for source code distribution.
    --repo-ci                commit all modifications with the given changelog description.
    --repo-clone             checkout or update the workspace source code from a remote repository.
    --repo-co                checkout or update the workspace source code from a local repository.
    --repo-init              initialize those local repositories that do not exist yet.
    --repo-history           show locally stored history information of enabled software components.
    --repo-history-last      number of history records to show.
    --repo-pull              pull the repositories from this server (e.g. repo-genesis3.cbi.utsa.edu).
    --repo-push              push the repositories to this server (e.g. repo-genesis3.cbi.utsa.edu).
    --repo-serve             start the version control program in server mode to give others access to your code.
                             this will automatically fork processes as needed and return control to the terminal.
    --repo-status            compare workspace with source code repository branch head.
    --repo-sync              sync the repositories with this server (e.g. repo-genesis3.cbi.utsa.edu).
    --tag                    set this tag on all packages.
    --uninstall              uninstall packages, cannot be combined with installation options.
    --upload-server          enable uploading packages to this server (e.g. https://frs.sourceforge.net/uploads).
    --version                give version information.
    --version-tag            The software version for a source code distribution release.
    --v|verbose              tell what is being done, specify multiple times to get more feedback.
    --website-prepare        prepare the website on your developer machine.
    --website-upload         upload the website to the webserver.

options related to installation on a client machine:
    --download-server        enable downloading packages from this server (e.g. downloads.sourceforge.net).
    --src-tag                use this tag for finding src directories on a client machine.
    --src-dir                use this dir as the base for directories on a client machine.

So on a client machine, for package xxx, the src are found in the
directory <src-dir>/xxx-<src-tag>.  From there the build starts as
usual.


options related to behavior of external applications:
    --environment            fills in the environment, can be given multiple times.
                             e.g. environment NEUROSPACES_HARNESS_OPTION_EMAIL=1 generates emails for tests that fail.

",

			all_packages => $all_packages,
			all_operations => $all_operations,
		       },
		      );

	exit 1;
    }

    if ($option_help_operations)
    {
	print
	    "$0:\n  operations in order of build:\n    - "
		. (
		   join
		   "\n    - ",
		   grep
		   {
		       $_ =~ /$option_regex_selector/i
		   }
		   map
		   {
		       $_->{description} || join ' ', @{$_->{operation} || []},
		   }
		   @$all_operations,
		  )
		    . "\n";

	exit 1;
    }

    if ($option_help_packages)
    {
	print
	    "---\nenabled packages in order of build:\n    - "
		. (
		   join
		   "\n    - ",
		   sort
		   {
		       $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
		   }
		   grep
		   {
		       not $all_packages->{$_}->{disabled}
		   }
		   grep
		   {
		       $_ =~ /$option_regex_selector/i
		   }
		   keys %$all_packages
		  )
		    . "\n";

	exit 1;
    }

    if ($option_help_repositories)
    {
	my $repositories
	    = [
	       map
	       {
		   my $package_information = $all_packages->{$_};

		   my $repository_name
		       = $package_information->{version_control}->{repository}
			   || $package_information->{directory} . '/' . 'mtn';

		   {
		       package => $_,
		       repository_name => $repository_name,
		   };
	       }
	       sort
	       {
		   $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
	       }
	       grep
	       {
		   not $all_packages->{$_}->{disabled}
	       }
	       grep
	       {
		   $_ =~ /$option_regex_selector/i
	       }
	       keys %$all_packages
	      ];

	use YAML;

	print Dump( { $0 => { repositories => $repositories, }, }, );
	
	exit 1;
    }

}


sub report_exit
{
    my $exit_code = shift;

    my $description = shift;

    $build_report->{global}->{time_end} = `date`;

    #! I remove the times here, just to ease the regression testing

    if ($ENV{NEUROSPACES_BUILD_TESTING})
    {
	delete $build_report->{global}->{time_end};
	delete $build_report->{global}->{time_start};
    }

    if (defined $description
        && $exit_code eq 3)
    {
	print "*** die: $description\n";
    }

    # yaml out the build report

    if ($option_verbose > 1)
    {
	print Dump($build_report);
    }

#     # if there were errors

#     if ($error_count)
#     {
# 	# exit with failure

# 	$exit_code ||= 1;

# 	print "$0: exit_code $exit_code\n";

# 	exit $exit_code;
#     }

#     # else

#     else
    {
	# exit, possibly success

	exit $exit_code;
    }
}


sub report_message
{
    my $header = shift;

    my $trailer = shift;

    my $message = shift;

    my $lines = [ split '\n', $message, ];

    my $longest = 0;

    map
    {
	($longest < length) && ($longest = length)
    }
	@$lines;

    my $line = '-' x $longest;

    print "\n";
    print "$line\n" for 0 .. $header;
    print "\n";
    print "$message\n\n";
    print "$line\n" for 0 .. $trailer;
    print "\n";
}


sub operation_execute
{
    my $operations = shift;

    my $environment = shift;

    my $arguments = shift;

    my $description = $environment->{description};

    my $keywords = defined $environment->{keywords} ? $environment->{keywords} : 1;

    my $package_name = $environment->{package_name};

    my $reported_arguments = [ @$arguments, ];

    # if keyword expansions

    if ($keywords)
    {
	# get monotone id

	#t MONOTONE

	my $monotone_id = `mtn automate get_base_revision_id`;

	chomp $monotone_id;

	# define release labels

	#! copied from release-extract

	my $log = [ `mtn log --last 1`, ];

# 	my $monotone_id
# 	    = [
# 	       map
# 	       {
# 		   s/.*Revision:\s*//;

# 		   s/\s*//g;

# 		   $_;
# 	       }
# 	       grep
# 	       {
# 		   m'Revision:';
# 	       }
# 	       @$log,
# 	      ];

	my $release_label = $option_tag;

	$release_label =~ m/([^-]+)-([^-]+)?(?:-([^-]+))?/;

	my $release_major = $1 || $monotone_id;

	my $release_minor = $2 || 0;

	my $release_micro = $3 || 0;

	$arguments
	    = [
	       map
	       {
		   s/%package/$package_name/g;
		   s/%release_major/$release_major/g;
		   s/%release_micro/$release_micro/g;
		   s/%release_minor/$release_minor/g;
		   s/%version/$monotone_id/g;

		   $_;
	       }
	       @$arguments,
	      ];

	#! to prevent monotone from interpreting the yaml as an option,
	#! we prefix the report with something that does not look like an
	#! option.

	my $report_text = Dump( { build_report => $build_report, }, ) . "\n";

	$reported_arguments
	    = [
	       map
	       {
		   my $argument = $_;

		   $argument =~ s/%report/$report_text/g;

		   # replace non-LDH characters: underscores

		   $argument =~ s/_/-/g;

		   $argument;
	       }
	       @$arguments,
	      ];
    }

    # register that we are about to do this operation for this package

    push @$operations, { description => $description, package_name => $package_name, operations => $reported_arguments, };

    if (!$option_dry_run)
    {
	print "$0: package $package_name [" . (join ' ', map { /\s/ ? "\"$_\"" : $_ } @$arguments) . "] executing\n";

	system join " ", map { /\s/ ? "\"$_\"" : $_ } @$arguments;

	if ($?)
	{
	    if ($option_keep_going and ((join " ", map { /\s/ ? "\"$_\"" : $_ } @$arguments) =~ /check/))
	    {
		#! assume system has given a good error message

		print "$0: *** Error: package $package_name: $?\n";
		print "$0: option_keep_going is set to $option_keep_going, continuing.\n";
	    }
	    else
	    {
		#! assume system has given a good error message

		die "$0: *** Error: package $package_name: $?";
	    }
	}

	if ($option_verbose)
	{
	    print "$0: package $package_name [" . (join ' ', map { /\s/ ? "\"$_\"" : $_ } @$arguments ) . "] executed \n";
	}
    }
    else
    {
	if ($option_verbose)
	{
	    print "$0: package $package_name [" . (join ' ', map { /\s/ ? "\"$_\"" : $_ } @$arguments ) . "] not executed, dry_run is $option_dry_run\n";
	}
    }
}


sub version
{
    # $Format: "    my $version=\"${package}-${label}\";"$
    my $version="developer-alpha";

    return $version;
}


#
# Returns the monotone version. 
#
sub monotone_version
{

  my $tmp = `mtn --version`;

  my @tmp = split(/ /,$tmp);

  return $tmp[1];

}


sub version_control_translate_server
{
    my $server_name = shift;

    # by default, the result is the given name

    my $result = $server_name;

    # loop over all known servers

    foreach my $version_control_server (@$version_control_servers)
    {
	# if the server name matches

	if ($server_name eq $version_control_server->{name})
	{
	    # translate

	    $result = $version_control_server->{address};

	    # break loop

	    last;
	}
    }

    # return result

    return $result;
}


main();


