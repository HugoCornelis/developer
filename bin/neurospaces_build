#!/usr/bin/perl
#!/usr/bin/perl -w -d:ptkdb
#


use strict;


use Getopt::Long;

use YAML;


# options related to operation mode selection:

my $option_client = 0;
my $option_developer = 0;

# operation execution profile: default is configure, compile and install

my $option_certification_report = 0;
my $option_check = 0;
my $option_clean = 0;
my $option_compile = 1;
my $option_configure = 1;
my $option_dist = 0;
my $option_distcheck = 0;
my $option_distclean = 0;
my $option_distkeywords = 0;
my $option_dry_run = 0;
my $option_install = 1;
my $option_regex_selector = ".*";
my $option_tag = 0;
my $option_uninstall = 0;
my $option_verbose = 0;

# options related to installation on a client machine

my $option_src_tag;
my $option_src_dir;
my $option_download_server;


my $all_operations = [];
#     = [
#        {
# 	operation => [ 'make', 'distclean', ],
# 	condition => $option_distclean && !$option_uninstall,
#        },
#        {
# 	operation => [
# 		      ( 'make', 'dist-keywords', ),
# 		      ( '&&', 'make', 'clean', ),
# 		      ( '&&', 'make', 'clean', ),
# 		     ],
# 	condition => $option_distkeywords,
#        },
#        {
# 	operation => [
# 		      ( "test", "!", '"`mtn ls unknown && mtn ls missing && mtn ls changed`"', ),
# 		      ( '&&', 'release-expand', "'%package'", "'%release_major'", "'%release_minor'", "'%release_micro'", "'%release_major-%release_minor'", 'hugo.cornelis@gmail.com', '--verbose', ),
# 		      ( '&&', 'make', 'clean', ),
# 		      ( '&&', 'make', 'clean', ),
# 		      ( "&&", 'mtn', 'ci', "-m", "'1. Keywords only: $option_tag\n'", ),
# 		      ( "&&", "test", "!", '"`mtn ls unknown && mtn ls missing && mtn ls changed`"', ),
# 		     ],
# 	condition => $option_tag,
#        },
#        {
# 	operation => [
# 		      #! in a separate operation such that we have the correct %version

# 		      ( 'mtn', 'tag', '\'%version\'', "'$option_tag'", ),
# 		     ],
# 	condition => $option_tag,
#        },
#        {
# 	operation => [ './configure', ],
# 	condition => $option_configure,
#        },
#        {
# 	operation => [ 'make', 'clean', ],
# 	condition => $option_clean,
#        },
#        {
# 	operation => [ 'make', ],
# 	condition => $option_compile,
#        },
#        {
# 	operation => [ 'make', 'check', ],
# 	condition => $option_check,
#        },
#        {
# 	operation => [ 'make', 'dist', ],
# 	condition => $option_dist,
#        },
#        {
# 	operation => [ 'make', 'distcheck', ],
# 	condition => $option_distcheck,
#        },
#        {
# 	operation => [ 'make', '&&', 'sudo', 'make', 'install', ],
# 	condition => $option_compile && !$option_uninstall && $option_install,
#        },
#        {
# 	operation => [ 'make', 'uninstall', ],
# 	condition => $option_uninstall,
#        },
#        {
# 	operation => [ 'mtn', 'cert', '\'%version\'', '--', 'build_report', '\'%report\'', ],
# 	condition => $option_certification_report,
#        },
#       ];


my $all_packages
    = {
       developer => {
		     directory => "$ENV{HOME}/neurospaces_project/project/developer/source/snapshots/0",
		     disabled => 0,
		     order => 0,
		    },
       geometry => {
		    directory => "$ENV{HOME}/neurospaces_project/geometry/source/c/snapshots/0",
		    disabled => 1,
		    order => 4,
		   },
       heccer => {
		  directory => "$ENV{HOME}/neurospaces_project/heccer/source/c/snapshots/0",
		  disabled => 0,
		  order => 2,
		 },
       model_container => {
			   './configure' => [
					     '--with-delete-operation',
					    ],
			   directory => "$ENV{HOME}/neurospaces_project/model_container/source/c/snapshots/0",
			   disabled => 0,
			   order => 1,
			  },
       simulation_browser => {
			      directory => "$ENV{HOME}/neurospaces_project/simulation_browser/source/perl/snapshots/0",
			      disabled => 1,
			      order => 6,
			     },
       ssp => {
	       directory => "$ENV{HOME}/neurospaces_project/ssp/source/perl/snapshots/0",
	       disabled => 0,
	       order => 3,
	      },
       studio => {
		  directory => "$ENV{HOME}/neurospaces_project/studio/source/perl/snapshots/0",
		  disabled => 0,
		  order => 5,
		 },
      };


my $build_report
    = {
       description => {
		       command => $0,
		       name => "Build report",
		      },
       global => {
# 		  config => $config,
# 		  error_count => $error_count,
		  status => 'initializing',
		  test_count => 0,
		  time_start => `date`,
		 },
       client => {
		  OS => $^O,
		 },
      };


$SIG{'__DIE__'}
    = sub
      {
	  use Carp;

	  print STDERR Carp::longmess(@_);

	  $build_report->{global}->{status} = 'Died: ' . join " ", @_;

	  report_exit(3, @_);
      };


$SIG{'INT'}
    = sub
      {
	  $build_report->{global}->{status} = 'Interrupted';

	  report_exit(2);
      };


sub main
{
    read_cmd_line();

    # tell neurospaces_harness never to send emails for this

    $ENV{NEUROSPACES_HARNESS_OPTION_EMAIL} = 0;

    # set status: running

    $build_report->{global}->{status} = 'Running';

    # execute all operations

    all_operations_execute();

    # finish

    $build_report->{global}->{status} = 'Finished';

    report_exit(0);
}


sub all_operations_execute
{
    # initialize operations related matters

    $build_report->{operations} = [];

    my $operations = $build_report->{operations};

    # loop over all packages, in dependency order

    foreach my $package_name (sort
			      {
				  $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
			      }
			      keys %$all_packages)
    {
	if ($option_verbose)
	{
	    print "$0: examining $package_name\n";
	}

	my $package = $all_packages->{$package_name};

	if ($package->{disabled})
	{
	    if ($option_verbose)
	    {
		print "$0: $package_name skipped, disabled is $package->{disabled}\n";
	    }

	    next;
	}

	if ($package_name !~ /$option_regex_selector/i)
	{
	    if ($option_verbose)
	    {
		print "$0: $package_name skipped, not selected using --regex-selector\n";
	    }

	    next;
	}

	# loop over all installation operations

	foreach my $all_operation (@$all_operations)
	{
	    my $condition_value = $all_operation->{condition};

	    my $operation = $all_operation->{operation};

	    my $description = $all_operation->{description} || (join ' ', @$operation );

	    # if the uninstall option is given

	    if ($option_uninstall)
	    {
		# but this operation is not uninstall

		if (ref $operation eq 'ARRAY'
		    && exists $operation->[1]
		    && $operation->[1] ne 'uninstall')
		{
		    # don't execute, doesnot make sense

		    $condition_value = 0;

		    if ($option_verbose > 1)
		    {
			print "$0: $package_name [" . $description . "] condition turned to false \n";
		    }

		}
	    }

	    # if the operation's condition is true

	    if ($condition_value)
	    {
		if ($option_verbose > 1)
		{
		    print "$0: $package_name [" . $description . "] preparing to execute \n";
		}

		# construct package directory

		my $target_directory = $package->{directory};

		# if we are working on a client machine

		if ($option_client)
		{
		    if (!defined $option_src_dir
			|| !defined $option_src_tag)
		    {
			die "$0: you must set option_src_dir and option_src_tag when working in client mode";
		    }

		    # construct a target directory from the src-* options

		    $target_directory = $option_src_dir . "/" . $package_name . "-" . $option_src_tag;
		}

		# if package directory exists

		if (-e $target_directory)
		{
		    # if this is perl code

		    if (ref $operation eq 'CODE')
		    {
			# register that we are about to do this operation for this package

			push @$operations, { package_name => $package_name, operations => $operation, };

			if (!$option_dry_run)
			{
			    my $filename = $option_src_dir . "/" . $package_name . "-" . $option_src_tag . ".tar.gz";

			    my $url = "http://" . $option_download_server . "/neurospaces/" . $filename;

			    my $result
				= &$operation
				    (
				     {
				      filename => $filename,
				      url => $url,
				     },
				    );
			}
			else
			{
			    if ($option_verbose)
			    {
				# embedded perl code

				use Data::Dumper;

				local $Data::Dumper::Deparse = 1;

				my $perl_code = Dumper($operation);

				print "$0: $package_name [" . (join ' ', $perl_code ) . "] not executed, dry_run is $option_dry_run\n";
			    }
			}
		    }
		    else
		    {
			# go to package directory

			use Cwd;

			my $current_directory = getcwd();

			my $success = chdir $target_directory;

			if (!$success)
			{
			    die "$0: cannot change from directory ($current_directory) to directory ($target_directory): $!";
			}

			# perform the operation on the package

			my $package_options = $package->{$operation->[0]};

			operation_execute($operations, $package_name, @$operation, @$package_options);

			my $success = chdir $current_directory;

			if (!$success)
			{
			    die "$0: cannot change from directory ($target_directory) to directory ($current_directory): $!";
			}
		    }
		}
		else
		{
		    if ($option_verbose)
		    {
			print "$0: skipped $package_name [" . $description . "], directory not found, assuming this package source is not installed\n";
		    }
		}
	    }
	    else
	    {
		if ($option_verbose > 1)
		{
		    print "$0: $package_name [" . $description . "] skipped, condition_value is $condition_value\n";
		}
	    }
	}
    }
}


sub read_cmd_line
{
    my $option_help = 0;
    my $option_help_all = 0;
    my $option_packages = 0;

    my $result
	= GetOptions(
		     # options related to operation mode selection:

		     "client!" => \$option_client,
		     "developer!" => \$option_developer,

		     # operation execution profile: default is configure, compile and install

		     "certification-report!" => \$option_certification_report,
		     "check!" => \$option_check,
		     "clean!" => \$option_clean,
		     "compile!" => \$option_compile,
		     "configure!" => \$option_configure,
		     "dist!" => \$option_dist,
		     "distcheck!" => \$option_distcheck,
		     "distclean!" => \$option_distclean,
		     "distkeywords!" => \$option_distkeywords,
		     "dry-run!" => \$option_dry_run,
		     "help!" => \$option_help,
		     "help-all!" => \$option_help_all,
		     "install!" => \$option_install,
		     "packages" => \$option_packages,
		     "regex-selector=s" => \$option_regex_selector,
		     "tag=s" => \$option_tag,
		     "uninstall!" => \$option_uninstall,
		     "verbose+" => \$option_verbose,

		     # options related to installation on a client machine

		     "src-tag=s" => \$option_src_tag,
		     "src-dir=s" => \$option_src_dir,
		    );

    if (!$result)
    {
	die "$0: Error in option processing";
    }

    # process operation mode options

    #! we give client mode precedence over developer mode

    if (!$option_client
	&& !$option_developer)
    {
	$option_client = 1;
    }

    if ($option_client)
    {
	$option_developer = 0;
    }

    if ($option_developer)
    {
	$option_client = 0;
    }

    # fill in the build report

    $build_report->{options}
	= {
	   # options related to operation mode selection:

	   "client!" => $option_client,
	   "developer!" => $option_developer,

	   # operation execution profile: default is configure, compile and install

	   "certification-report!" => $option_certification_report,
	   "check!" => $option_check,
	   "clean!" => $option_clean,
	   "compile!" => $option_compile,
	   "configure!" => $option_configure,
	   "dist!" => $option_dist,
	   "distcheck!" => $option_distcheck,
	   "distclean!" => $option_distclean,
	   "distkeywords!" => $option_distkeywords,
	   "dry-run!" => $option_dry_run,
	   "help!" => $option_help,
	   "help-all!" => $option_help_all,
	   "install!" => $option_install,
	   "packages" => $option_packages,
	   "regex-selector=s" => $option_regex_selector,
	   "tag=s" => $option_tag,
	   "uninstall!" => $option_uninstall,
	   "verbose+" => $option_verbose,

	   # options related to installation on a client machine

	   "src-tag=s" => $option_src_tag,
	   "src-dir=s" => $option_src_dir,
	  };

    # merge operations with options that affect the execution of the
    # operations

    $all_operations
	= [
	   {
	    condition => $option_distclean && !$option_uninstall,
	    operation => [ 'make', 'distclean', ],
	   },
	   {
	    condition => $option_distkeywords,
	    operation => [
			  #! after keyword expansion, regenerate the
			  #! autotool related files that perhaps are
			  #! checked in.

			  ( 'make', 'dist-keywords', ),
			  ( '&&', 'make', 'clean', ),
			  ( '&&', 'make', 'clean', ),
			 ],
	   },
	   {
	    condition => $option_tag,
	    operation => [
			  ( "test", "!", '"`mtn ls unknown && mtn ls missing && mtn ls changed`"', ),
			  ( '&&', 'release-expand', "'%package'", "'%release_major'", "'%release_minor'", "'%release_micro'", "'%release_major-%release_minor'", 'hugo.cornelis@gmail.com', '--verbose', ),

			  #! after keyword expansion, regenerate the
			  #! autotool related files that perhaps are
			  #! checked in.

			  ( '&&', 'make', 'clean', ),
			  ( '&&', 'make', 'clean', ),
			  ( "&&", 'mtn', 'ci', "-m", "'1. Keywords only: $option_tag\n'", ),
			  ( "&&", "test", "!", '"`mtn ls unknown && mtn ls missing && mtn ls changed`"', ),
			 ],
	   },
	   {
	    condition => $option_tag,
	    operation => [
			  #! in a separate operation such that we have the correct %version

			  ( 'mtn', 'tag', '\'%version\'', "'$option_tag'", ),
			 ],
	   },
	   {
	    condition => $option_download_server,
	    description => "downloading",
	    operation =>
	    sub
	    {
		my $package_information = shift;

		# download the package

		use LWP::Simple;

		my $http_response = getstore($package_information->{url}, $package_information->{filename});

		if (!is_success($http_response))
		{
		    die "$0: error downloading from $option_download_server: $http_response";
		}
	    },
	   },
	   {
	    condition => $option_download_server,
	    operation => [
			  'tar', "xfz", "'%package-$option_tag.tar.gz'",
			 ],
	   },
	   {
	    condition => $option_configure,
	    operation => [ './configure', ],
	   },
	   {
	    condition => $option_clean,
	    operation => [ 'make', 'clean', ],
	   },
	   {
	    condition => $option_compile,
	    operation => [ 'make', ],
	   },
	   {
	    condition => $option_check,
	    operation => [ 'make', 'check', ],
	   },
	   {
	    condition => $option_dist,
	    operation => [ 'make', 'dist', ],
	   },
	   {
	    condition => $option_distcheck,
	    operation => [ 'make', 'distcheck', ],
	   },
	   {
	    #! always make as the regular user to avoid cluttering the
	    #! source directory with root owned files

	    condition => $option_compile && !$option_uninstall && $option_install,
	    operation => [ 'make', '&&', 'sudo', 'make', 'install', ],
	   },
	   {
	    condition => $option_uninstall,
	    operation => [ 'make', 'uninstall', ],
	   },
	   {
	    condition => $option_certification_report,
	    operation => [ 'mtn', 'cert', '\'%version\'', '--', 'build_report', '\'%report\'', ],
	   },
	  ];

    if ($option_help
        || $option_help_all)
    {
	$0 =~ m(.*/(.*));

	my $program_name = $1;

	print
	    "

$0: configure, compile, check, install, tag and build releases of
packages selected from a set of packages.

$program_name can operate in two modes: the default one is for a
client machine, assuming a user who tries to install the packages.
The second mode is for a developer who follows the Neurospaces
conventions where to put the src code of the packages.  The main
difference between the two modes is where this script finds the source
code.

$program_name creates a matrix of packages and build operations.  The
options fill in the matrix, then $program_name goes through the matrix
packages first, and performs one build operation after the other for
each package.  To find out what packages are in the database, use the
'--packages' option, to select individual packages, use the
'--regex-selector' option.  To find out about the known build
operations, use '--help'.

To disable a build stage, prefix the corresponding option with
'--no-', eg. to disable configure, use '--no-configure'.

To see what packages are known in the database, use the '--packages' option.

options related to operation mode selection:
    client                 execute in client mode (for regular users, default).
    developer              execute in developer mode.

options related to operation execution profile:
    certification-report   annotate the (monotone) repository with the build_report.
    check                  check packages.
    clean                  clean before compiling.
    configure              configure before compiling.
    compile                compile packages.
    dist                   build distribution tarballs.
    distcheck              check created tarballs.
    distclean              distclean before compiling.
    dry-run                do not execute any command, just report what would be done.
    help                   print usage information.
    help-all               print usage, all packages and all operations.
    install                install packages.
    packages               print known packages, in order of installation.
    regex-selector         defines a regex to select specific packages.
    tag                    set this tag on all packages.
    uninstall              uninstall packages, cannot be combined with installation options.
    v|verbose              tell what is being done, specify multiple times to get
                           more feedback.

options related to installation on a client machine:
    src-tag                use this tag for finding src directories on a client machine.
    src-dir                use this dir as the base for directories on a client machine.

So on a client machine, for package xxx, the src are found in the
directory <src-dir>/xxx-<src-tag>.  From there the build starts as
usual.

";

	print Dump($build_report->{options});

	if ($option_help_all)
	{
	    print Dump(
		       {
			all_packages => $all_packages,
			all_operations => $all_operations,
		       },
		      );
	}

	exit 1;
    }


    if ($option_packages)
    {
	print
	    "$0: packages in order of installation are ("
		. (
		   join
		   ' ',
		   sort
		   {
		       $all_packages->{$a}->{order} <=> $all_packages->{$b}->{order}
		   }
		   grep
		   {
		       $_ =~ /$option_regex_selector/i
		   }
		   keys %$all_packages
		  )
		    . ")\n";

	exit 1;
    }


}


sub report_exit
{
    my $exit_code = shift;

    my $description = shift;

    $build_report->{global}->{time_end} = `date`;

    if (defined $description
        && $exit_code eq 3)
    {
	print "*** die: $description\n";
    }

    # yaml out the test report

    print Dump($build_report);

    # if there were errors

#     if ($error_count)
#     {
# 	# exit with failure

# 	$exit_code ||= 1;

# 	print "$0: exit_code $exit_code\n";

# 	exit $exit_code;
#     }

#     # else

#     else
    {
	# exit, possibly success

	exit $exit_code;
    }
}


sub report_message
{
    my $header = shift;

    my $trailer = shift;

    my $message = shift;

    my $lines = [ split '\n', $message, ];

    my $longest = 0;

    map
    {
	($longest < length) && ($longest = length)
    }
	@$lines;

    my $line = '-' x $longest;

    print "\n";
    print "$line\n" for 0 .. $header;
    print "\n";
    print "$message\n\n";
    print "$line\n" for 0 .. $trailer;
    print "\n";
}


sub operation_execute
{
    my $operations = shift;

    my $package_name = shift;

    my $arguments = [ @_ ];

    # get monotone id

    my $monotone_id = `mtn automate get_base_revision_id`;

    chomp $monotone_id;

    # define release labels

    #! copied from release-extract

    my $log = [ `mtn log --last 1`, ];

#     my $monotone_id
# 	= [
# 	   map
# 	   {
# 	       s/.*Revision:\s*//;

# 	       s/\s*//g;

# 	       $_;
# 	   }
# 	   grep
# 	   {
# 	       m'Revision:';
# 	   }
# 	   @$log,
# 	  ];

    my $release_label = $option_tag;

    $release_label =~ m/([^-]+)-([^-]+)?(?:-([^-]+))?/;

    my $release_major = $1 || $monotone_id;

    my $release_minor = $2 || 0;

    my $release_micro = $3 || 0;

    $arguments
	= [
	   map
	   {
	       s/%package/$package_name/g;
	       s/%release_major/$release_major/g;
	       s/%release_micro/$release_micro/g;
	       s/%release_minor/$release_minor/g;
	       s/%version/$monotone_id/g;

	       $_;
	   }
	   @$arguments,
	  ];

    #! to prevent monotone from interpreting the yaml as an option,
    #! we prefix the report with something that does not look like an
    #! option.

    my $report_text = Dump( { build_report => $build_report, }, ) . "\n";

    $arguments
	= [
	   map
	   {
	       s/%report/$report_text/g;

	       # replace non-LDH characters: underscores

	       s/_/-/g;

	       $_;
	   }
	   @$arguments,
	  ];

    # register that we are about to do this operation for this package

    push @$operations, { package_name => $package_name, operations => $arguments, };

    if (!$option_dry_run)
    {
	print "$0: $package_name [" . (join ' ', @$arguments) . "] executing\n";

	system join " ", @$arguments;

	if ($?)
	{
	    #! assume system has given a good error message

	    die "*** Error for package_name $package_name: $?";
	}

	if ($option_verbose)
	{
	    print "$0: $package_name [" . (join ' ', @$arguments ) . "] executed \n";
	}
    }
    else
    {
	if ($option_verbose)
	{
	    print "$0: $package_name [" . (join ' ', @$arguments ) . "] not executed, dry_run is $option_dry_run\n";
	}
    }
}


main();


