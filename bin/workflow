#!/usr/bin/perl -w

use strict;

use warnings;

use Data::Dumper;

$Data::Dumper::Sortkeys = 'always';

use Getopt::Long qw(GetOptionsFromArray);;


$SIG{'__DIE__'}
    = sub
      {
	  require Carp;

	  print STDERR Carp::longmess(@_);
      };


$SIG{'INT'}
    = sub
      {
	  require Carp;

	  print STDERR Carp::longmess(@_);

	  exit 1;
      };


our $option_bash_completion;
our $option_branch = "master";
our $option_build_server;
our $option_built_image_directory;
our $option_commands = [];
our $option_dry_run = '';
our $option_dump_all_interaction_roles;
our $option_dump_interaction_roles;
our $option_dump_module_interaction_roles;
our $option_dump_schedule;
our $option_dump_specific_workflow_roles;
our $option_export_remote;
our $option_export_sh;
our $option_export_sudo;
our $option_export_times;
our $option_export_verbose;
our $option_force_rebuild;
our $option_forward_destination_server = "laptop";
our $option_forward_source_server = "laptop";
our $option_help;
our $option_help_build_servers;
our $option_help_commands;
our $option_help_field_project_name;
our $option_help_options;
our $option_help_packages;
our $option_help_projects;
our $option_help_targets;
our $option_incremental = 1;
our $option_interactions;
our $option_interactions_all;
our $option_interactions_module;
our $option_packages = [];
our $option_remote = "gitlab";
our $option_ssh_server;
our $option_ssh_port;
our $option_ssh_user;
our $option_tftp_directory;
our $option_target;
our $option_verbose;

our $global_options
    = {
       "bash-completion=s" => \$option_bash_completion,
       "branch=s" => \$option_branch,
       "build-server=s" => \$option_build_server,
       "built-image-directory=s" => \$option_built_image_directory,
       "command=s" => $option_commands,
       "dry-run!" => \$option_dry_run,
       "dump-all-interaction-roles!" => \$option_dump_all_interaction_roles,
       "dump-interaction-roles!" => \$option_dump_interaction_roles,
       "dump-module-interaction-roles!" => \$option_dump_module_interaction_roles,
       "dump-schedule!" => \$option_dump_schedule,
       "export-remote=s" => \$option_export_remote,
       "export-sh:s" => \$option_export_sh,
       "export-sudo" => \$option_export_sudo,
       "export-times!" => \$option_export_times,
       "export-verbose!" => \$option_export_verbose,
       "force-rebuild!" => \$option_force_rebuild,
       "forward-destination-server=s" => \$option_forward_destination_server,
       "forward-source-server=s" => \$option_forward_source_server,
       "help!" => \$option_help,
       "help-build-servers!" => \$option_help_build_servers,
       "help-commands!" => \$option_help_commands,
       "help-field-project-name!" => \$option_help_field_project_name,
       "help-options!" => \$option_help_options,
       "help-packages!" => \$option_help_packages,
       "help-projects!" => \$option_help_projects,
       "help-targets!" => \$option_help_targets,
       "incremental!" => \$option_incremental,
       "interactions!" => \$option_interactions,
       "interactions-all!" => \$option_interactions_all,
       "interactions-module!" => \$option_interactions_module,
       "package=s" => $option_packages,
       "ssh-port=s" => \$option_ssh_port,
       "ssh-server=s" => \$option_ssh_server,
       "ssh-user=s" => \$option_ssh_user,
       "target=s" => \$option_target,
       "tftp-directory=s" => \$option_tftp_directory,
       "v|verbose+" => \$option_verbose,
      };

our $global_command_line = join " ", $0, @ARGV;
our $global_overriden_packages;
our $global_program_abs_directory;
our $global_program_rel_directory;
our $global_program_name;
our $global_scheduled_commands = [];

{
    use Cwd;

    ($0 =~ m((.*)/(\S+)));

    $global_program_rel_directory = $1;
    # $global_program_name = $2;

    my $program_name_full = $0;

    my $program_name_full_abs = Cwd::abs_path($program_name_full);

    ($program_name_full_abs =~ m((.*)/(\S+)));

    $global_program_abs_directory = $1;

    ($0 =~ m((.*)/(\S+)));

    $global_program_name = $2;
}


our $global_target_command;

our $global_field_project_configuration;

our $global_technical_project_configuration;


package Command;


sub execute_shell_command
{
    return Engine::execute_shell_command(@_);
}


sub execute_shell_command_array
{
    return Engine::execute_shell_command_array(@_);
}


sub execute_shell_command_schedule
{
    return Engine::execute_shell_command_schedule(@_);
}


sub execute_shell_command_schedule_array
{
    return Engine::execute_shell_command_schedule_array(@_);
}


sub execute_shell_script
{
    my $filename = shift;

    # assumes $/ has its default value of a newline

    use IO::File;

    my $file = IO::File->new("<$filename");

    if (not $file)
    {
	die "$0: *** Error: no valid commands available in file '$filename'\n";
    }

    my $commands
	= [
	   map
	   {
	       chomp; $_;
	   }
	   <$file>,
	  ];

    # use Data::Dumper;

    # print Dumper($commands);

    return Engine::execute_shell_command_array($commands, @_);
}


# given a local script filename, execute the script remotely

sub execute_shell_script_remote
{
    my $local_filename_arguments = shift;

    my $options = shift;

    $local_filename_arguments =~ m(^(\S+)(\s+(.*))?$);

    my $local_filename = $1;

    my $arguments = $3;

    if (not -e $local_filename)
    {
	die "$0: *** Error: no valid script file '$local_filename'\n";
    }

    my $remote = $options->{remote};

    my $remote_and_interaction_role = Engine::compute_remote_and_interaction_role("", $remote, "scp");

    my $ssh_options = $remote_and_interaction_role->{ssh_options} || "";

#    my $remote_prefix = $remote_and_interaction_role->{remote_prefix};

    my $interaction_role_with_policy_syntax = $remote_and_interaction_role->{interaction_role_with_policy_syntax} || "";

    use File::Spec;

    my ($volume, $directories, $remote_filename) = File::Spec->splitpath( $local_filename );

    $remote_filename = "/tmp/$remote_filename";

    # copy the local file to the remote

    my $scp_command = "scp -pr $ssh_options $local_filename $interaction_role_with_policy_syntax$remote_filename";

    # execute_shell_command($scp_command, { %$options, remote => undef, }, @_);
    execute_shell_command($scp_command, { remote => undef, }, @_);

    # execute the remote file with the remote role

    return Engine::execute_shell_command("$remote_filename $arguments", $options, @_);
}


sub _init
{
    my $commands_seen;

    my $field_project_name = $global_field_project_configuration->{field_project_name};

    my $command_filenames_found
	= [
	   grep
	   {
	       /$field_project_name-commands[-a-z0-9]*$/;
	   }
	   map
	   {
	       chomp; $_;
	   }
	   `ls $global_program_rel_directory/$field_project_name-commands*`,
	  ];

    my $command_filenames_configured
	= [
	   grep
	   {
	       /$field_project_name-commands[-a-z0-9]*$/;
	   }
	   map
	   {
	       "$global_program_rel_directory/$_";
	   }
	   @{ $global_technical_project_configuration->{command_filenames} },
	  ];

    my $command_filenames
	= [
	   grep
	   {
	       not $commands_seen->{$_}++;
	   }
	   @$command_filenames_configured,
	   #        @$command_filenames_found,
	  ];

    foreach my $command_filename (@$command_filenames)
    {
	my $commands = do $command_filename;

	if ($@)
	{
	    die "$0: *** Error: no valid commands file '$command_filename' found ($@)\n";
	}

	if ($!)
	{
	    die "$0: *** Error: no commands file '$command_filename' found ($!)\n";
	}
    }
}


package Engine;


our $global_exported_sh_file;

our $global_exported_sh_filename;

our $global_exported_times_file;

our $global_exported_times_filename;


# note: keys are interaction_roles, values are working directories

our $global_remote_working_directory = {};


sub working_directory_for_interaction_role_apply
{
    my $interaction_role = shift;

    my $command = shift;

    my $result = $command;

    if ($interaction_role ne "localuser\@localhost")
    {
	my $current_working_directory = $global_remote_working_directory->{$interaction_role};

	if (defined $current_working_directory)
	{
	    $result = "'cd $current_working_directory && $command'";
	}
    }

    return $result;
}


# keep track of the possibly remote working directory

sub _working_directory_for_interaction_role_change
{
    my $interaction_role = shift;

    my $working_directory = shift;

    my $current_working_directory = $global_remote_working_directory->{$interaction_role};

    if (not defined $current_working_directory
	and $interaction_role eq 'localuser@localhost')
    {
	$current_working_directory = '.';
    }
    else
    {
	$current_working_directory = '~';
    }

    use File::Spec;

    my $is_absolute = File::Spec->file_name_is_absolute( $working_directory );

    my $new_working_directory;

    if ($is_absolute)
    {
	$new_working_directory = $working_directory;
    }
    else
    {
	if (not defined $current_working_directory)
	{
	    die "*** Error: $0: current_working_directory not defined when parsing directories for interaction role '$interaction_role'.";
	}

	if (not defined $working_directory)
	{
	    die "*** Error: $0: working_directory not defined when parsing directories for interaction role '$interaction_role'.";
	}

	$new_working_directory = File::Spec->catdir( $current_working_directory, $working_directory );
    }

    $global_remote_working_directory->{$interaction_role} = $new_working_directory;
}


sub working_directory_for_interaction_role_parse
{
    my $executable_command = shift;

    my $dry_run = shift;

    my $interaction_role = shift;

    my $arguments;

    # if this is a chdir executable_command

    if ($executable_command =~ /^\s*chdir\s+(.*)$/
	or $executable_command =~ /^\s*cd\s*$/
	or $executable_command =~ /^\s*cd\s+(.*)$/)
    {
	# process its arguments

	my $arguments = $1 || "";

	# remove quotes, they are invalid in directory names for the purpose of this script

	$arguments =~ s/^'//g;
	$arguments =~ s/'$//g;

	# some forms of chdir require an argument,
	# some forms of cd don't and use a default of $HOME

	if ($arguments =~ /^\s*$/)
	{
	    $arguments = $ENV{HOME};
	}

	$executable_command = "cd $arguments";

	# keep track of the possibly remote working directory

	_working_directory_for_interaction_role_change($interaction_role, $arguments);
    }
    else
    {
#  	$executable_command = working_directory_for_interaction_role_apply($interaction_role, $executable_command);
    }

    # return the possibly processed result

    return $executable_command;
}


sub build_tree_needs_rebuild
{
    my $build_tree = shift;

    my $options = shift;

    my $result = "default is to rebuild";

    my $remote_prefix = $options->{remote_prefix};

    if ($option_force_rebuild)
    {
	if ($option_verbose
	    and $option_verbose > 1)
	{
	    print STDERR "build_tree_needs_rebuild(): option_force_rebuild is set\n";
	}

	return "option_force_rebuild";
    }

    # if we have sources and targets

    if ($build_tree->{sources}
	and $build_tree->{targets})
    {
	# determine the youngest source file

	my $source_youngest = 0;

	my $sources = $build_tree->{sources};

	foreach my $source (@$sources)
	{
	    #! %Y gives second accuracy, %y gives a higher resolution
	    #! but its output requires more parsing

	    my $source_stat_command = 'stat --format="%Y" ' . "'$source'";

	    if ($remote_prefix)
	    {
		$source_stat_command = "$remote_prefix   $source_stat_command";
	    }

	    my $source_stat_output = `$source_stat_command 2>/dev/null`;

	    if ($option_verbose
		and $option_verbose > 1)
	    {
		print STDERR "build_tree_needs_rebuild(): source_stat_output: $source_stat_output ($source)\n";
	    }

	    if ($?)
	    {
		return 1;
	    }

	    # the youngest source file is the one with the highest seconds value

	    if ($source_stat_output > $source_youngest)
	    {
		$source_youngest = $source_stat_output;
	    }
	}

	# determine the oldest target file

	my $target_oldest = 16127117390; # GMT: Friday, January 17, 2481 10:49:50 AM

	my $targets = $build_tree->{targets};

	foreach my $target (@$targets)
	{
	    #! %Y gives second accuracy, %y gives a higher resolution
	    #! but its output requires more parsing

	    my $target_stat_command = 'stat --format="%Y" ' . "'$target'";

	    if ($remote_prefix)
	    {
		$target_stat_command = "$remote_prefix   $target_stat_command";
	    }

	    my $target_stat_output = `$target_stat_command 2>/dev/null`;

	    if ($option_verbose
		and $option_verbose > 1)
	    {
		print STDERR "build_tree_needs_rebuild(): target_stat_output: $target_stat_output ($target)\n";
	    }

	    if ($?)
	    {
		return 1;
	    }

	    # the oldest target file is the one with the smallest seconds value

	    if ($target_stat_output < $target_oldest)
	    {
		$target_oldest = $target_stat_output;
	    }
	}

	# if the youngest source file is younger than the oldest target file

	if ($source_youngest >= $target_oldest)
	{
	    # we need to rebuild

	    $result = 1;
	}

	# else all the target files  are younger than the youngest source file

	else
	{
	    # so we don't need to rebuild

	    $result = 0;
	}

	if ($option_verbose
	    and $option_verbose > 1)
	{
	    print STDERR "build_tree_needs_rebuild(): source_youngest: $source_youngest, target_oldest: $target_oldest ==> needs_rebuild: $result\n";
	}

    }

    # return result

    return $result;
}


sub display_commented_command
{
    my $command = shift;

    my $options = shift;

    if (not $options->{quiet})
    {
	# print "# $command (length: $command_length)\n#\n";

	print "# $command\n#\n";
    }
}


our $interaction_roles = {};

my $current_interaction_role;


# apply the remoting prefix

sub apply_remote_record_exported_command
{
    my $remote_prefix = shift;

    my $command = shift;

    my $export_remote = shift;

    my $export_sh_command = shift;

    if ($remote_prefix)
    {
	# if we are exporting this one role

	if (defined $export_remote
	    and (($export_remote eq $interaction_roles->{$current_interaction_role}->{name})
		 or $export_remote eq $interaction_roles->{$current_interaction_role}->{number}))
	{
	    # we export the command without the remoting information

	    $export_sh_command = $command;
	}

	# this is a command for a different role

	else
	{
	    # export as a comment

	    $export_sh_command = "# <remote command at $remote_prefix: $command>";
	}

	$command = "$remote_prefix   $command";

	# if we are exporting all roles

	if (defined $export_remote
	    and ($export_remote eq 0))
	{
	    # we export the command with the remoting information prefixed

	    $export_sh_command = $command;
	}
    }

    return ($command, $export_sh_command);
}


# apply the sudo prefix

sub apply_sudo
{
    my $sudo_prefix = shift;

    my $command = shift;

    my $option_export_sudo = shift;

    my $export_sh_command = shift;

    if ($sudo_prefix)
    {
	$command = "$sudo_prefix   $command";

	if ($option_export_sudo)
	{
	    $export_sh_command = $command;
	}
    }

    return ($command, $export_sh_command);
}


# apply the timeout prefix

sub apply_timeout
{
    my $timeout_prefix = shift;

    my $command = shift;

    my $option_export_timeout = shift;

    my $export_sh_command = shift;

    if ($timeout_prefix)
    {
	$command = "$timeout_prefix   $command";

	$export_sh_command = $command;
    }

    return ($command, $export_sh_command);
}


sub compute_remote_and_interaction_role
{
    my $command = shift;

    my $option_remote = shift;

    my $remote_policy = shift || "ssh";

    # default result: an empty string

    my $remote_prefix = "";

    my $interaction_role;

    my $interaction_role_with_policy_syntax;

    my $ssh_options;

    if ($option_remote)
    {
	# if we need to skip remoting for this command?

	if (exists $option_remote->{skip}
	    and $command =~ /$option_remote->{skip}/)
	{
	    # use the localuser interaction role to prevent remoting

	    $interaction_role = "localuser\@localhost";
	}

	# if this is the local account

	elsif (exists $option_remote->{localuser}
	       and $option_remote->{localuser} eq 'yes')
	{
	    # use the localuser interaction role to prevent remoting

	    $interaction_role = "localuser\@localhost";
	}

	# else construct the remote role

	else
	{
	    if (exists $option_remote->{ssh_password})
	    {
		my $ssh_password = $option_remote->{ssh_password};

		$remote_prefix .= "sshpass -p $ssh_password ";
	    }

	    if (exists $option_remote->{ssh_options})
	    {
		$interaction_role = "";

		$ssh_options = $option_remote->{ssh_options};

		if (exists $option_remote->{ssh_server})
		{
		    my $ssh_server = $option_remote->{ssh_server};

		    my $remote_role = exists $option_remote->{name} ? $option_remote->{name} : $ssh_server;

		    if (exists $option_remote->{ssh_user})
		    {
			my $ssh_user = $option_remote->{ssh_user};

			$interaction_role = "$ssh_user\@$remote_role";

			$remote_prefix .= "$remote_policy $ssh_options $ssh_user\@$ssh_server ";

			# either ssh syntax ...

			if ($remote_policy eq 'ssh')
			{
			    $interaction_role_with_policy_syntax = "$ssh_user\@$ssh_server";
			}

			# ... or scp syntax (the filename should be appended -- is this clumsy?)

			else
			{
			    $interaction_role_with_policy_syntax = "$ssh_user\@$ssh_server:";
			}
		    }
		    else
		    {
			$interaction_role = $remote_role;

			$remote_prefix .= "$remote_policy $ssh_options $ssh_server ";
		    }
		}
		else
		{
		    $interaction_role = "localuser\@localhost";

		    $remote_prefix .= "$remote_policy $ssh_options ";
		}
	    }
	    else
	    {
		$interaction_role = "localuser\@localhost";
	    }

	    if (defined $option_verbose and $option_verbose > 1)
	    {
		print STDERR "$0: *** result is $remote_prefix\n";
	    }
	}
    }

    # else no remoting information

    else
    {
	# track the interaction role

	$interaction_role = "localuser\@localhost";
    }

    $current_interaction_role = $interaction_role;

    # return result

    return
    {
     interaction_role => $current_interaction_role,
     interaction_role_with_policy_syntax => $interaction_role_with_policy_syntax,
     remote_prefix => $remote_prefix,
     ssh_options => $ssh_options,
    };
}


# prefix the given command with appropriate sudo options.

sub compute_sudo
{
    my $command = shift;

    my $option_sudo = shift;

    # default result: an empty string

    my $result = "";

    if ($option_sudo)
    {
	my $sudo_pattern
	    = (exists $option_sudo->{pattern}
	       ? $option_sudo->{pattern}
	       : '.*');

	# if we need to skip sudo information

	if (exists $option_sudo->{skip}
	    and $command =~ /$option_sudo->{skip}/)
	{
	}

	# else construct the sudo command

	elsif ($command =~ /$sudo_pattern/)
	{
	    $result .= "sudo ";

	    if (exists $option_sudo->{options})
	    {
		$result .= "$option_sudo->{options} ";
	    }
	}
    }

    # return result

    return $result;
}


# prefix the command with appropriate timeout options

sub compute_timeout
{
    my $command = shift;

    my $option_timeout = shift;

    # default result: an empty string

    my $result = "";

    if ($option_timeout)
    {
	# if we need to skip timeout information

	if (exists $option_timeout->{skip}
	    and $command =~ /$option_timeout->{skip}/)
	{
	}

	# else construct the timeout command

	else
	{
	    if (exists $option_timeout->{sudo}
		and $option_timeout->{sudo} eq 1)
	    {
		$result .= "sudo ";
	    }

	    $result .= "timeout ";

	    if (exists $option_timeout->{options})
	    {
		$result .= "$option_timeout->{options} ";
	    }

	    if (not exists $option_timeout->{duration})
	    {
		die "*** Error: $0: the timeout option of '$command' does not have the mandatory duration specified";
	    }

	    $result .= "$option_timeout->{duration} ";
	}
    }

    # return result

    return $result;
}


sub execute_option_dry_run
{
    my $scheduled_command = shift;

    my $command = $scheduled_command->{command};

    my $dry_run = $scheduled_command->{dry_run};

    my $executable_command = $scheduled_command->{executable_command};

    my $export_sh = $scheduled_command->{export_sh};

    my $interaction_role = $scheduled_command->{interaction_role};

    my $options = $scheduled_command->{options};

    if ($export_sh
	and exists $export_sh->{prefix})
    {
	my $dry_run_prefix = "$0: *** Running in dry_run mode, export prefix: '";

	print map { "$dry_run_prefix$_\n" } split "\n", $export_sh->{prefix};
    }

    if ($dry_run =~ /^[0-9]+$/)
    {
	print "$0: *** Running in dry_run $dry_run mode, not executing: '$command'\n";
    }

    if ($executable_command =~ /cd\s+(.*)$/)
    {
	my $arguments = $1;

	my $exit_status = not chdir $arguments;
    }
    else
    {
	#! should die here?
    }
}


sub identify_interaction_roles
{
    my $command = shift;

    my $executable_command = shift;

    my $indent_delta = 40;

    if (exists $interaction_roles->{$current_interaction_role})
    {
    }
    elsif ($option_interactions_all)
    {
	my $target_servers = $global_technical_project_configuration->{target_servers};

	my $interaction_indent = 4;

	my $interaction_number = 1;

	$interaction_roles
	    = {
	       map
	       {
		   my $target = $_;

		   my $result
		       = {
			  $target => {
				      indent => $interaction_indent,
				      is_new_and_needs_header => 'yes',
				      name => $target,
				      number => $interaction_number,
				     },
			 };

		   $interaction_number += 1;

		   $interaction_indent += 24;

		   %$result;
	       }
	       sort
	       {
		   # make sure that localhost always comes first

		   if ($a =~ /local/)
		   {
		       return -1;
		   }
		   elsif ($b =~ /local/)
		   {
		       return 1;
		   }
		   else
		   {
		       $a cmp $b;
		   }
	       }
	       map
	       {
		   my $target_server_key = $_;

		   my $target_server = $target_servers->{$target_server_key};

		   my $result;

		   if (exists $target_server->{localuser}
		       and $target_server->{localuser} eq 'yes')
		   {
		       $result = "localuser\@localhost";
		   }
		   else
		   {
		       my $target_server_name = $target_server->{name} || $target_server->{ssh_server} || 'localhost';

		       my $target_user = $target_server->{ssh_user} || 'localuser';

		       $result = $target_user . '@' . $target_server_name;
		   }

		   $result;
	       }
	       keys %$target_servers,
	      };
    }
    else
    {
	my $sorted_roles = [ keys %$interaction_roles, ];

	my $interaction_indent = 4 + scalar @$sorted_roles * $indent_delta;

	$interaction_roles->{$current_interaction_role}
	    = {
	       indent => $interaction_indent,
	       is_new_and_needs_header => 'yes',
	       name => $current_interaction_role,
	       number => (scalar @$sorted_roles) + 1,
	      };
    }
}


sub execute_option_interactions
{
    my $scheduled_command = shift;

    my $all = shift;

    my $command = $scheduled_command->{command};

    my $executable_command = $scheduled_command->{executable_command};

    my $interaction_role_arg = $scheduled_command->{interaction_role};

    if (not defined $interaction_role_arg)
    {
	# use Data::Dumper;

	# print Dumper( { interaction_roles => $interaction_roles, }, );

	die "*** Error: $0: option_interactions cannot compute an indentation level without a valid interaction role (is '$interaction_role_arg')";
    }

    if ($all)
    {
	foreach my $interaction_role_name (sort
					   {
					       $interaction_roles->{$a}->{number} <=> $interaction_roles->{$b}->{number};
					   }
					   keys %$interaction_roles)
	{
	    my $interaction_role = $interaction_roles->{$interaction_role_name};

	    if ($interaction_role->{is_new_and_needs_header} eq 'yes')
	    {
		_print_interaction_header($interaction_role);
	    }
	}
    }

    if ($interaction_role_arg eq 'none')
    {
	print "$command\n";
    }
    else
    {
	my $interaction_role = $interaction_roles->{$interaction_role_arg};

	if ($interaction_role->{is_new_and_needs_header} eq 'yes')
	{
	    _print_interaction_header($interaction_role);
	}

	if ($executable_command !~ /^\s*$/)
	{
	    my $interaction_indent = $interaction_role->{indent};

	    my $indent = " " x $interaction_indent;

	    print "$indent'$executable_command'\n";
	}
    }
}


sub _print_interaction_header
{
    my $interaction_role = shift;

    my $interaction_role_name = $interaction_role->{name};

    my $interaction_indent = $interaction_roles->{$interaction_role_name}->{indent};

    my $indent = " " x $interaction_indent;

    my $header = "${indent}ROLE: '$interaction_role_name'";

    $interaction_role->{is_new_and_needs_header} = $header;

    print "$header\n\n";
}


sub execute_option_export_sh
{
    my $scheduled_command = shift;

    my $executable_command = $scheduled_command->{executable_command};

    my $export_sh = $scheduled_command->{export_sh};

    my $export_sh_command = $scheduled_command->{export_sh_command};

    my $interaction_role = $scheduled_command->{interaction_role};

    if (not defined $global_exported_sh_file)
    {
	if (not defined $global_exported_sh_filename)
	{
	    $global_exported_sh_filename = $export_sh->{filename};
	}

	my $ok = open($global_exported_sh_file, ">", $global_exported_sh_filename);

	if (not $ok)
	{
	    die "*** Error: $0: cannot open $global_exported_sh_filename for writing ($!)";
	}

	print $global_exported_sh_file "#!/bin/sh\n";
	print $global_exported_sh_file "#\n";
	print $global_exported_sh_file "# script generated with $::global_program_name\n";
	print $global_exported_sh_file "#\n";
	print $global_exported_sh_file "# the command line to generate this script was:\n";
	print $global_exported_sh_file "#\n";
	print $global_exported_sh_file "# $global_command_line\n";
	print $global_exported_sh_file "#\n";

	chmod 0755, $global_exported_sh_filename;
    }

    if ($export_sh_command =~ /cd\s+(.*)$/)
    {
	my $arguments = $1;

	my $exit_status = not chdir $arguments;
    }
    else
    {
	#! should die here?
    }

    if ($export_sh_command =~ /^'/
	and $export_sh_command =~ /'$/)
    {
	$export_sh_command =~ s/^'//;
	$export_sh_command =~ s/'$//;
    }

    print "$0: *** Running in export_sh mode, exporting: '$export_sh_command'\n";

    if ((not defined $option_export_remote or $option_export_remote eq 0)
	or $option_export_remote eq $interaction_roles->{$interaction_role}->{name}
	or $option_export_remote eq $interaction_roles->{$interaction_role}->{number})
    {
	if ($option_export_verbose)
	{
	    print $global_exported_sh_file "echo '$export_sh_command'\n";
	}

	if (exists $export_sh->{prefix})
	{
	    print $global_exported_sh_file $export_sh->{prefix};
	}

	print $global_exported_sh_file "$export_sh_command\n";
    }
    else
    {
	print $global_exported_sh_file "$export_sh_command\n";
    }
}


sub execute_scheduled_command
{
    my $scheduled_command = shift;

    my $command = $scheduled_command->{command};

    my $dry_run = $scheduled_command->{dry_run};

    my $executable_command = $scheduled_command->{executable_command};

    my $interaction_role = $scheduled_command->{interaction_role};

    my $options = $scheduled_command->{options};

    my $exit_status;

    #! note that the \s+ is a bug: it forces the use of white-space when no arguments are given

    #! note the difference in processing and exit status for a local cd vs a remote cd

    if ($interaction_role eq 'localuser@localhost'
	and $executable_command =~ /cd\s+(.*)$/)
    {
	my $arguments = $1;

	display_commented_command($command, $options);

	$exit_status = not chdir $arguments;
    }
    elsif ($dry_run)
    {
	execute_option_dry_run($scheduled_command);
    }
    else
    {
	my $export_output = $options->{export_output};

	my $export_times = $options->{export_times};

	if ($export_times)
	{
	    if (not defined $global_exported_times_file)
	    {
		if (not defined $global_exported_times_filename)
		{
		    $global_exported_times_filename = $export_times->{filename};
		}

		my $ok = open($global_exported_times_file, ">", $global_exported_times_filename);

		if (not $ok)
		{
		    die "*** Error: $0: cannot open $global_exported_times_filename for writing ($!)";
		}

		print $global_exported_times_file "#!/bin/sh\n";
		print $global_exported_times_file "#\n";
		print $global_exported_times_file "# script generated with $::global_program_name\n";
		print $global_exported_times_file "#\n";
		print $global_exported_times_file "# the command line to generate this script was:\n";
		print $global_exported_times_file "#\n";
		print $global_exported_times_file "# $global_command_line\n";
		print $global_exported_times_file "#\n";

		chmod 0644, $global_exported_times_filename;
	    }
	}

	# execute the command, collect start and end time

	use IPC::System::Simple qw(capture);

	my $start_time = time();

	my $output = "";

	my $command_is_empty = $executable_command =~ /^\s*$/ ? 'yes' : '';

	if (not $command_is_empty)
	{
	    if (not $export_output)
	    {
		display_commented_command($command, $options);

		$exit_status = system "$command";
	    }
	    else
	    {
		$output .= capture($command);

		$exit_status = $IPC::System::Simple::EXITVAL;
	    }
	}

	my $end_time = time();

	if ($export_times)
	{
	    print $global_exported_times_file "$0: *** Starting ('$command') at " . localtime($start_time) . "\n";

	    print $global_exported_times_file "$0: *** Ended    ('$command') at " . localtime($end_time) . "\n";

	    print $global_exported_times_file "$0: *** Duration (s): " . ($end_time - $start_time) . "\n";

	    print $global_exported_times_file "\n";
	}

	if ($export_output)
	{
	    my $filename = generate_output_filename($global_target_command, $command);

	    my $output_file;

	    my $ok = open($output_file, ">", $filename);

	    if (not $ok)
	    {
		die "*** Error: $0: cannot open $filename for writing ($!)";
	    }

	    print $output_file "# $command\n#\n";

	    print $output_file $output;

	    close($output_file);
	}
	# else
	# {
	# 	print $output;
	# }
    }

    my $output_path = $options->{output_path};

#     my $exit_status = system "( $command ) >>$output_path 2>&1";

    if ($exit_status)
    {
	my $allow_fail = $options->{allow_fail};

	if ($allow_fail)
	{
# 	    system "echo >>$output_path 2>&1 failed with $exit_status: $command\n";

	    print "$0: *** Note: $command was allowed to fail (because $allow_fail) and has exit status $exit_status\n";
	}
	else
	{
	    die "$0: *** Fatal: $command failed with exit status $exit_status\n";
	}
    }

    # return the result of command execution

    return $exit_status;
}


sub schedule_real_command
{
    my $command = shift;

    my $executable_command = shift;

    my $options = shift;

    my $dry_run = shift;

    my $export_sh = shift;

    my $export_sh_command = shift;

    my $scheduled_command
	= {
	   command => $command,
	   dry_run => $dry_run,
	   executable_command => $executable_command,
	   export_sh => $export_sh,
	   export_sh_command => $export_sh_command,
	   interaction_role => $current_interaction_role,
	   options => $options,
	  };

    push @$global_scheduled_commands, $scheduled_command;
}


sub execute_all_scheduled_commands
{
    if ($option_dump_schedule)
    {
	use Data::Dumper;

	print Dumper( { scheduled_commands => $global_scheduled_commands, }, );
    }
    elsif ($option_dump_interaction_roles)
    {
	use Data::Dumper;

	print Dumper( { interaction_roles => $interaction_roles, }, );
    }
    elsif ($option_dump_module_interaction_roles)
    {
	print Dumper( { interaction_roles => $interaction_roles, }, );
    }
    else
    {
	foreach my $scheduled_command (@$global_scheduled_commands)
	{
	    # we are either in dry-run ...

	    if ($option_dry_run =~ /^[0-9]+$/)
	    {
		execute_option_dry_run($scheduled_command);
	    }

	    # ... or printing an interaction diagram

	    elsif ($option_interactions
		   or $option_interactions_all
		   or $option_interactions_module)
	    {
		execute_option_interactions($scheduled_command, $option_interactions_all);
	    }

	    # ... or exporting to an executable shell script ...

	    elsif (defined $option_export_sh)
	    {
		execute_option_export_sh($scheduled_command);
	    }

	    # or real-time executing the scheduled command

	    else
	    {
		execute_scheduled_command($scheduled_command);
	    }
	}
    }
}


sub execute_shell_command
{
    my $command = shift;

    my $options = shift;

    # keep a record of the command that will be executed

    my $executable_command = $command;

    $executable_command =~ s(^\s*#.*)()g;

    my $command_length = length $executable_command;

    # option preprocessing

    my $verbose = $options->{verbose} || $option_verbose;

    # the command to be exported defaults to the command given

    my $export_sh_command = defined $option_export_sh ? $command : undef;

    if (defined $verbose
	and $verbose =~ /^[0-9]+$/)
    {
	$verbose = "*** INFO: ";
    }

    # start of meta option and information processing

    # if exporting to a script for this command

    my $export_sh = $options->{export_sh};

    if (not defined $export_sh)
    {
	if (defined $option_export_sh)
	{
	    $export_sh = { filename => $option_export_sh, };
	}
    }
    else
    {
	# if globally exporting all commands

	if (defined $option_export_sh)
	{
	    $export_sh->{filename} = $option_export_sh;
	}
    }

    # if we are not exporting timing information specifically for this command

    my $export_times = $options->{export_times};

    if (not defined $export_times)
    {
	# are we globally exporting all timing information?

	if (defined $option_export_times)
	{
	    # configure the export_times option

	    $export_times = { filename => $option_export_times, };
	}
	else
	{
	    # we are not exporting any timing information
	}
    }

    # if we are exporting timing information specifically for this command

    else
    {
	# if globally exporting all timing information to the same file

	if (defined $option_export_times)
	{
	    # set the shared filename

	    $export_times->{filename} = $option_export_times;
	}
	else
	{
	    # use the filename set in the command specific options
	}
    }

    # start of peripheral option and command processing

    # if there is remoting information

    my $remote_and_interaction_role = compute_remote_and_interaction_role($command, $options->{remote});

    my $remote_prefix = $remote_and_interaction_role->{remote_prefix};

    # define the interaction roles

    identify_interaction_roles($command, $executable_command);

    # now that we know the remote, apply the working directory for the remote on the command to be executed

    $command = working_directory_for_interaction_role_apply($current_interaction_role, $command);

    # prefix the command with appropriate sudo options

    my $sudo_prefix = compute_sudo($command, $options->{sudo});

    # prefix the command with appropriate timeout options

    my $timeout_prefix = compute_timeout($command, $options->{timeout});

    # if we need to rebuild according to the (optionally remote) build_tree

    my $needs_rebuild = build_tree_needs_rebuild($options->{build_tree}, { remote_prefix => $remote_prefix, }, );

    if (not $needs_rebuild)
    {
	return 0;
    }

    # force the execution of a change of the working directory to this process

    my $dry_run = $options->{dry_run} || $option_dry_run;

    $executable_command = working_directory_for_interaction_role_parse($executable_command, $dry_run, $current_interaction_role);

    #! note that the order of processing determines whether the options are locally or remotely applied

    # apply the sudo prefix, possibly remote

    ($command, $export_sh_command) = apply_sudo($sudo_prefix, $command, $option_export_sudo, $export_sh_command);

    # apply the remoting prefix, always local

    ($command, $export_sh_command) = apply_remote_record_exported_command($remote_prefix, $command, $option_export_remote, $export_sh_command);

    # apply the timeout prefix, always local

    ($command, $export_sh_command) = apply_timeout($timeout_prefix, $command, undef, $export_sh_command);

    # schedule the given command

    my $exit_code
	= schedule_real_command
	  (
	   $command,
	   $executable_command,
	   $options,
	   $dry_run,
	   $export_sh,
	   $export_sh_command,
	  );
}


sub execute_shell_command_array
{
    my $commands = shift;

    my $options = shift;

    my $needs_rebuild = build_tree_needs_rebuild($options->{build_tree}, );

    if (not $needs_rebuild)
    {
	return 0;
    }

    foreach my $command (@$commands)
    {
	execute_shell_command($command, $options);
    }
}


sub execute_shell_command_schedule
{
    my $schedule = shift;

    my $command_array = $schedule->{commands};

    my $option_array = $schedule->{options};

    if (not defined $option_array)
    {
	$option_array = [ {}, ];
    }

    foreach my $options (@$option_array)
    {
	foreach my $command (@$command_array)
	{
	    execute_shell_command($command, $options);
	}
    }
}


sub execute_shell_command_schedule_array
{
    my $schedule_array = shift;

    foreach my $schedule (@$schedule_array)
    {
	execute_shell_command_schedule($schedule);
    }
}


# given a filename prefix and a 'command' generate an output filename
# for logging the output of the command.

our $output_filename_counter = 0;

sub generate_output_filename
{
    my $prefix = shift;

    my $command = shift;

    # a command three alphanumeric sequences that are used to
    # construct an abbreviation of the command for use in the
    # generated output filename

    #! I don't believe this has ever been fully tested, and I don't
    #! believe the regex is correct, it seems to miss anchors between
    #! the alphanumeric sequences.

    $command =~ /([a-z0-9]){0,5}(?:[a-z0-9]*)([a-z0-9]){0,5}(?:[a-z0-9]*)([a-z0-9]){0,5}(?:[a-z0-9]*)/i;

    my $one = defined $1 ? $1 : "one";

    my $two = defined $2 ? $2 : "two";

    my $three = defined $3 ? $3 : "three";

    # make sure the filename is unique to the given command

    $output_filename_counter++;

    # generate the filename

    my $result = "$prefix-$output_filename_counter-$one-$two-$three";

    # return result

    return $result;
}


package FieldProject;


our $status;


sub _init
{
    # default result: empty

    my $result_field;

    my $result_technical;

    # set the global field project name and field configuration data
    # this is used to find configuration and command files

    $result_field = _init_get_field_project_configuration();

    # set the technical configuration

    if ($result_field)
    {
	$result_technical = _init_get_technical_configuration($result_field->{field_project_name});
    }

    # return field project configuration data

    return ($result_field, $result_technical);
}


sub _init_get_field_project_configuration
{
    # set default result: undefined

    my $result;

    # try to determine the field_project_name from the executable name

    if ($0 =~ m(.*/(.*)-workflow))
    {
	# set result

	$result
	    = {
	       field_project_name => $1,
	       from_executable => "dynamically_generated from the executable script name",
	      };
    }
    else
    {
	# try to determine the field project name for a field_project_configuration file

	my $field_project_configuration_filename = "project.pl";

	# loop over the possible field project configuration directories

	my $field_project_configuration_directories
	    = [
	       ".",
	       $global_program_rel_directory,
	       $global_program_abs_directory,
	      ];

	my $field_project_configuration_directory;

	foreach my $tmp (@$field_project_configuration_directories)
	{
	    # if a field_project_configuration file can be found

	    if (-d $tmp
		and -e "$tmp/$field_project_configuration_filename"
		and -r "$tmp/$field_project_configuration_filename")
	    {
		# this is the one we use

		$field_project_configuration_directory = $tmp;

		last;
	    }
	}

	# if the field_project_configuration_directory was found

	if (defined $field_project_configuration_directory)
	{
	    # read the field project configuration

	    # set the global variable with the field_project data

	    my $field_project_configuration = do "$field_project_configuration_directory/$field_project_configuration_filename";

	    if ($@)
	    {
		$status = "$0: *** Error: no valid configuration file '$field_project_configuration_directory/$field_project_configuration_filename' found ($@)\n";

		return undef;
	    }

	    if (not defined $field_project_configuration
		and $!)
	    {
		$status = "$0: *** Error: no configuration file '$field_project_configuration_directory/$field_project_configuration_filename' found ($!)\n";

		return undef;
	    }

	    # set result: field project name, it is used to find configuration and command files

	    $result
		= {
		   %$field_project_configuration,
		   from_directory => $field_project_configuration_directory,
		  };
	}

	# no field_project_configuration_directory was found

	else
	{
	    $status = "$0: *** Error: no valid configuration file '$field_project_configuration_filename' found in any of the configuration directories ('.', 'global_program_rel_directory' or '$global_program_abs_directory')\n";

	    return undef;
	}
    }

    # return result

    return $result;
}


sub _init_get_technical_configuration
{
    my $project_name = shift;

    my $technical_project_configuration_directories
	= [
	   ".",
	   $global_program_rel_directory,
	   $global_program_abs_directory,
	  ];

    my $technical_project_configuration_directory;

    foreach my $tmp (@$technical_project_configuration_directories)
    {
	# if a technical_project_configuration file can be found

	if (-d $tmp
	    and -e "$tmp/$project_name-configuration"
	    and -r "$tmp/$project_name-configuration")
	{
	    # this is the one we use

	    $technical_project_configuration_directory = $tmp;

	    last;
	}
    }

    if (not defined $technical_project_configuration_directory)
    {
	$status = "$0: *** Error: no configuration file '$project_name-configuration' found in any of the searched directories (would prefer this to be in $global_program_rel_directory)\n";

	return undef;
    }

    my $technical_configuration_filename = "$technical_project_configuration_directory/$project_name-configuration";

    my $technical_configuration = do $technical_configuration_filename;

    if ($@)
    {
	$status = "$0: *** Error: no valid configuration file '$technical_configuration_filename' found ($@)\n";

	return undef;
    }

    if (not defined $technical_configuration
	and $!)
    {
	$status = "$0: *** Error: no configuration file '$technical_configuration_filename' found ($!)\n";

	return undef;
    }

    return $technical_configuration;
}


our $global_main_project_name = "ssp";


package main;


sub bash_completion
{
    my $command_line = $option_bash_completion || "";

    my $command_line_words = [ split ' ', $command_line, ];

    #! kind of sloppy ...

    my $comp_cword = $option_target;

    my $comp_point = $ARGV[0];

    my $command_line_word = $command_line_words->[$comp_cword];

    my $arguments = [ split ' ', $command_line, ];

    my $command = shift @$arguments;

    my $result;

    if ($command =~ /configuration/)
    {
	$result = bash_completion_generate($command, $arguments, $global_technical_project_configuration);

	push @$result, '--', '-1', '-2', '-3';
    }
    elsif ($command =~ /workflow/)
    {
	if (defined $command_line_word
	    and $command_line_word =~ /^-/)
	{
	    $result = bash_completion_generate_options();

	    unshift @$result, 'aa', 'bb';
	}
	else
	{
	    my $internal_commands = generate_command_hash();

	    $result = bash_completion_generate($command, $arguments, $internal_commands);

	    push @$result, '--a', '--b';
	}
    }

    print join " ", @$result;

    exit 0;
}


sub bash_completion_generate
{
    my $command = shift;

    my $arguments = shift;

    my $configuration = shift;

    # search the given arguments in the configuration

    while (@$arguments)
    {
	if (ref $configuration eq 'HASH')
	{
	    my $argument = shift @$arguments;

	    if (exists $configuration->{$argument})
	    {
		$configuration = $configuration->{$argument};
	    }
	}
	elsif (ref $configuration eq 'ARRAY')
	{
	    last;
	}
	else
	{
	    last;
	}
    }

    # return the result depending on its type

    if (ref $configuration eq 'HASH')
    {
	return [ keys %$configuration, ];
    }
    elsif (ref $configuration eq 'ARRAY')
    {
	return [ @$configuration, ];
    }
    else
    {
	return [];
    }
}


sub bash_completion_generate_options
{
    my $result = [
		  qw(
			--bash-completion
			--branch
			--build-server
			--built-image-directory
			--command
			--dry-run
			--dump-all-interaction-roles
			--dump-interaction-roles
			--dump-module-interaction-roles
			--dump-schedule
			--export-remote
			--export-sh
			--export-sudo
			--export-times
			--export-verbose
			--force-rebuild
			--forward-destination
			--forward-source
			--help
			--help-build-servers
			--help-commands
			--help-field-project-name
			--help-options
			--help-packages
			--help-projects
			--help-targets
			--incremental
			--interactions
			--interactions-all
			--interactions-module
			--packages
			--ssh-port
			--ssh-server
			--ssh-user
			--target
			--tftp-directory
			--verbose
		   )
		 ];

    return $result;
}


sub generate_command_hash
{
    my $commands = generate_command_list();

    # set default result

    my $result = {};

    # loop over all the found targets and commands

    foreach my $command (@$commands)
    {
	# extract the target and the subroutine from the generated string

	$command =~ m(([^ ]+) ([^ ]+))g;

	my $target = $1;

	my $subroutine = $2;

	# insert them into the result

	$result->{$target}->{$subroutine} = $command;
    }

    # return result

    return $result;
}


sub generate_command_list
{
    # generate a list of the available command subroutines

    my $subroutines = [
		       # select only code references

		       grep
		       {
		       	   defined &{"$_"};
		       }

		       # clarify that they belong to the Command:: package

		       map
		       {
			   "Command::$_";
		       }

		       # select only code references

		       # grep
		       # {
		       # 	   ref {Command::}->{$_} eq 'CODE';
		       # }
		       # grep
		       # {
		       # 	   not defined &$_;
		       # }
		       keys %Command::,
		      ];

    # rework, select and sort these commands

    my $targets = $global_technical_project_configuration->{targets};

    my $commands = [
		    # alphabatically group and make sense

		    sort

		    # remove internal commands and commands that don't belong to a target

		    grep
		    {
			$_ !~ /Command::/;
		    }

		    # remove Command:: package name and rework target prefixes

		    map
		    {
			foreach my $target (sort keys %$targets)
			{
			    $target =~ s/-/_/g;

			    s/Command::${target}_(.*)/${target} $1/g;
			}

			$_;
		    }

		    # all internal commands

		    sort @$subroutines,
		   ];

    return $commands;
}


sub main
{
    # this is YAML related, see for instance https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=707229

    $INC{'Mo/builder.pm'} = 1;
    $INC{'Mo/default.pm'} = 1;

    # initiallize field project related global configuration

    ($global_field_project_configuration, $global_technical_project_configuration) = FieldProject::_init();

    if ($global_field_project_configuration
	and $global_technical_project_configuration)
    {
	# initialize the command module

	Command::_init();

	# parse the local.mk packages to update the dynamically generated help pages

	$global_overriden_packages = buildroot_parse_packages_directories();
    }

    # parse command line

    parse_command_line();

    # perform bash completion logic, this will exit the script

    if ($option_bash_completion)
    {
	bash_completion();
    }

    # parse package directories

    #t this will overwrite the code in the build directories with custom code for packages listed in local.mk.
    #t should set a flag whether a build will be required and honor the flag in preprocessing stages.

    buildroot_process_packages_directories($global_overriden_packages);

    # figure out the target and the command

    my $target = $option_target;

    my $command = $option_commands->[0] || "";

    # we allow finger laziness: the shift key is not necessary for the underscore

    $target =~ s/-/_/g;
    $command =~ s/-/_/g;

    $global_target_command = "$target-$command";

    # given the target and the command generate a useful filename for exporting commands to a shell script

    if (defined $option_export_sh)
    {
	if ($option_export_sh eq 0)
	{
	    $option_export_sh = "/tmp/$global_target_command.sh";
	}
	elsif ($option_export_sh eq 1
	       or $option_export_sh eq '')
	{
	    $option_export_sh = "$global_target_command.sh";
	}

	# again we prefer to not need to press the shift key

	$option_export_sh =~ s/_/-/g;
    }

    # given the target and the command generate a useful filename for exporting execution times to a log file

    if (defined $option_export_times)
    {
	if ($option_export_times eq 0)
	{
	    $option_export_times = "/tmp/$global_target_command.times";
	}
	elsif ($option_export_times eq 1
	       or $option_export_times eq '')
	{
	    $option_export_times = "$global_target_command.times";
	}

	# again we prefer to not need to press the shift key

	$option_export_times =~ s/_/-/g;
    }

    # if we are using a build server

    if ($option_build_server)
    {
	die "$0: *** option_build_server is still in development";

	my $build_source = "";

	my $build_servers = $global_technical_project_configuration->{build_servers};

	my $build_server = $build_servers->{$option_build_server};

	if ($build_server->{name} ne 'laptop')
	{
	    my $ssh_user = $build_server->{ssh_user};

	    my $ssh_server = $build_server->{ssh_server};

	    my $tftp_directory = $build_server->{tftp_directory};

	    $build_source .= "$ssh_user\@$ssh_server";
	}

	# this results in something like this:
	#
	# ssh cornelih@cbi.utsa.edu tmux new-session -d 'project-workflow ssp build && bash'
	#
	# but I will likely also need to use sendkeys to detach from the session
	# also need to cd to the correct directory

	Engine::execute_shell_command("ssh $build_source tmux new-session -d 'neurospaces-workflow $target $command && bash'");
    }
    else
    {
	my $dry_run_module_commands;

	if ($option_interactions_module)
	{
	    $dry_run_module_commands = 'option_interactions_module';

	    # make sure we don't actually run any commands

	    $option_dry_run = 'option_interactions_module';
	}

	if ($option_dump_module_interaction_roles)
	{
	    $dry_run_module_commands = 'option_dump_module_interaction_roles';

	    # make sure we don't actually run any commands

	    $option_dry_run = 'option_dump_module_interaction_roles';
	}

	if ($dry_run_module_commands)
	{
	    # generate the list of all commands

	    my $all_commands = generate_command_hash();

	    # reference subroutine names specific for the given target: they belong together

	    my $target_subroutines = $all_commands->{$target};

	    # collect the subroutine names

	    my $command_implementations
		= [
		   map
		   {
		       my $subroutine = $_;

		       "Command::${target}_${subroutine}";
		   }
		   keys %$target_subroutines,
		  ];

	    # invoke all these subroutines in dry run mode to have them either generate or report the module roles

	    foreach my $command_implementation (sort @$command_implementations)
	    {
		if ($option_verbose)
		{
		    print "Invoking ($command_implementation)\n";
		}

		$command_implementation =~ /Command::(.*)/;

		my $short_command = $1;

		my $scheduled_command
		    = {
		       command => "---\nCOMMAND: $short_command",
		       dry_run => $dry_run_module_commands,
		       interaction_role => 'none',
		      };

		push @$global_scheduled_commands, $scheduled_command;

		{
		    no strict "refs";

		    &$command_implementation();
		}

		$scheduled_command
		    = {
		       command => "\n\n---\n",
		       dry_run => $dry_run_module_commands,
		       interaction_role => 'none',
		      };

		push @$global_scheduled_commands, $scheduled_command;
	    }
	}
	else
	{
	    my $command_implementation = "Command::${target}_${command}";

	    if ($option_verbose)
	    {
		print "Invoking ($command_implementation)\n";
	    }

	    no strict "refs";

	    &$command_implementation(\@ARGV);
	}

	Engine::execute_all_scheduled_commands();
    }
}


sub parse_command_line
{
    my $result = GetOptionsFromArray(\@ARGV, %$global_options);

    if (!$result)
    {
        die "$0: *** error in option processing, try --help";
    }

    # my $asking_help = ($option_help
    # 		       or $option_help_build_servers
    # 		       or $option_help_commands
    # 		       or $option_help_packages
    # 		       or $option_help_projects
    # 		       or $option_help_targets);

    if (not defined $option_target
	and scalar @ARGV)
    {
	$option_target = shift @ARGV;
    }

    if (not defined $option_commands->[0]
	and scalar @ARGV)
    {
	$option_commands->[0] = shift @ARGV;
    }

    if ($option_help)
    {
        print
            "
$0: support for workflow design for embedded software engineers.

SYNOPSIS

$0 <options> <target> <command> -- < ... command specific options and arguments ... >

EXAMPLES -- first try these with the --dry-run to understand what they do:

  \$ $0 ssp build                                            # 'build' the 'ssp' target (if it exists for your local configuration).

  \$ $0 --dry-run ssp build                                  # display the shell commands that would be executed to 'build' the 'ssp' target.

  \$ $0 --help-targets                                       # display the available targets that are found in the configuration file.

options:
    --bash-completion               compute bash completion for the given command line.
                                    hint: the bash completion script implements completion for options, targets and commands.
    --branch                        git branch to work with.
    --build-server                  the build server profile to work with.
    --built-image-directory         the directory on the build server where the built images are to be found.
    --command                       commands to execute, hyphens (-) in the command will be replaced with underscores (_).
    --dry-run                       if set, do not execute system shell commands but print them to STDOUT.
    --dump-all-interaction-roles    dump all the interaction roles found in the configuration.
    --dump-interaction-roles        dump the found interaction roles (note that they depend on the scheduled commands).
    --dump-module-interaction-roles dump all the interaction roles found in the module of the given command.
    --dump-schedule                 dump the constructed schedule to standard output without executing the scheduled commands.
    --export-remote                 include the remote access part of exported commands.
                                    this option takes a number: 0 means all roles are exported, any other number exports only that respective role.
    --export-sh                     export the commands to a file with the given name.
    --export-sudo                   include the sudo commands when exporting commands to a file.
    --export-times                  export the times when commands are started and ended to a file with the given name.
    --export-verbose                when exporting the commands to a file, interleave them with echo commands.
    --force-rebuild                 force a rebuild regardless of the existence and build date of previously built artefacts.
    --forward-destination           the target file forward destination to copy to.
    --forward-source                the target file forward source to copy from.
    --help                          display usage information and stop execution.
    --help-build-servers            display the known build servers.
    --help-commands                 display the available commands (requires the installation of Devel::Symdump with 'sudo cpanm Devel::Symdump').
    --help-field-project-name       print the field project name and exit.
    --help-options                  print the option values.
    --help-packages                 display known package and overriden package information and stop execution.
    --help-projects                 display known project information and stop execution.
    --help-targets                  display known targets and stop execution.
    --incremental                   assume an incremental build (default is " . ($option_incremental ? "yes" : "no") . "
    --interactions                   show the interaction diagram of the commands.
    --interactions-all               show the interaction diagram of the commands using all the found interaction roles in the configuration.
    --interactions-module            show the interaction diagram of all the commands in the module.
    --packages                      packages to operate on, can be given multiple times.
    --ssh-port                      the ssh port.
    --ssh-server                    the used ssh build server.
    --ssh-user                      ssh-user on the build server (please configure your public key).
    --target                        the target to apply the given commands to.
    --tftp-directory                the target tftp directory (eg. where your device will find its kernel and rootfs).
    --verbose                       set verbosity level.

NOTES

OVERRIDE_SRCDIR delivered packages for Buildroot targets are recognized.

";

	exit 0;
    }

    if (defined $option_build_server)
    {
	my $build_servers = $global_technical_project_configuration->{build_servers};

	if (not exists $build_servers->{$option_build_server})
	{
	    die "$0: *** Error: unknown build server $option_build_server, use --help-build-servers to learn about the known servers";
	}

	# if (not defined $option_ssh_server)
	# {
	#     $option_ssh_server = $build_servers->{$option_build_server}->{ssh_server};
	# }

	# if (not defined $option_ssh_user)
	# {
	#     $option_ssh_user = $build_servers->{$option_build_server}->{ssh_user};
	# }

	if (not defined $option_ssh_port)
	{
	    $option_ssh_port = $build_servers->{$option_build_server}->{ssh_port};
	}

	# if (not defined $option_tftp_directory)
	# {
	#     $option_tftp_directory = $build_servers->{$option_build_server}->{tftp_directory};
	# }

	# if (not defined $option_built_image_directory)
	# {
	#     $option_built_image_directory = $build_servers->{$option_build_server}->{built_image_directory};
	# }
    }

    my $build_servers = $global_technical_project_configuration->{build_servers};

    my $status;

    if (defined $option_forward_destination_server)
    {
	if (not exists $build_servers->{$option_forward_destination_server})
	{
	    $status = "$0: *** Error: unknown forwarding server $option_forward_destination_server, use --help-build-servers to learn about the known servers";
	}
    }

    if (defined $option_forward_source_server)
    {
	if (not exists $build_servers->{$option_forward_source_server})
	{
	    $status = "$0: *** Error: unknown forwarding server $option_forward_source_server, use --help-build-servers to learn about the known servers";
	}
    }

    if ($option_help_build_servers)
    {
	use YAML;

	print Dump( { build_servers => $build_servers, }, );

	exit 0;
    }

    if ($option_help_commands)
    {
	use YAML;

	my $commands = generate_command_list();

	if ($option_target)
	{
	    $commands
		= [
		   grep
		   {
		       /$option_target/;
		   }
		   @$commands,
		  ];
	}

	$commands
	    = [
	       map
	       {
		   "$global_program_name $_ --dry-run";
	       }
	       @$commands,
	      ];

	print Dump( { "available_commands (copy-paste the one you would like to execute, try it with the --dry-run option, execute it without this option)" => $commands, }, );

	exit 0;
    }

    if ($option_help_options)
    {
	use YAML;

	my $options
	    = {
	       bash_completion => $option_bash_completion,
	       branch => $option_branch,
	       build_server => $option_build_server,
	       built_image_directory => $option_built_image_directory,
	       commands => $option_commands,
	       dry_run => $option_dry_run,
	       dump_all_interaction_roles => $option_dump_all_interaction_roles,
	       dump_interaction_roles => $option_dump_interaction_roles,
	       dump_module_interaction_roles => $option_dump_module_interaction_roles,
	       dump_schedule => $option_dump_schedule,
	       export_remote => $option_export_remote,
	       export_sh => $option_export_sh,
	       export_sudo => $option_export_sudo,
	       export_times => $option_export_times,
	       export_verbose => $option_export_verbose,
	       force_rebuild => $option_force_rebuild,
	       forward_destination_server => $option_forward_destination_server,
	       forward_source_server => $option_forward_source_server,
	       help => $option_help,
	       help_build_servers => $option_help_build_servers,
	       help_commands => $option_help_commands,
	       help_field_project_name => $option_help_field_project_name,
	       help_options => $option_help_options,
	       help_packages => $option_help_packages,
	       help_projects => $option_help_projects,
	       help_targets => $option_help_targets,
	       incremental => $option_incremental,
	       interactions => $option_interactions,
	       interactions_all => $option_interactions_all,
	       interactions_module => $option_interactions_module,
	       packages => $option_packages,
	       ssh_port => $option_ssh_port,
	       ssh_server => $option_ssh_server,
	       ssh_user => $option_ssh_user,
	       target => $option_target,
	       tftp_directory => $option_tftp_directory,
	       verbose => $option_verbose,
	      };

	print Dump( { "global_options" => $global_options, }, );

	exit 0;
    }

    if ($option_help_packages)
    {
	use YAML;

	my $packages = $global_technical_project_configuration->{packages};

	print Dump( { global_packages => $packages, }, );

	print Dump( { global_overriden_packages => $global_overriden_packages, }, );

	exit 0;
    }

    if ($option_help_field_project_name)
    {
	use YAML;

	print Dump( { global_field_project_configuration => $global_field_project_configuration, }, );

	exit 0;
    }

    # if ($option_help_node_configuration)
    # {
    # 	use YAML;

    # 	print Dump( { configuration => $global_node_configuration, }, );

    # 	exit 0;
    # }

    if ($option_help_projects)
    {
	use YAML;

	my $projects = $global_technical_project_configuration->{projects};

	print Dump( { global_projects => $projects, }, );

	exit 0;
    }

    if ($option_help_targets)
    {
	use YAML;

	my $targets = $global_technical_project_configuration->{targets};

	print Dump( { targets => $targets, }, );

	exit 0;
    }

    if (not defined $option_target)
    {
	die "$0: *** Error: neither a target option nor target argument given, try --help";
    }

    if ($FieldProject::status)
    {
	die $FieldProject::status;
    }

    if ($status)
    {
	die $status;
    }
}


# parse the package directories in local.mk

sub buildroot_parse_packages_directories
{
#     "$ENV{HOME}/projects/developer/source/snapshots/$branch";

    # packages listed in alphabetical order, dashes replaced with underscores

    my $package_overrides_filename = "local.mk";

    my $package_overrides;

    {
	# see also https://stackoverflow.com/questions/8963400/the-correct-way-to-read-a-data-file-into-an-array

	# local $/;		# enable localized slurp mode

	$package_overrides = [ `cat 2>/dev/null "$package_overrides_filename"` ];
    }

    # loop over all lines in local.mk

    my $overriden_packages;

    foreach my $package_override (@$package_overrides)
    {
	# we are only interested custom repositories

	if ($package_override !~ /_OVERRIDE_SRCDIR/)
	{
	    next;
	}

	if ($package_override =~ /_RSYNC_EXCLUSIONS/)
	{
	    next;
	}

	# skip comment lines

	if ($package_override =~ /^\s*#/)
	{
	    next;
	}

	#! beware of unmatched characters in the directory name

	$package_override =~ /^\s*(\w+)_OVERRIDE_SRCDIR\s*=\s*([\w\/\.-]*)/;

	my $package_name = lc $1;

	# # skip gcc related overrides, buildroot ignores them, we deal with them elsewhere

	# if ($package_name eq 'cr_gcc')
	# {
	#     next;
	# }

	my $package_directory = $2;

	$overriden_packages->{$package_name}->{directory} = $package_directory;

	if ($option_verbose)
	{
	    print STDERR "$0: *** added for package $package_name OVERRIDE_SRCDIR $package_directory\n";
	}
    }

    # propagate the overriden_packages

    return $overriden_packages;
}


# prepare the package directories in local.mk

sub buildroot_process_packages_directories
{
    my $overriden_packages = shift;

    # loop over all the overriden packages

    foreach my $package_name (sort keys %$overriden_packages)
    {
	# skip gcc related overrides, buildroot ignores them, we deal
	# with them in the build command of the toolchain target

	if ($package_name eq 'cr_gcc')
	{
	    next;
	}

	# get the package source directory from the override

	my $package_directory = $overriden_packages->{$package_name}->{directory};

	# get the build directory from the globally known packages

	my $packages = $global_technical_project_configuration->{packages};

	my $build_directory = $packages->{$package_name}->{build_directory};

	if (not defined $build_directory)
	{
	    die "$0: *** Fatal: package $package_name has no build_directory defined in the package list";
	}

	# Engine::execute_shell_command("mkdir --parents '$build_directory'");

	# Engine::execute_shell_command("cp -a '$package_directory'/* '$build_directory'");

	# my $stamp_filenames = $global_technical_project_configuration->{stamp_filenames};

	# my $stamp_built = $stamp_filenames->[0];

	# Engine::execute_shell_command("rm -f '$build_directory/$stamp_built'");
    }
}


main();


