#!/usr/bin/perl -w 
#!/usr/bin/perl -w -d:ptkdb
#


use strict;


use Getopt::Long;

use YAML;


my $option_output_directory = "/tmp";
my $option_config = "";


my $configuration
    = {
      };

#! note the following are currently a constants

my $installer_directory = "$ENV{HOME}/neurospaces_project/installer/source/snapshots/0";

my $output_filename = "neurospaces_cron.stdout";



sub check_and_prepare
{
    # check if the installer is ok

    my $output_path = $option_output_directory . "/" . $output_filename;

    # here we rotate the logs

    rotate_logs($output_path);

    try_to("echo '$0' started at", 1);

    try_to("date", 1);

    try_to("mkdir -p $installer_directory", 1);

    chdir($installer_directory);

    # we assume that there is already an installer repository

    #t wrong assumption

    try_to("mtn co --db ~/neurospaces_project/MTN/neurospaces-developer.mtn --branch 0 .", 1, 1);

    # install the installer

    install_installer();

}


sub check_user_id
{
    # get effective user id


    my $num_id = $>;


    # convert to ascii representation

    my $passwd_database = [ `cat /etc/passwd`, ];

    # split into fields

    my $records = [ map { [ split ":", $_ ], } @$passwd_database, ];

    # only those records with the numerical id under which this script runs

    $records = [ grep { $_->[2] == $num_id } @$records, ];

    # if not exactly one record left

    if (scalar @$records ne 1)
    {
	report_error("check_user_id()", "$0 cannot determine username under which we are running");

	
	# just to make sure that this script stops we die

	die "check_user_id()" . "$0 cannot determine username under which we are running";
    }

    # get name of this user

    my $fields = $records->[0];

    my $label_id = $fields->[0];

    # if matches with neurospaces

    #t switched off for convenience, although should make it to the real thing again.

    if (1 || $label_id =~ /neurospaces/)
    {
	# ok, continue
    }

    # else

    else
    {
	report_error("check_user_id()", 
		     "$0 must not be executed by a regular user (now running as unprivileged user $label_id)");


	# just to make sure that this script stops we die

	die "check_user_id()" . "$0 must not be executed by a regular user";
    }
}


#
# try to clean up some files out of the /tmp directory
#
#t cleanup of output files should perhaps be optional?
sub cleanup_and_finalize
{

  print "Cleaning generate files out of /tmp\n";

  #t maybe make @trash a list that read in from
  #t a trash configuration file.

  #t then the test specifications can add to the trash file when the
  #t harness runs, and such that the html output can produce a list
  #t of generated output files.

  my @trash
      = (
	 "output",
	 "OutputGenerator",
	 "output_spike",
	 "output_spike_source",
	 "output_vm",
	 "output_vm_source",
	 "purk_test_soma",
	 "purk_test_soma_aggregators",
	 "state",
	 "neurospaces",
	 "a1",
	 "a2",
	 "1.xml",
	 "*.ndf",
	 "readcell_reset.txt",
	 "current_schedule",
	 "state",
	 "heccer",
	 "morphology2ndf.yml",
	 "morphology*.ndf",
	);


  my $item;

  foreach $item (@trash)
  {
      my $trashfile = "/tmp/" . $item;

      if (-e $trashfile)
      {
	  try_to("echo $0: Removing $trashfile\n", 1);

	  try_to("rm -rf $trashfile", 1);
      }
      else
      {
	  try_to("echo $0: $trashfile not found, please remove it from the trash list\n", 1);
      }
  }

  try_to("echo $0: done with cleanup.\n", 1);

  try_to("date", 1);

}


#
#
#
sub copy_tests
{

  if ($option_output_directory eq "/tmp")
  {
      # if default no need to do anything.

      return;
  }


  # clean out the old tests
  system "rm -f $option_output_directory/text_*";




  # copy over the new ones.
  system "mv -f /tmp/text_* $option_output_directory";



}


sub install_installer
{
    chdir($installer_directory);

    try_to("./autogen.sh && ./configure && make && sudo make install");
}


sub main
{

    {
	my $result
	    = GetOptions
		(
		 "outputdir=s" => \$option_output_directory,
		 "config=s" => \$option_config,
		);

    }


    if ($option_config)
    {
	parse_config_file($option_config);
    }

    #
    # For security reasons cronjobs use a restricted $PATH
    # which leaves out /usr/local/bin and prevents it from executing some
    # commands.
    #
    # note: May be needed for users with
    # a different cron path since '/usr/local/bin' is usually not included by default.
    #

    $ENV{PATH} .= ':/bin:/usr/bin:/usr/local/bin';


    # this script can only be run by a user whose name matches 'neurospaces'

    check_user_id();

    # unlink the output file

    unlink($output_filename);

    chdir($option_output_directory);

    # preparatory startup procedure to check this system

    check_and_prepare();

    # prepare an initial directory layout

    try_to("neurospaces_create_directories");

    # pull code from the repositories

    try_to("neurospaces_pull");

    # uninstall what was installed

    try_to("neurospaces_uninstall");

    install_installer();

    # update the source code in the workspaces, remove previous build

    try_to("neurospaces_update");

    try_to("neurospaces_clean");

    # loop over all the configurations we want to test

    foreach my $package_configuration (1)
    {
	#t insert configuration options in the configurator package

	# configure all packages

	try_to("neurospaces_configure");

	# install without check

	try_to("neurospaces_install");

	# uninstall again

	try_to("neurospaces_uninstall");

	install_installer();

	# check with install

	try_to("neurospaces_check");

	# uninstall again

	try_to("neurospaces_uninstall");

	install_installer();

	# clean out previous build

	try_to("neurospaces_clean");

	#t now download from sourceforge, configurator defines what release to download

	#t compile, install, uninstall, check, uninstall, clean
    }

    # build docs if present in configuration
    # do this AFTER the clean so that the swig stuff doesn't get doxygenized

    try_to("neurospaces_docs");

    if (defined $configuration->{DOXYGENOUTPUT})
    {
	system "rm -rf $configuration->{DOXYGENOUTPUT}/*";
	system "mv -f $ENV{HOME}/neurospaces_project/model-container/source/snapshots/0/docs/html $configuration->{DOXYGENOUTPUT}/model-container";
	system "mv -f $ENV{HOME}/neurospaces_project/heccer/source/snapshots/0/docs/html $configuration->{DOXYGENOUTPUT}/heccer";
	system "mv -f $ENV{HOME}/neurospaces_project/ns-sli/source/snapshots/0/docs/html $configuration->{DOXYGENOUTPUT}/ns-sli";
    }

    if (defined $configuration->{REGTESTOUTPUT})
    {
	system "rm -rf $configuration->{REGTESTOUTPUT}/*";
	system "mv -f $ENV{HOME}/neurospaces_project/model-container/source/snapshots/0/tests/html $configuration->{REGTESTOUTPUT}/model-container";
	system "mv -f $ENV{HOME}/neurospaces_project/heccer/source/snapshots/0/tests/html $configuration->{REGTESTOUTPUT}/heccer";
	system "mv -f $ENV{HOME}/neurospaces_project/ns-sli/source/snapshots/0/tests/html $configuration->{REGTESTOUTPUT}/ns-sli";
	system "mv -f $ENV{HOME}/neurospaces_project/ssp/source/snapshots/0/tests/html $configuration->{REGTESTOUTPUT}/ssp";
	system "mv -f $ENV{HOME}/neurospaces_project/gshell/source/snapshots/0/tests/html $configuration->{REGTESTOUTPUT}/gshell";
    }

#     # now build tarballs

#     my $release_label = time();

#     try_to("neurospaces_dist --tag $release_label-0");

    # copy our individual test output files to the output directory

    copy_tests();


    # clean up after the tests.

    cleanup_and_finalize();

    my $status_message = produce_email_text();

    try_to_mail("neurospaces_cron finished", $status_message);

    #t remove the entire neurospaces_project directory ?

#     try_to("rm -fr $ENV{HOME}/neurospaces_project");
}


#
# ($config_file) a file with a configuration in it.
#
sub parse_config_file
{
  my $config_file = shift;

  if (! -e $config_file)
  {
      print "\n$config_file is an invalid filename\n";

      return;
  }

  print "\nParsing configuration in $config_file\n\n";

  $configuration = YAML::LoadFile($config_file);


  if(!defined $configuration)
  {

    print "This YAML file is invalid\n";
    return;

  }

  if(defined $configuration->{MAILTO})
  {
    chomp($configuration->{MAILTO});
    print "\tSend to email: $configuration->{MAILTO}\n";
  }

  if(defined $configuration->{MAILFROM})
  {
    chomp($configuration->{MAILFROM});
    print "\tSend from email: $configuration->{MAILFROM}\n";
  }

  if(defined $configuration->{OUTPUTDIR})
  {
      #! note that this overrides an option from set by the command line

      $option_output_directory = $configuration->{OUTPUTDIR};
      chomp($option_output_directory);
      print "\tOutput directory is $option_output_directory\n";
  }


  if(defined $configuration->{URL})
  {
      chomp($configuration->{URL});
      print "\tOutput directory for test harness output is $configuration->{URL}\n";
  }



  if(defined $configuration->{DOXYGENOUTPUT})
  {
      chomp($configuration->{DOXYGENOUTPUT});
      print "\tURL for serving the doxygen output is $configuration->{DOXYGENOUTPUT}\n";
  }


    if(defined $configuration->{DOXYGENURL})
  {
      chomp($configuration->{DOXYGENURL});
      print "\tOutput directory for doxygen is $configuration->{URL}\n";
  }


  if(defined $configuration->{REGTESTURL})
  {
      chomp($configuration->{REGTESTURL});
      print "\tURL for serving the regression tests is $configuration->{REGTESTURL}\n";
  }


  if(defined $configuration->{REGTESTOUTPUT})
  {
      chomp($configuration->{REGTESTOUTPUT});
      print "\tOutput directory for regression tests is $configuration->{DOXYGENOUTPUT}\n";
  }


  if(defined $configuration->{LOGROTATE})
  {

    chomp($configuration->{LOGROTATE});
    print "\tNumber of logs to rotate $configuration->{LOGROTATE}\n";

  }


  print "Done Parsing $config_file:\n";

}



#
# Forms the status message to be sent
# in the cronjob email.
#
sub produce_email_text
{

  my $status_message = "";
  my $outputfile = $option_output_directory . "/" . $output_filename;
  my $errorcounts = `cat $outputfile | grep error_count`;
  my $die_messages = `grep die $outputfile`;

  $status_message
      .= (
	  "$0:\nCheck for your output on the host machine here "
	  . $option_output_directory
	  . "/"
	  . $output_filename . "\n"
	 );

  if (defined $configuration->{URL})
  {
      $status_message .= "Check the test output over the web via this link " . $configuration->{URL} . "\n";
  }


  if(defined $configuration->{DOXYGENOUTPUT})
  {
    $status_message .= "\nCheck for the Doxygen output locally in this directory " . $configuration->{DOXYGENOUTPUT} . "\n";
  }

  if(defined $configuration->{DOXYGENURL})
  {
    $status_message .= "\nCheck the Doxygen output over the web via this link " . $configuration->{DOXYGENURL} . "\n";
  }


  if(defined $configuration->{REGTESTOUTPUT})
  {
    $status_message .= "\nCheck for the regression test output locally in this directory " . $configuration->{REGTESTOUTPUT} . "\n";
  }

  if(defined $configuration->{REGTESTURL})
  {
    $status_message .= "\nCheck the regression test output over the web via this link " . $configuration->{REGTESTURL} . "\n";
  }

  $status_message .= "\nError Counts:\n" . $errorcounts . "\n";
  $status_message .= "\nDie Messages:\n" . $die_messages . "\n";
	

  return $status_message;

}


sub report_error
{
    my $command = shift;

    my $error_code = shift;

    try_to_mail("neurospaces_cron error", "$0: $command returned $error_code");

    die "$0: $command returned $error_code";
}


sub try_to
{
    my $command = shift;

    my $no_verbose = shift;

    my $allow_fail = shift;

    if (!$no_verbose)
    {
	print "---\n";
	print "$0: trying to $command\n";
    }

    my $output_path = $option_output_directory . "/" . $output_filename;

    #! $command executed in a subshell such that redirection applies
    #! to all commands.

    system "( $command ) >>$output_path 2>&1";

    if ($?)
    {
	if ($allow_fail)
	{
	    system "echo >>$output_path 2>&1 failed with $?: $command\n";
	}
	else
	{
	    report_error($command, $?);
	}
    }
}



# Rotates logs with the name '$logname'
# 
# args ($logname)
#
sub rotate_logs
{

  my $logname = shift;
  my $numlogs  = -1;

  if(not defined $configuration->{LOGROTATE})
  {
    #i If we aren't rotating logs when we just delete 
    #i the log from the last run.
    #i
    if (-e $logname)
    {
	system "rm -f $logname";
    }
    return;
  }
  else
  {
    $numlogs = $configuration->{LOGROTATE};
  }


  # we shift all of our logs if present. 
  # Whatever log happens to be the last one should
  # get overwritten with a previous log.
  my $i;
  for($i = $numlogs-1; $i > 0; $i--)
  {

    my $log = $logname .'.' . $i;

    if( -e $log )
    {

      # mv should preserve permissions.

      my $nextlog = $logname . '.' . $i+1;

      system "mv -f $log $nextlog";

    }
    else
    {
      next;
    }

  }

  # after the shift, we should be able to move the 
  # first log to slot 0. Now the original slot is open
  # for a log run.
  my $nextlog = $logname . '.' . 0;
  system "mv -f $logname $nextlog";

  return;

}



#
# This will actually send mail.
#
# args ($subject,$message)
#
sub try_to_mail
{
    my $subject = shift;
    my $message = shift;

    if (!$configuration->{MAILTO})
    {
	return;
    }

    my $sendto = $configuration->{MAILTO};
    my $replyto = $configuration->{MAILFROM};

    #todo figure out why I can't put the output of
    # `which sendmail` into a variable and put it in 
    # place of the /usr/sbin/sendmail. A user may have 
    # a different sendmail path.

    #t Mando: perhaps /sbin/ is not in the PATH, such that which does
    #t not find sendmail when things run over cron?

    open(MAIL, "|/usr/sbin/sendmail -oi -t");
    print MAIL "From: $replyto\n";
    print MAIL "To: $sendto\n";
    print MAIL "Subject: $subject\n\n";
    print MAIL "$message\n";
    close(MAIL);

}



main();


