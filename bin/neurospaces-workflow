#!/usr/bin/perl -w

use strict;

use warnings;

use Data::Dumper;

$Data::Dumper::Sortkeys = 'always';

use Getopt::Long;


$SIG{'__DIE__'}
    = sub
      {
	  require Carp;

	  print STDERR Carp::longmess(@_);
      };


$SIG{'INT'}
    = sub
      {
	  require Carp;

	  print STDERR Carp::longmess(@_);

	  exit 1;
      };


our $option_bash_completion;
our $option_branch = "master";
our $option_build_server;
our $option_built_image_directory;
our $option_commands = [];
our $option_dry_run;
our $option_export_remote;
our $option_export_sh;
our $option_export_times;
our $option_export_verbose;
our $option_forward_destination_server = "laptop";
our $option_forward_source_server = "laptop";
our $option_help;
our $option_help_build_servers;
our $option_help_commands;
our $option_help_packages;
our $option_help_projects;
our $option_help_targets;
our $option_incremental = 1;
our $option_interaction;
our $option_packages = [];
our $option_remote = "gitlab";
our $option_ssh_server;
our $option_ssh_port;
our $option_ssh_user;
our $option_tftp_directory;
our $option_target;
our $option_verbose;


our $default_command = "build";
our $default_target = "ssp";


our $global_command_line = join " ", $0, @ARGV;
our $global_overriden_packages;
our $global_program_abs_directory;
our $global_program_name;

{
    use Cwd;

    my $program_name_full = $0;
    my $program_name_full_abs = Cwd::abs_path($program_name_full);

    ($program_name_full_abs =~ m((.*)/(\S+)));

    $global_program_abs_directory = $1;
    $global_program_name = $2;
}


our $global_target_command;

our $global_business_project_configuration;

our $global_business_project;

our $global_configuration;


package BusinessProject;


sub _init
{
    # set the global business project name and business configuration data, this is used to find configuration and command files

    $global_business_project = _init_get_project_name();

    # set the technical configuration

    $global_configuration = _init_get_configuration($global_business_project);
}


sub _init_get_project_name
{
    my $business_project_configuration_filename = "project.pl";

    # find the business project configuration directory

    my $business_project_configuration_directories
	= [
	   ".",
	   $global_program_abs_directory,
	  ];

    my $business_project_configuration_directory;

    foreach my $tmp (@$business_project_configuration_directories)
    {
	if (-d $tmp
	    and -e "$tmp/$business_project_configuration_filename"
	    and -r "$tmp/$business_project_configuration_filename")
	{
	    $business_project_configuration_directory = $tmp;

	    last;
	}
    }

    # read the business project configuration

    if (not defined $business_project_configuration_directory)
    {
	die "$0: *** Error: no valid configuration file '$business_project_configuration_filename' found in any of the configuration directories ('.' or '$global_program_abs_directory')\n";
    }

    # set the global variable with the business_project data

    $global_business_project_configuration = do "$business_project_configuration_directory/$business_project_configuration_filename";

    if ($@)
    {
	die "$0: *** Error: no valid configuration file '$business_project_configuration_directory/$business_project_configuration_filename' found ($@)\n";
    }

    if (not defined $global_business_project_configuration
	and $!)
    {
	die "$0: *** Error: no configuration file '$business_project_configuration_directory/$business_project_configuration_filename' found ($!)\n";
    }

    # return business project name, it is used to find configuration and command files

    return $global_business_project_configuration->{project_name};
}


sub _init_get_configuration
{
    my $project_name = shift;

    my $configuration_filename = "$global_program_abs_directory/$project_name-configuration";

    my $configuration = do $configuration_filename;

    if ($@)
    {
	die "$0: *** Error: no valid configuration file '$configuration_filename' found ($@)\n";
    }

    if (not defined $configuration
	and $!)
    {
	die "$0: *** Error: no configuration file '$configuration_filename' found ($!)\n";
    }

    return $configuration;
}


our $global_main_project_name = "ssp";


package Command;


#! these imports will be properly implemented with proper packages

sub execute_shell_command
{
    return Context::execute_shell_command(@_);
}


sub execute_shell_command_array
{
    return Context::execute_shell_command_array(@_);
}


sub execute_shell_command_schedule
{
    return Context::execute_shell_command_schedule(@_);
}


sub execute_shell_command_schedule_array
{
    return Context::execute_shell_command_schedule_array(@_);
}


sub _init
{
    my $commands_seen;

    my $command_filenames_found
	= [
	   grep
	   {
	       /$global_business_project-commands[-a-z0-9]*$/;
	   }
	   map
	   {
	       chomp; $_;
	   }
	   `ls $global_program_abs_directory/$global_business_project-commands*`,
	  ];

    my $command_filenames_configured
	= [
	   grep
	   {
	       /$global_business_project-commands[-a-z0-9]*$/;
	   }
	   map
	   {
	       "$global_program_abs_directory/$_";
	   }
	   @{ $global_configuration->{command_filenames} },
	  ];

    my $command_filenames
	= [
	   grep
	   {
	       not $commands_seen->{$_}++;
	   }
	   @$command_filenames_configured,
	   #        @$command_filenames_found,
	  ];

    foreach my $command_filename (@$command_filenames)
    {
	my $commands = do $command_filename;

	if ($@)
	{
	    die "$0: *** Error: no valid commands file '$command_filename' found ($@)\n";
	}

	if ($!)
	{
	    die "$0: *** Error: no commands file '$command_filename' found ($!)\n";
	}
    }
}


package Context;


our $global_exported_sh_file;

our $global_exported_sh_filename;

our $global_exported_times_file;

our $global_exported_times_filename;


sub process_chdir_2_cd
{
    my $command = shift;

    my $dry_run = shift;

    my $arguments;

    # if this is a chdir command

    if ($command =~ /^\s*chdir\s+(.*)$/
	or $command =~ /^\s*cd\s*$/
	or $command =~ /^\s*cd\s+(.*)$/)
    {
	# process its arguments

	my $arguments = $1 || "";

	# remove quotes, they are invalid in directory names for the purpose of this script

	$arguments =~ s/^'//g;
	$arguments =~ s/'$//g;

	# some forms of chdir require an argument,
	# some forms of cd don't and use a default of $HOME

	if ($arguments =~ /^\s*$/)
	{
	    $arguments = $ENV{HOME};
	}

	$command = "cd $arguments";
    }

    # return the possibly processed result

    return $command;
}


sub build_tree_needs_rebuild
{
    my $build_tree = shift;

    my $options = shift;

    my $result = "default is to rebuild";

    my $remote_prefix = $options->{remote_prefix};

    # if we have sources and targets

    if ($build_tree->{sources}
	and $build_tree->{targets})
    {
	# determine the youngest source file

	my $source_youngest = 0;

	my $sources = $build_tree->{sources};

	foreach my $source (@$sources)
	{
	    #! %Y gives second accuracy, %y gives a higher resolution
	    #! but its output requires more parsing

	    my $source_stat_command = 'stat --format="%Y" ' . "'$source'";

	    if ($remote_prefix)
	    {
		$source_stat_command = "$remote_prefix   $source_stat_command";
	    }

	    my $source_stat_output = `$source_stat_command 2>/dev/null`;

	    if ($option_verbose
		and $option_verbose > 1)
	    {
		print "build_tree_needs_rebuild(): source_stat_output: $source_stat_output ($source)\n";
	    }

	    if ($?)
	    {
		return 1;
	    }

	    # the youngest source file is the one with the highest seconds value

	    if ($source_stat_output > $source_youngest)
	    {
		$source_youngest = $source_stat_output;
	    }
	}

	# determine the oldest target file

	my $target_oldest = 16127117390; # GMT: Friday, January 17, 2481 10:49:50 AM

	my $targets = $build_tree->{targets};

	foreach my $target (@$targets)
	{
	    #! %Y gives second accuracy, %y gives a higher resolution
	    #! but its output requires more parsing

	    my $target_stat_command = 'stat --format="%Y" ' . "'$target'";

	    if ($remote_prefix)
	    {
		$target_stat_command = "$remote_prefix   $target_stat_command";
	    }

	    my $target_stat_output = `$target_stat_command 2>/dev/null`;

	    if ($option_verbose
		and $option_verbose > 1)
	    {
		print "build_tree_needs_rebuild(): target_stat_output: $target_stat_output ($target)\n";
	    }

	    if ($?)
	    {
		return 1;
	    }

	    # the oldest target file is the one with the smallest seconds value

	    if ($target_stat_output < $target_oldest)
	    {
		$target_oldest = $target_stat_output;
	    }
	}

	# if the youngest source file is younger than the oldest target file

	if ($source_youngest >= $target_oldest)
	{
	    # we need to rebuild

	    $result = 1;
	}

	# else all the target files  are younger than the youngest source file

	else
	{
	    # so we don't need to rebuild

	    $result = 0;
	}

	if ($option_verbose
	    and $option_verbose > 1)
	{
	    print "build_tree_needs_rebuild(): source_youngest: $source_youngest, target_oldest: $target_oldest ==> needs_rebuild: $result\n";
	}

    }

    # return result

    return $result;
}


sub display_commented_command
{
    my $command = shift;

    my $options = shift;

    if (not $options->{quiet})
    {
	# print "# $command (length: $command_length)\n#\n";

	print "# $command\n#\n";
    }
}


my $interaction_roles = {};

my $current_interaction_role;

sub execute_shell_command
{
    my $command = shift;

    my $options = shift;

    my $processed_command = $command;

    $processed_command =~ s(^\s*#.*)()g;

    my $command_is_empty = $processed_command =~ /^\s*$/ ? 'yes' : '';

    my $command_length = length $processed_command;

    my $allow_fail = $options->{allow_fail};

    my $verbose = $options->{verbose} || $option_verbose;

    # the command to be exported defaults to the command given

    my $export_command = defined $option_export_sh ? $command : undef;

    if (defined $verbose
	and $verbose =~ /^[0-9]+$/)
    {
	$verbose = "*** INFO: ";
    }

    # if exporting to a script for this command

    my $export_sh = $options->{export_sh};

    if (not defined $export_sh)
    {
	if (defined $option_export_sh)
	{
	    $export_sh = { filename => $option_export_sh, };
	}
    }
    else
    {
	# if globally exporting all commands

	if (defined $option_export_sh)
	{
	    $export_sh->{filename} = $option_export_sh;
	}
    }

    # if exporting timing information for this command

    my $export_times = $options->{export_times};

    if (not defined $export_times)
    {
	if (defined $option_export_times)
	{
	    $export_times = { filename => $option_export_times, };
	}
    }
    else
    {
	# if globally exporting all timing information

	if (defined $option_export_times)
	{
	    $export_times->{filename} = $option_export_times;
	}
    }

    # if there is remoting information

    my $remote_prefix = "";

    if ($options->{remote})
    {
	# do we need to skip remoting for this command?

	if (exists $options->{remote}->{skip}
	    and $command =~ /$options->{remote}->{skip}/)
	{
	    $current_interaction_role = "localuser\@localhost";
	}

	# else construct the remote role

	else
	{
	    if (exists $options->{remote}->{ssh_password})
	    {
		my $ssh_password = $options->{remote}->{ssh_password};

		$remote_prefix .= "sshpass -p $ssh_password ";
	    }

	    if (exists $options->{remote}->{ssh_options})
	    {
		$current_interaction_role = "";

		my $ssh_options = $options->{remote}->{ssh_options};

		if (exists $options->{remote}->{ssh_server})
		{
		    my $ssh_server = $options->{remote}->{ssh_server};

		    if (exists $options->{remote}->{ssh_user})
		    {
			my $ssh_user = $options->{remote}->{ssh_user};

			$current_interaction_role = "$ssh_user\@$ssh_server";

			$remote_prefix .= "ssh $ssh_options $ssh_user\@$ssh_server ";
		    }
		    else
		    {
			$current_interaction_role = $ssh_server;

			$remote_prefix .= "ssh $ssh_options $ssh_server ";
		    }
		}
		else
		{
		    $current_interaction_role = "localuser\@localhost";

		    $remote_prefix .= "ssh $ssh_options ";
		}
	    }
	    else
	    {
		$current_interaction_role = "localuser\@localhost";
	    }

	    if (defined $verbose and ($verbose =~ /INFO/ or $verbose > 1))
	    {
		print "$verbose: remote_prefix is $remote_prefix\n";
	    }
	}
    }

    # else no remoting information

    else
    {
	# track the interaction role

	$current_interaction_role = "localuser\@localhost";
    }

    # prefix the command with the remoting information

    if ($remote_prefix)
    {
	$command = "$remote_prefix   $command";

	if ($option_export_remote)
	{
	    $export_command = $command;
	}
    }

    # if there is timeout information

    my $timeout_prefix = "";

    if ($options->{timeout})
    {
	# if we need to skip timeout information

	my $timeout_options = $options->{timeout};

	if (exists $timeout_options->{skip}
	    and $command =~ /$timeout_options->{skip}/)
	{
	}

	# else construct the timeout command

	else
	{
	    if (exists $timeout_options->{sudo}
		and $timeout_options->{sudo} eq 1)
	    {
		$timeout_prefix .= "sudo ";
	    }

	    $timeout_prefix .= "timeout ";

	    if (exists $timeout_options->{options})
	    {
		$timeout_prefix .= "$timeout_options->{options} ";
	    }

	    if (not exists $timeout_options->{duration})
	    {
		die "*** Error: $0: the timeout option of '$command' does not have the mandatory duration specified";
	    }

	    $timeout_prefix .= "$timeout_options->{duration} ";
	}
    }

    # prefix the command with the timeout command

    if ($timeout_prefix)
    {
	$command = "$timeout_prefix   $command";
    }

    # if we need to rebuild according to the build_tree

    my $needs_rebuild = build_tree_needs_rebuild($options->{build_tree}, { remote_prefix => $remote_prefix, }, );

    if (not $needs_rebuild)
    {
	return 0;
    }

    if ($verbose)
    {
	use Cwd qw();

	my $path = Cwd::cwd();

	print "---\n";

	if (defined $verbose and ($verbose =~ /INFO/ or $verbose > 1))
	{
	    print "$verbose: current path is: $path\n";
	}

	print "$verbose: trying to $command\n";
    }

    # we are either in dry-run ...

    my $dry_run = $options->{dry_run} || $option_dry_run;

    if ($dry_run)
    {
	if ($export_sh
	    and exists $export_sh->{prefix})
	{
	    my $dry_run_prefix = "$0: *** Running in dry_run mode, export prefix: '";

	    print map { "$dry_run_prefix$_\n" } split "\n", $export_sh->{prefix};
	}

	$command = process_chdir_2_cd($command, $dry_run);

	print "$0: *** Running in dry_run mode, not executing: '$command'\n";

	# we do run the cd command to allow File::Spec to compute correct relative paths

	if ($command =~ /cd\s+(.*)$/)
	{
	    my $arguments = $1;

	    my $exit_status = not chdir $arguments;
	}
	else
	{
	    #! should die here?
	}
    }

    # ... or printing an interaction diagram

    elsif ($option_interaction)
    {
	my $interaction_indent = 4;

	my $is_new = "";

	if (exists $interaction_roles->{$current_interaction_role})
	{
	    $interaction_indent = $interaction_roles->{$current_interaction_role}->{indent};
	}
	else
	{
	    my $sorted_roles = [ keys %$interaction_roles, ];

	    $interaction_indent = 4 + scalar @$sorted_roles * 64;

	    $interaction_roles->{$current_interaction_role} = { indent => $interaction_indent, };

	    $is_new = 'yes';
	}

	my $indent = " " x $interaction_indent;

	if ($is_new)
	{
	    print "${indent}ROLE: '$current_interaction_role'\n\n";
	}

	if ($processed_command !~ /^\s*$/)
	{
	    print "$indent'$processed_command'\n";
	}
    }

    # ... or exporting to a shell executable script ...

    elsif (defined $option_export_sh)
    {
	if (not defined $global_exported_sh_file)
	{
	    if (not defined $global_exported_sh_filename)
	    {
		$global_exported_sh_filename = $export_sh->{filename};
	    }

	    my $ok = open($global_exported_sh_file, ">", $global_exported_sh_filename);

	    if (not $ok)
	    {
		die "*** Error: $0: cannot open $global_exported_sh_filename for writing ($!)";
	    }

	    print $global_exported_sh_file "#!/bin/sh\n";
	    print $global_exported_sh_file "#\n";
	    print $global_exported_sh_file "# script generated with $::global_program_name\n";
	    print $global_exported_sh_file "#\n";
	    print $global_exported_sh_file "# the command line to generate this script was:\n";
	    print $global_exported_sh_file "#\n";
	    print $global_exported_sh_file "# $global_command_line\n";
	    print $global_exported_sh_file "#\n";

	    chmod 0755, $global_exported_sh_filename;
	}

	$export_command = process_chdir_2_cd($export_command, $dry_run);

	# we do run the cd command to allow File::Spec to compute correct relative paths

	if ($export_command =~ /cd\s+(.*)$/)
	{
	    my $arguments = $1;

	    my $exit_status = not chdir $arguments;
	}
	else
	{
	    #! should die here?
	}

	if ($export_command =~ /^'/
	    and $export_command =~ /'$/)
	{
	    $export_command =~ s/^'//;
	    $export_command =~ s/'$//;
	}

	print "$0: *** Running in export_sh mode, exporting: '$export_command'\n";

	if ($option_export_verbose)
	{
	    print $global_exported_sh_file "echo '$export_command'\n";
	}

	if (exists $export_sh->{prefix})
	{
	    print $global_exported_sh_file $export_sh->{prefix};
	}

	print $global_exported_sh_file "$export_command\n";
    }

    # ... or we have to execute the given command

    else
    {
	my $exit_status;

	# force the execution of a change of the working directory to this process

	#! note that the \s+ is a bug: it forces the use of white-space when no arguments are given

	$command = process_chdir_2_cd($command, $dry_run);

	if ($command =~ /cd\s+(.*)$/)
	{
	    my $arguments = $1;

	    display_commented_command($command, $options);

	    $exit_status = not chdir $arguments;
	}
	else
	{
	    my $export_output = $options->{export_output};

	    if ($export_times)
	    {
		if (not defined $global_exported_times_file)
		{
		    if (not defined $global_exported_times_filename)
		    {
			$global_exported_times_filename = $export_times->{filename};
		    }

		    my $ok = open($global_exported_times_file, ">", $global_exported_times_filename);

		    if (not $ok)
		    {
			die "*** Error: $0: cannot open $global_exported_times_filename for writing ($!)";
		    }

		    print $global_exported_times_file "#!/bin/sh\n";
		    print $global_exported_times_file "#\n";
		    print $global_exported_times_file "# script generated with $::global_program_name\n";
		    print $global_exported_times_file "#\n";
		    print $global_exported_times_file "# the command line to generate this script was:\n";
		    print $global_exported_times_file "#\n";
		    print $global_exported_times_file "# $global_command_line\n";
		    print $global_exported_times_file "#\n";

		    chmod 0644, $global_exported_times_filename;
		}
	    }

	    # execute the command, collect start and end time

	    use IPC::System::Simple qw(capture);

	    my $start_time = time();

	    my $output = "";

	    if (not $command_is_empty)
	    {
		if (not $export_output)
		{
		    display_commented_command($command, $options);

		    $exit_status = system "$command";
		}
		else
		{
		    $output .= capture($command);

		    $exit_status = $IPC::System::Simple::EXITVAL;
		}
	    }

	    my $end_time = time();

	    if ($export_times)
	    {
		print $global_exported_times_file "$0: *** Starting ('$command') at " . localtime($start_time) . "\n";

		print $global_exported_times_file "$0: *** Ended    ('$command') at " . localtime($end_time) . "\n";

		print $global_exported_times_file "$0: *** Duration (s): " . ($end_time - $start_time) . "\n";

		print $global_exported_times_file "\n";
	    }

	    if ($export_output)
	    {
		my $filename = generate_output_filename($global_target_command, $command);

		my $output_file;

		my $ok = open($output_file, ">", $filename);

		if (not $ok)
		{
		    die "*** Error: $0: cannot open $filename for writing ($!)";
		}

		print $output_file "# $command\n#\n";

		print $output_file $output;

		close($output_file);
	    }
	    # else
	    # {
	    # 	print $output;
	    # }
	}

	my $output_path = $options->{output_path};

#     my $exit_status = system "( $command ) >>$output_path 2>&1";

	if ($exit_status)
	{
	    if ($allow_fail)
	    {
# 	    system "echo >>$output_path 2>&1 failed with $?: $command\n";

		print "$0: *** Note: $command was allowed to fail (because $allow_fail) and has exit status $?\n";
	    }
	    else
	    {
		die "$0: *** Fatal: $command failed with exit status $?\n";
	    }
	}

	return $exit_status;
    }
}


sub execute_shell_command_array
{
    my $commands = shift;

    my $options = shift;

    my $needs_rebuild = build_tree_needs_rebuild($options->{build_tree}, );

    if (not $needs_rebuild)
    {
	return 0;
    }

    foreach my $command (@$commands)
    {
	execute_shell_command($command, $options);
    }
}


sub execute_shell_command_schedule
{
    my $schedule = shift;

    my $command_array = $schedule->{commands};

    my $option_array = $schedule->{options};

    if (not defined $option_array)
    {
	$option_array = [ {}, ];
    }

    foreach my $options (@$option_array)
    {
	foreach my $command (@$command_array)
	{
	    execute_shell_command($command, $options);
	}
    }
}


sub execute_shell_command_schedule_array
{
    my $schedule_array = shift;

    foreach my $schedule (@$schedule_array)
    {
	execute_shell_command_schedule($schedule);
    }
}


# given a filename prefix and a 'command' generate an output filename
# for logging the output of the command.

our $output_filename_counter = 0;

sub generate_output_filename
{
    my $prefix = shift;

    my $command = shift;

    # a command three alphanumeric sequences that are used to
    # construct an abbreviation of the command for use in the
    # generated output filename

    #! I don't believe this has ever been fully tested, and I don't
    #! believe the regex is correct, it seems to miss anchors between
    #! the alphanumeric sequences.

    $command =~ /([a-z0-9]){0,5}(?:[a-z0-9]*)([a-z0-9]){0,5}(?:[a-z0-9]*)([a-z0-9]){0,5}(?:[a-z0-9]*)/i;

    my $one = defined $1 ? $1 : "one";

    my $two = defined $2 ? $2 : "two";

    my $three = defined $3 ? $3 : "three";

    # make sure the filename is unique to the given command

    $output_filename_counter++;

    # generate the filename

    my $result = "$prefix-$output_filename_counter-$one-$two-$three";

    # return result

    return $result;
}


package main;


sub bash_completion
{
    my $command_line = $option_bash_completion || "";

    my $command_line_words = [ split ' ', $command_line, ];

    #! kind of sloppy ...

    my $comp_cword = $option_target;

    my $comp_point = $ARGV[0];

    my $command_line_word = $command_line_words->[$comp_cword];

    my $arguments = [ split ' ', $command_line, ];

    my $command = shift @$arguments;

    my $result;

    if ($command =~ /configuration/)
    {
	$result = bash_completion_generate($command, $arguments, $global_configuration);

	push @$result, '--', '-1', '-2', '-3';
    }
    elsif ($command =~ /workflow/)
    {
	if (defined $command_line_word
	    and $command_line_word =~ /^-/)
	{
	    $result = bash_completion_generate_options();

	    unshift @$result, 'aa', 'bb';
	}
	else
	{
	    my $internal_commands = generate_command_hash();

	    $result = bash_completion_generate($command, $arguments, $internal_commands);

	    push @$result, '--a', '--b';
	}
    }

    print join " ", @$result;

    exit 0;
}


sub bash_completion_generate
{
    my $command = shift;

    my $arguments = shift;

    my $configuration = shift;

    # search the given arguments in the configuration

    while (@$arguments)
    {
	if (ref $configuration eq 'HASH')
	{
	    my $argument = shift @$arguments;

	    if (exists $configuration->{$argument})
	    {
		$configuration = $configuration->{$argument};
	    }
	}
	elsif (ref $configuration eq 'ARRAY')
	{
	    last;
	}
	else
	{
	    last;
	}
    }

    # return the result depending on its type

    if (ref $configuration eq 'HASH')
    {
	return [ keys %$configuration, ];
    }
    elsif (ref $configuration eq 'ARRAY')
    {
	return [ @$configuration, ];
    }
    else
    {
	return [];
    }
}


sub bash_completion_generate_options
{
    my $result = [
		  qw(
			--bash-completion
			--branch
			--build-server
			--built-image-directory
			--command
			--dry-run
			--export-remote
			--export-sh
			--export-times
			--forward-destination
			--forward-source
			--help
			--help-build-servers
			--help-commands
			--help-packages
			--help-projects
			--help-targets
			--incremental
			--interaction
			--packages
			--ssh-port
			--ssh-server
			--ssh-user
			--target
			--tftp-directory
			--verbose
		   )
		 ];

    return $result;
}


sub generate_command_hash
{
    my $commands = generate_command_list();

    # set default result

    my $result = {};

    # loop over all the found targets and commands

    foreach my $command (@$commands)
    {
	# extract the target and the subroutine from the generated string

	$command =~ m(([^ ]+) ([^ ]+))g;

	my $target = $1;

	my $subroutine = $2;

	# insert them into the result

	$result->{$target}->{$subroutine} = $command;
    }

    # return result

    return $result;
}


sub generate_command_list
{
    # generate a list of the available command subroutines

    my $subroutines = [
		       # clarify that they belong to the Command:: package

		       map
		       {
			   "Command::$_";
		       }

		       # select only code references

		       grep
		       {
			   not defined &$_;
		       }
		       keys %Command::,
		      ];

    # rework, select and sort these commands

    my $targets = $global_configuration->{targets};

    my $commands = [
		    # alphabatically group and make sense

		    sort

		    # remove internal commands and commands that don't belong to a target

		    grep
		    {
			$_ !~ /Command::/;
		    }

		    # remove Command:: package name and rework target prefixes

		    map
		    {
			foreach my $target (sort keys %$targets)
			{
			    $target =~ s/-/_/g;

			    s/Command::${target}_(.*)/${target} $1/g;
			}

			$_;
		    }

		    # all internal commands

		    sort @$subroutines,
		   ];

    return $commands;
}


sub main
{
    # this is YAML related, see for instance https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=707229

    $INC{'Mo/builder.pm'} = 1;
    $INC{'Mo/default.pm'} = 1;

    # initiallize business project related global configuration

    BusinessProject::_init();

    # initialize the command module

    Command::_init();

    # parse the local.mk packages to update the dynamically generated help pages

    $global_overriden_packages = buildroot_parse_packages_directories();

    # parse command line

    parse_command_line();

    # perform bash completion logic, this will exit the script

    if ($option_bash_completion)
    {
	bash_completion();
    }

    # parse package directories

    #t this will overwrite the code in the build directories with custom code for packages listed in local.mk.
    #t should set a flag whether a build will be required and honor the flag in preprocessing stages.

    buildroot_process_packages_directories($global_overriden_packages);

    # figure out the target and the command

    my $target = $option_target;

    my $command = $option_commands->[0];

    # we allow finger laziness: the shift key is not necessary for the underscore

    $target =~ s/-/_/g;
    $command =~ s/-/_/g;

    $global_target_command = "$target-$command";

    # given the target and the command generate a useful filename for exporting commands to a shell script

    if (defined $option_export_sh)
    {
	if ($option_export_sh eq 0)
	{
	    $option_export_sh = "/tmp/$global_target_command.sh";
	}
	elsif ($option_export_sh eq 1
	       or $option_export_sh eq '')
	{
	    $option_export_sh = "$global_target_command.sh";
	}

	# again we prefer to not need to press the shift key

	$option_export_sh =~ s/_/-/g;
    }

    # given the target and the command generate a useful filename for exporting execution times to a log file

    if (defined $option_export_times)
    {
	if ($option_export_times eq 0)
	{
	    $option_export_times = "/tmp/$global_target_command.times";
	}
	elsif ($option_export_times eq 1
	       or $option_export_times eq '')
	{
	    $option_export_times = "$global_target_command.times";
	}

	# again we prefer to not need to press the shift key

	$option_export_times =~ s/_/-/g;
    }

    # if we are using a build server

    if ($option_build_server)
    {
	die "$0: *** option_build_server is still in development";

	my $build_source = "";

	my $build_servers = $global_configuration->{build_servers};

	my $build_server = $build_servers->{$option_build_server};

	if ($build_server->{name} ne 'laptop')
	{
	    my $ssh_user = $build_server->{ssh_user};

	    my $ssh_server = $build_server->{ssh_server};

	    my $tftp_directory = $build_server->{tftp_directory};

	    $build_source .= "$ssh_user\@$ssh_server";
	}

	# this results in something like this:
	#
	# ssh cornelih@cbi.utsa.edu tmux new-session -d 'project-workflow ssp build && bash'
	#
	# but I will likely also need to use sendkeys to detach from the session
	# also need to cd to the correct directory

	Context::execute_shell_command("ssh $build_source tmux new-session -d 'neurospaces-workflow $target $command && bash'");
    }
    else
    {
	my $command_implementation = "Command::${target}_${command}";

	{
	    no strict "refs";

	    &$command_implementation();
	}
    }
}


sub parse_command_line
{
    my $result
        = GetOptions
	(
	 "bash-completion=s" => \$option_bash_completion,
	 "branch=s" => \$option_branch,
	 "build-server=s" => \$option_build_server,
	 "built-image-directory=s" => \$option_built_image_directory,
	 "command=s" => $option_commands,
	 "dry-run!" => \$option_dry_run,
	 "export-remote" => \$option_export_remote,
	 "export-sh:s" => \$option_export_sh,
	 "export-times!" => \$option_export_times,
	 "export-verbose!" => \$option_export_verbose,
	 "forward-destination-server=s" => \$option_forward_destination_server,
	 "forward-source-server=s" => \$option_forward_source_server,
	 "help!" => \$option_help,
	 "help-build-servers!" => \$option_help_build_servers,
	 "help-commands!" => \$option_help_commands,
	 "help-packages!" => \$option_help_packages,
	 "help-projects!" => \$option_help_projects,
	 "help-targets!" => \$option_help_targets,
	 "incremental!" => \$option_incremental,
	 "interaction!" => \$option_interaction,
	 "package=s" => $option_packages,
	 "ssh-port=s" => \$option_ssh_port,
	 "ssh-server=s" => \$option_ssh_server,
	 "ssh-user=s" => \$option_ssh_user,
	 "target=s" => \$option_target,
	 "tftp-directory=s" => \$option_tftp_directory,
	 "v|verbose+" => \$option_verbose,
	);

    if (!$result)
    {
        die "$0: *** error in option processing, try --help";
    }

    # my $asking_help = ($option_help
    # 		       or $option_help_build_servers
    # 		       or $option_help_commands
    # 		       or $option_help_packages
    # 		       or $option_help_projects
    # 		       or $option_help_targets);

    if (scalar @ARGV eq 0)
    {
	$option_commands->[0] = $default_command;
    }
    elsif (scalar @ARGV eq 1)
    {
	# no commands given, a single argument is the command

	$option_commands->[scalar @$option_commands] = $ARGV[0];
    }
    elsif (scalar @ARGV eq 2)
    {
	# giving both a target option and a target argument on the command line is an error, we can only take commands for one target

	if (defined $option_target)
	{
	    die "$0: *** Error: both a --target option and an target argument given, try --help";
	}

	$option_target = shift @ARGV;

	$option_commands->[scalar @$option_commands] = $ARGV[0];
    }
    else
    {
        die "$0: *** error in argument processing, try --help";
    }

    if (not defined $option_target)
    {
	$option_target = $default_target;
    }

    if ($option_help)
    {
        print
            "
$0: checkout and build the given targets

OVERRIDE_SRCDIR delivered packages for Buildroot targets are recognized.

examples -- first try these with the --dry-run to understand what they do:

  \$ $0                                                      # build the default target (the default target is '$default_target')

  \$ $0 ssp                                                  # build the 'ssp' target (if it exists for your local configuration)

  \$ $0 --dry-run                                            # display the commands that would be executed for the default target

  \$ $0 --help-targets                                       # display the available targets that are found in the configuration file

options:
    --bash-completion         compute bash completion for the given command line.
                              hint: the bash completion script implements completion for options, targets and commands.
    --branch                  git branch to work with.
    --build-server            the build server profile to work with.
    --built-image-directory   the directory on the build server where the built images are to be found.
    --command                 commands to execute, hyphens (-) will be replaced with underscores (_).
    --dry-run                 if set, do not execute system shell commands but print them to STDOUT.
    --export-remote           include the remote access part when exporting commands to a file.
    --export-sh               export the commands to a file with the given name.
    --export-times            export the times when commands are started and ended to a file with the given name.
    --export-verbose          when exporting the commands to a file, interleave them with echo commands.
    --forward-destination     the target file forward destination to copy to.
    --forward-source          the target file forward source to copy from.
    --help                    display usage information and stop execution.
    --help-build-servers      display the known build servers.
    --help-commands           display the available commands (requires the installation of Devel::Symdump with 'sudo cpanm Devel::Symdump').
    --help-packages           display known package and overriden package information and stop execution.
    --help-projects           display known project information and stop execution.
    --help-targets            display known targets and stop execution.
    --incremental             assume an incremental build (default is " . ($option_incremental ? "yes" : "no") . "
    --interaction             show the interaction diagram of the commands.
    --packages                packages to operate on, can be given multiple times.
    --ssh-port                the ssh port.
    --ssh-server              the used ssh build server.
    --ssh-user                ssh-user on the build server (please configure your public key).
    --target                  the target to build (default is '$option_target').
    --tftp-directory          the target tftp directory (where your device will find its kernel and rootfs).
    --verbose                 set verbosity level.
";

	exit 0;
    }

    if (defined $option_build_server)
    {
	my $build_servers = $global_configuration->{build_servers};

	if (not exists $build_servers->{$option_build_server})
	{
	    die "$0: *** Error: unknown build server $option_build_server, use --help-build-servers to learn about the known servers";
	}

	# if (not defined $option_ssh_server)
	# {
	#     $option_ssh_server = $build_servers->{$option_build_server}->{ssh_server};
	# }

	# if (not defined $option_ssh_user)
	# {
	#     $option_ssh_user = $build_servers->{$option_build_server}->{ssh_user};
	# }

	if (not defined $option_ssh_port)
	{
	    $option_ssh_port = $build_servers->{$option_build_server}->{ssh_port};
	}

	# if (not defined $option_tftp_directory)
	# {
	#     $option_tftp_directory = $build_servers->{$option_build_server}->{tftp_directory};
	# }

	# if (not defined $option_built_image_directory)
	# {
	#     $option_built_image_directory = $build_servers->{$option_build_server}->{built_image_directory};
	# }
    }

    my $build_servers = $global_configuration->{build_servers};

    if (defined $option_forward_destination_server)
    {
	if (not exists $build_servers->{$option_forward_destination_server})
	{
	    die "$0: *** Error: unknown forwarding server $option_forward_destination_server, use --help-build-servers to learn about the known servers";
	}
    }

    if (defined $option_forward_source_server)
    {
	if (not exists $build_servers->{$option_forward_source_server})
	{
	    die "$0: *** Error: unknown forwarding server $option_forward_source_server, use --help-build-servers to learn about the known servers";
	}
    }

    if ($option_help_build_servers)
    {
	use YAML;

	print Dump( { build_servers => $build_servers, }, );

	exit 0;
    }

    if ($option_help_commands)
    {
	use YAML;

	my $commands = generate_command_list();

	$commands
	    = [
	       map
	       {
		   "$global_program_name $_ --dry";
	       }
	       @$commands,
	      ];

	print Dump( { "available_commands (copy-paste the one you would like to execute, try it with the --dry option, execute it without this option)" => $commands, }, );

	exit 0;
    }

    if ($option_help_packages)
    {
	use YAML;

	my $packages = $global_configuration->{packages};

	print Dump( { global_packages => $packages, }, );

	print Dump( { global_overriden_packages => $global_overriden_packages, }, );

	exit 0;
    }

    # if ($option_help_node_configuration)
    # {
    # 	use YAML;

    # 	print Dump( { configuration => $global_node_configuration, }, );

    # 	exit 0;
    # }

    if ($option_help_projects)
    {
	use YAML;

	my $projects = $global_configuration->{projects};

	print Dump( { global_projects => $projects, }, );

	exit 0;
    }

    if ($option_help_targets)
    {
	use YAML;

	my $targets = $global_configuration->{targets};

	print Dump( { targets => $targets, }, );

	exit 0;
    }

}


# parse the package directories in local.mk

sub buildroot_parse_packages_directories
{
#     "$ENV{HOME}/projects/developer/source/snapshots/$branch";

    # packages listed in alphabetical order, dashes replaced with underscores

    my $package_overrides_filename = "local.mk";

    my $package_overrides;

    {
	# see also https://stackoverflow.com/questions/8963400/the-correct-way-to-read-a-data-file-into-an-array

	# local $/;		# enable localized slurp mode

	$package_overrides = [ `cat 2>/dev/null "$package_overrides_filename"` ];
    }

    # loop over all lines in local.mk

    my $overriden_packages;

    foreach my $package_override (@$package_overrides)
    {
	# we are only interested custom repositories

	if ($package_override !~ /_OVERRIDE_SRCDIR/)
	{
	    next;
	}

	if ($package_override =~ /_RSYNC_EXCLUSIONS/)
	{
	    next;
	}

	# skip comment lines

	if ($package_override =~ /^\s*#/)
	{
	    next;
	}

	#! beware of unmatched characters in the directory name

	$package_override =~ /^\s*(\w+)_OVERRIDE_SRCDIR\s*=\s*([\w\/\.-]*)/;

	my $package_name = lc $1;

	# # skip gcc related overrides, buildroot ignores them, we deal with them elsewhere

	# if ($package_name eq 'cr_gcc')
	# {
	#     next;
	# }

	my $package_directory = $2;

	$overriden_packages->{$package_name}->{directory} = $package_directory;

	if ($option_verbose)
	{
	    print "$0: *** added for package $package_name OVERRIDE_SRCDIR $package_directory\n";
	}
    }

    # propagate the overriden_packages

    return $overriden_packages;
}


# prepare the package directories in local.mk

sub buildroot_process_packages_directories
{
    my $overriden_packages = shift;

    # loop over all the overriden packages

    foreach my $package_name (sort keys %$overriden_packages)
    {
	# skip gcc related overrides, buildroot ignores them, we deal
	# with them in the build command of the toolchain target

	if ($package_name eq 'cr_gcc')
	{
	    next;
	}

	# get the package source directory from the override

	my $package_directory = $overriden_packages->{$package_name}->{directory};

	# get the build directory from the globally known packages

	my $packages = $global_configuration->{packages};

	my $build_directory = $packages->{$package_name}->{build_directory};

	if (not defined $build_directory)
	{
	    die "$0: *** Fatal: package $package_name has no build_directory defined in the package list";
	}

	# Context::execute_shell_command("mkdir --parents '$build_directory'");

	# Context::execute_shell_command("cp -a '$package_directory'/* '$build_directory'");

	# my $stamp_filenames = $global_configuration->{stamp_filenames};

	# my $stamp_built = $stamp_filenames->[0];

	# Context::execute_shell_command("rm -f '$build_directory/$stamp_built'");
    }
}


main();


